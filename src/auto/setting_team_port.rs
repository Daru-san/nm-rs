// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir
// from gtk-girs (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
use crate::TeamLinkWatcher;
use crate::{Setting, ffi};
use glib::{
    prelude::*,
    signal::{SignalHandlerId, connect_raw},
    translate::*,
};
use std::boxed::Box as Box_;

glib::wrapper! {
    #[doc(alias = "NMSettingTeamPort")]
    pub struct SettingTeamPort(Object<ffi::NMSettingTeamPort, ffi::NMSettingTeamPortClass>) @extends Setting;

    match fn {
        type_ => || ffi::nm_setting_team_port_get_type(),
    }
}

impl SettingTeamPort {
    #[doc(alias = "nm_setting_team_port_new")]
    pub fn new() -> SettingTeamPort {
        assert_initialized_main_thread!();
        unsafe { Setting::from_glib_full(ffi::nm_setting_team_port_new()).unsafe_cast() }
    }

    // rustdoc-stripper-ignore-next
    /// Creates a new builder-pattern struct instance to construct [`SettingTeamPort`] objects.
    ///
    /// This method returns an instance of [`SettingTeamPortBuilder`](crate::builders::SettingTeamPortBuilder) which can be used to create [`SettingTeamPort`] objects.
    pub fn builder() -> SettingTeamPortBuilder {
        SettingTeamPortBuilder::new()
    }

    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    #[doc(alias = "nm_setting_team_port_add_link_watcher")]
    pub fn add_link_watcher(&self, link_watcher: &TeamLinkWatcher) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_team_port_add_link_watcher(
                self.to_glib_none().0,
                link_watcher.to_glib_none().0,
            ))
        }
    }

    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    #[doc(alias = "nm_setting_team_port_clear_link_watchers")]
    pub fn clear_link_watchers(&self) {
        unsafe {
            ffi::nm_setting_team_port_clear_link_watchers(self.to_glib_none().0);
        }
    }

    #[doc(alias = "nm_setting_team_port_get_config")]
    #[doc(alias = "get_config")]
    pub fn config(&self) -> glib::GString {
        unsafe { from_glib_none(ffi::nm_setting_team_port_get_config(self.to_glib_none().0)) }
    }

    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    #[doc(alias = "nm_setting_team_port_get_lacp_key")]
    #[doc(alias = "get_lacp_key")]
    #[doc(alias = "lacp-key")]
    pub fn lacp_key(&self) -> i32 {
        unsafe { ffi::nm_setting_team_port_get_lacp_key(self.to_glib_none().0) }
    }

    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    #[doc(alias = "nm_setting_team_port_get_lacp_prio")]
    #[doc(alias = "get_lacp_prio")]
    #[doc(alias = "lacp-prio")]
    pub fn lacp_prio(&self) -> i32 {
        unsafe { ffi::nm_setting_team_port_get_lacp_prio(self.to_glib_none().0) }
    }

    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    #[doc(alias = "nm_setting_team_port_get_link_watcher")]
    #[doc(alias = "get_link_watcher")]
    pub fn link_watcher(&self, idx: u32) -> TeamLinkWatcher {
        unsafe {
            from_glib_none(ffi::nm_setting_team_port_get_link_watcher(
                self.to_glib_none().0,
                idx,
            ))
        }
    }

    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    #[doc(alias = "nm_setting_team_port_get_num_link_watchers")]
    #[doc(alias = "get_num_link_watchers")]
    pub fn num_link_watchers(&self) -> u32 {
        unsafe { ffi::nm_setting_team_port_get_num_link_watchers(self.to_glib_none().0) }
    }

    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    #[doc(alias = "nm_setting_team_port_get_prio")]
    #[doc(alias = "get_prio")]
    pub fn prio(&self) -> i32 {
        unsafe { ffi::nm_setting_team_port_get_prio(self.to_glib_none().0) }
    }

    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    #[doc(alias = "nm_setting_team_port_get_queue_id")]
    #[doc(alias = "get_queue_id")]
    #[doc(alias = "queue-id")]
    pub fn queue_id(&self) -> i32 {
        unsafe { ffi::nm_setting_team_port_get_queue_id(self.to_glib_none().0) }
    }

    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    #[doc(alias = "nm_setting_team_port_get_sticky")]
    #[doc(alias = "get_sticky")]
    #[doc(alias = "sticky")]
    pub fn is_sticky(&self) -> bool {
        unsafe { from_glib(ffi::nm_setting_team_port_get_sticky(self.to_glib_none().0)) }
    }

    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    #[doc(alias = "nm_setting_team_port_remove_link_watcher")]
    pub fn remove_link_watcher(&self, idx: u32) {
        unsafe {
            ffi::nm_setting_team_port_remove_link_watcher(self.to_glib_none().0, idx);
        }
    }

    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    #[doc(alias = "nm_setting_team_port_remove_link_watcher_by_value")]
    pub fn remove_link_watcher_by_value(&self, link_watcher: &TeamLinkWatcher) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_team_port_remove_link_watcher_by_value(
                self.to_glib_none().0,
                link_watcher.to_glib_none().0,
            ))
        }
    }

    pub fn set_config(&self, config: Option<&str>) {
        ObjectExt::set_property(self, "config", config)
    }

    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    #[doc(alias = "lacp-key")]
    pub fn set_lacp_key(&self, lacp_key: i32) {
        ObjectExt::set_property(self, "lacp-key", lacp_key)
    }

    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    #[doc(alias = "lacp-prio")]
    pub fn set_lacp_prio(&self, lacp_prio: i32) {
        ObjectExt::set_property(self, "lacp-prio", lacp_prio)
    }

    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    #[doc(alias = "link-watchers")]
    pub fn link_watchers(&self) -> Vec<TeamLinkWatcher> {
        let vals = ObjectExt::property::<glib::ValueArray>(self, "link-watchers");
        vals.iter()
            .map(|value| {
                use glib::value::FromValue;

                unsafe { TeamLinkWatcher::from_value(value) }
            })
            .collect()
    }

    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    #[doc(alias = "link-watchers")]
    pub fn set_link_watchers(&self, link_watchers: &[&TeamLinkWatcher]) {
        ObjectExt::set_property(
            self,
            "link-watchers",
            link_watchers
                .iter()
                .map(|team_link_watcher| team_link_watcher.to_value())
                .collect::<glib::ValueArray>(),
        )
    }

    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn set_prio(&self, prio: i32) {
        ObjectExt::set_property(self, "prio", prio)
    }

    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    #[doc(alias = "queue-id")]
    pub fn set_queue_id(&self, queue_id: i32) {
        ObjectExt::set_property(self, "queue-id", queue_id)
    }

    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn set_sticky(&self, sticky: bool) {
        ObjectExt::set_property(self, "sticky", sticky)
    }

    #[doc(alias = "config")]
    pub fn connect_config_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_config_trampoline<F: Fn(&SettingTeamPort) + 'static>(
            this: *mut ffi::NMSettingTeamPort,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::config".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_config_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    #[doc(alias = "lacp-key")]
    pub fn connect_lacp_key_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_lacp_key_trampoline<F: Fn(&SettingTeamPort) + 'static>(
            this: *mut ffi::NMSettingTeamPort,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::lacp-key".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_lacp_key_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    #[doc(alias = "lacp-prio")]
    pub fn connect_lacp_prio_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_lacp_prio_trampoline<F: Fn(&SettingTeamPort) + 'static>(
            this: *mut ffi::NMSettingTeamPort,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::lacp-prio".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_lacp_prio_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    #[doc(alias = "link-watchers")]
    pub fn connect_link_watchers_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_link_watchers_trampoline<F: Fn(&SettingTeamPort) + 'static>(
            this: *mut ffi::NMSettingTeamPort,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::link-watchers".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_link_watchers_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    #[doc(alias = "prio")]
    pub fn connect_prio_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_prio_trampoline<F: Fn(&SettingTeamPort) + 'static>(
            this: *mut ffi::NMSettingTeamPort,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::prio".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_prio_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    #[doc(alias = "queue-id")]
    pub fn connect_queue_id_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_queue_id_trampoline<F: Fn(&SettingTeamPort) + 'static>(
            this: *mut ffi::NMSettingTeamPort,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::queue-id".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_queue_id_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    #[doc(alias = "sticky")]
    pub fn connect_sticky_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_sticky_trampoline<F: Fn(&SettingTeamPort) + 'static>(
            this: *mut ffi::NMSettingTeamPort,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::sticky".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_sticky_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }
}

impl Default for SettingTeamPort {
    fn default() -> Self {
        Self::new()
    }
}

// rustdoc-stripper-ignore-next
/// A [builder-pattern] type to construct [`SettingTeamPort`] objects.
///
/// [builder-pattern]: https://doc.rust-lang.org/1.0.0/style/ownership/builders.html
#[must_use = "The builder must be built to be used"]
pub struct SettingTeamPortBuilder {
    builder: glib::object::ObjectBuilder<'static, SettingTeamPort>,
}

impl SettingTeamPortBuilder {
    fn new() -> Self {
        Self {
            builder: glib::object::Object::builder(),
        }
    }

    pub fn config(self, config: impl Into<glib::GString>) -> Self {
        Self {
            builder: self.builder.property("config", config.into()),
        }
    }

    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn lacp_key(self, lacp_key: i32) -> Self {
        Self {
            builder: self.builder.property("lacp-key", lacp_key),
        }
    }

    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn lacp_prio(self, lacp_prio: i32) -> Self {
        Self {
            builder: self.builder.property("lacp-prio", lacp_prio),
        }
    }

    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn link_watchers(self, link_watchers: &[&TeamLinkWatcher]) -> Self {
        Self {
            builder: self.builder.property(
                "link-watchers",
                link_watchers
                    .iter()
                    .map(|team_link_watcher| team_link_watcher.to_value())
                    .collect::<glib::ValueArray>(),
            ),
        }
    }

    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn prio(self, prio: i32) -> Self {
        Self {
            builder: self.builder.property("prio", prio),
        }
    }

    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn queue_id(self, queue_id: i32) -> Self {
        Self {
            builder: self.builder.property("queue-id", queue_id),
        }
    }

    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn sticky(self, sticky: bool) -> Self {
        Self {
            builder: self.builder.property("sticky", sticky),
        }
    }

    // rustdoc-stripper-ignore-next
    /// Build the [`SettingTeamPort`].
    #[must_use = "Building the object from the builder is usually expensive and is not expected to have side effects"]
    pub fn build(self) -> SettingTeamPort {
        assert_initialized_main_thread!();
        self.builder.build()
    }
}
