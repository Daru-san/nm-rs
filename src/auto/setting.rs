// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir
// from gtk-girs (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use crate::{Connection, SettingCompareFlags, SettingSecretFlags, ffi};
use glib::{
    prelude::*,
    signal::{SignalHandlerId, connect_raw},
    translate::*,
};
use std::boxed::Box as Box_;

glib::wrapper! {
    ///
    ///
    /// This is an Abstract Base Class, you cannot instantiate it.
    ///
    /// ## Properties
    ///
    ///
    /// #### `name`
    ///  The setting's name, which uniquely identifies the setting within the
    /// connection.  Each setting type has a name unique to that type, for
    /// example "ppp" or "802-11-wireless" or "802-3-ethernet".
    ///
    /// Readable
    ///
    /// # Implements
    ///
    /// [`SettingExt`][trait@crate::prelude::SettingExt]
    #[doc(alias = "NMSetting")]
    pub struct Setting(Object<ffi::NMSetting, ffi::NMSettingClass>);

    match fn {
        type_ => || ffi::nm_setting_get_type(),
    }
}

impl Setting {
    pub const NONE: Option<&'static Setting> = None;

    /// Get the type of the enum that defines the values that the property accepts. It is only
    /// useful for properties configured to accept values from certain enum type, otherwise
    /// it will return `G_TYPE_INVALID`. Note that flags (children of G_TYPE_FLAGS) are also
    /// considered enums.
    ///
    /// Note that the GObject property might be implemented as an integer, actually, and not
    /// as enum. Find out what underlying type is used, checking the #GParamSpec, before
    /// setting the GObject property.
    /// ## `setting_type`
    /// the GType of the NMSetting instance
    /// ## `property_name`
    /// the name of the property
    ///
    /// # Returns
    ///
    /// the enum's GType, or `G_TYPE_INVALID` if the property is not of enum type
    #[cfg(feature = "v1_46")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
    #[doc(alias = "nm_setting_get_enum_property_type")]
    #[doc(alias = "get_enum_property_type")]
    pub fn enum_property_type(
        setting_type: glib::types::Type,
        property_name: &str,
    ) -> glib::types::Type {
        assert_initialized_main_thread!();
        unsafe {
            from_glib(ffi::nm_setting_get_enum_property_type(
                setting_type.into_glib(),
                property_name.to_glib_none().0,
            ))
        }
    }

    /// Returns the #GType of the setting's class for a given setting name.
    /// ## `name`
    /// a setting name
    ///
    /// # Returns
    ///
    /// the #GType of the setting's class, or `G_TYPE_INVALID` if
    ///   @name is not recognized.
    #[doc(alias = "nm_setting_lookup_type")]
    pub fn lookup_type(name: &str) -> glib::types::Type {
        assert_initialized_main_thread!();
        unsafe { from_glib(ffi::nm_setting_lookup_type(name.to_glib_none().0)) }
    }
}

impl std::fmt::Display for Setting {
    #[inline]
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f.write_str(&SettingExt::to_str(self))
    }
}

/// Trait containing all [`struct@Setting`] methods.
///
/// # Implementors
///
/// [`Setting6Lowpan`][struct@crate::Setting6Lowpan], [`Setting8021x`][struct@crate::Setting8021x], [`SettingAdsl`][struct@crate::SettingAdsl], [`SettingBluetooth`][struct@crate::SettingBluetooth], [`SettingBondPort`][struct@crate::SettingBondPort], [`SettingBond`][struct@crate::SettingBond], [`SettingBridgePort`][struct@crate::SettingBridgePort], [`SettingBridge`][struct@crate::SettingBridge], [`SettingCdma`][struct@crate::SettingCdma], [`SettingConnection`][struct@crate::SettingConnection], [`SettingDcb`][struct@crate::SettingDcb], [`SettingDummy`][struct@crate::SettingDummy], [`SettingEthtool`][struct@crate::SettingEthtool], [`SettingGeneric`][struct@crate::SettingGeneric], [`SettingGsm`][struct@crate::SettingGsm], [`SettingHostname`][struct@crate::SettingHostname], [`SettingHsr`][struct@crate::SettingHsr], [`SettingIPConfig`][struct@crate::SettingIPConfig], [`SettingIPTunnel`][struct@crate::SettingIPTunnel], [`SettingInfiniband`][struct@crate::SettingInfiniband], [`SettingIpvlan`][struct@crate::SettingIpvlan], [`SettingLink`][struct@crate::SettingLink], [`SettingLoopback`][struct@crate::SettingLoopback], [`SettingMacsec`][struct@crate::SettingMacsec], [`SettingMacvlan`][struct@crate::SettingMacvlan], [`SettingMatch`][struct@crate::SettingMatch], [`SettingOlpcMesh`][struct@crate::SettingOlpcMesh], [`SettingOvsBridge`][struct@crate::SettingOvsBridge], [`SettingOvsDpdk`][struct@crate::SettingOvsDpdk], [`SettingOvsExternalIDs`][struct@crate::SettingOvsExternalIDs], [`SettingOvsOtherConfig`][struct@crate::SettingOvsOtherConfig], [`SettingOvsPatch`][struct@crate::SettingOvsPatch], [`SettingOvsPort`][struct@crate::SettingOvsPort], [`SettingPpp`][struct@crate::SettingPpp], [`SettingPppoe`][struct@crate::SettingPppoe], [`SettingPrefixDelegation`][struct@crate::SettingPrefixDelegation], [`SettingProxy`][struct@crate::SettingProxy], [`SettingSerial`][struct@crate::SettingSerial], [`SettingSriov`][struct@crate::SettingSriov], [`SettingTCConfig`][struct@crate::SettingTCConfig], [`SettingTeamPort`][struct@crate::SettingTeamPort], [`SettingTeam`][struct@crate::SettingTeam], [`SettingTun`][struct@crate::SettingTun], [`SettingUser`][struct@crate::SettingUser], [`SettingVeth`][struct@crate::SettingVeth], [`SettingVlan`][struct@crate::SettingVlan], [`SettingVpn`][struct@crate::SettingVpn], [`SettingVrf`][struct@crate::SettingVrf], [`SettingVxlan`][struct@crate::SettingVxlan], [`SettingWifiP2P`][struct@crate::SettingWifiP2P], [`SettingWimax`][struct@crate::SettingWimax], [`SettingWireGuard`][struct@crate::SettingWireGuard], [`SettingWired`][struct@crate::SettingWired], [`SettingWirelessSecurity`][struct@crate::SettingWirelessSecurity], [`SettingWireless`][struct@crate::SettingWireless], [`SettingWpan`][struct@crate::SettingWpan], [`Setting`][struct@crate::Setting]
pub trait SettingExt: IsA<Setting> + 'static {
    #[doc(alias = "nm_setting_compare")]
    fn compare(&self, b: &impl IsA<Setting>, flags: SettingCompareFlags) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_compare(
                self.as_ref().to_glib_none().0,
                b.as_ref().to_glib_none().0,
                flags.into_glib(),
            ))
        }
    }

    //#[doc(alias = "nm_setting_diff")]
    //fn diff(&self, b: &impl IsA<Setting>, flags: SettingCompareFlags, invert_results: bool, results: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 0, id: 7 }) -> bool {
    //    unsafe { TODO: call ffi:nm_setting_diff() }
    //}

    /// Duplicates a #NMSetting.
    ///
    /// # Returns
    ///
    /// a new #NMSetting containing the same properties and values as the
    /// source #NMSetting
    #[doc(alias = "nm_setting_duplicate")]
    #[must_use]
    fn duplicate(&self) -> Setting {
        unsafe { from_glib_full(ffi::nm_setting_duplicate(self.as_ref().to_glib_none().0)) }
    }

    //#[doc(alias = "nm_setting_enumerate_values")]
    //fn enumerate_values(&self, func: /*Unimplemented*/FnMut(&Setting, &str, /*Ignored*/glib::Value, /*Ignored*/glib::ParamFlags), user_data: /*Unimplemented*/Option<Basic: Pointer>) {
    //    unsafe { TODO: call ffi:nm_setting_enumerate_values() }
    //}

    //#[doc(alias = "nm_setting_get_dbus_property_type")]
    //#[doc(alias = "get_dbus_property_type")]
    //fn dbus_property_type(&self, property_name: &str) -> /*Ignored*/glib::VariantType {
    //    unsafe { TODO: call ffi:nm_setting_get_dbus_property_type() }
    //}

    /// Returns the type name of the #NMSetting object
    ///
    /// # Returns
    ///
    /// a string containing the type name of the #NMSetting object,
    /// like 'ppp' or 'wireless' or 'wired'.
    #[doc(alias = "nm_setting_get_name")]
    #[doc(alias = "get_name")]
    fn name(&self) -> glib::GString {
        unsafe { from_glib_none(ffi::nm_setting_get_name(self.as_ref().to_glib_none().0)) }
    }

    /// For a given secret, retrieves the #NMSettingSecretFlags describing how to
    /// handle that secret.
    /// ## `secret_name`
    /// the secret key name to get flags for
    /// ## `out_flags`
    /// on success, the #NMSettingSecretFlags for the secret
    ///
    /// # Returns
    ///
    /// [`true`] on success (if the given secret name was a valid property of
    /// this setting, and if that property is secret), [`false`] if not
    #[doc(alias = "nm_setting_get_secret_flags")]
    #[doc(alias = "get_secret_flags")]
    fn secret_flags(
        &self,
        secret_name: &str,
        out_flags: SettingSecretFlags,
    ) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::nm_setting_get_secret_flags(
                self.as_ref().to_glib_none().0,
                secret_name.to_glib_none().0,
                &mut out_flags.into_glib(),
                &mut error,
            );
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    //#[cfg(feature = "v1_26")]
    //#[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    //#[doc(alias = "nm_setting_option_clear_by_name")]
    //fn option_clear_by_name(&self, predicate: Option<&mut dyn FnMut() -> bool>) {
    //    unsafe { TODO: call ffi:nm_setting_option_clear_by_name() }
    //}

    //#[cfg(feature = "v1_26")]
    //#[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    //#[doc(alias = "nm_setting_option_get")]
    //fn option_get(&self, opt_name: &str) -> /*Ignored*/glib::Variant {
    //    unsafe { TODO: call ffi:nm_setting_option_get() }
    //}

    /// Gives the name of all set options.
    ///
    /// # Returns
    ///
    ///
    ///   A [`None`] terminated array of key names. If no names are present, this returns
    ///   [`None`]. The returned array and the names are owned by `NMSetting` and might be invalidated
    ///   by the next operation.
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    #[doc(alias = "nm_setting_option_get_all_names")]
    fn option_get_all_names(&self) -> Vec<glib::GString> {
        unsafe {
            let mut out_len = std::mem::MaybeUninit::uninit();
            let ret = FromGlibContainer::from_glib_none_num(
                ffi::nm_setting_option_get_all_names(
                    self.as_ref().to_glib_none().0,
                    out_len.as_mut_ptr(),
                ),
                out_len.assume_init() as _,
            );
            ret
        }
    }

    /// ## `opt_name`
    /// the option to get
    ///
    /// # Returns
    ///
    /// [`true`] if @opt_name is set to a boolean variant.
    ///
    /// ## `out_value`
    /// the optional output value.
    ///   If the option is unset, [`false`] will be returned.
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    #[doc(alias = "nm_setting_option_get_boolean")]
    fn option_get_boolean(&self, opt_name: &str) -> Option<bool> {
        unsafe {
            let mut out_value = std::mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::nm_setting_option_get_boolean(
                self.as_ref().to_glib_none().0,
                opt_name.to_glib_none().0,
                out_value.as_mut_ptr(),
            ));
            if ret { Some(true) } else { None }
        }
    }

    /// ## `opt_name`
    /// the option to get
    ///
    /// # Returns
    ///
    /// [`true`] if @opt_name is set to a uint32 variant.
    ///
    /// ## `out_value`
    /// the optional output value.
    ///   If the option is unset, 0 will be returned.
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    #[doc(alias = "nm_setting_option_get_uint32")]
    fn option_get_uint32(&self, opt_name: &str) -> Option<u32> {
        unsafe {
            let mut out_value = std::mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::nm_setting_option_get_uint32(
                self.as_ref().to_glib_none().0,
                opt_name.to_glib_none().0,
                out_value.as_mut_ptr(),
            ));
            if ret {
                Some(out_value.assume_init())
            } else {
                None
            }
        }
    }

    //#[cfg(feature = "v1_26")]
    //#[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    //#[doc(alias = "nm_setting_option_set")]
    //fn option_set(&self, opt_name: &str, variant: /*Ignored*/Option<&glib::Variant>) {
    //    unsafe { TODO: call ffi:nm_setting_option_set() }
    //}

    /// Like nm_setting_option_set() to set a boolean GVariant.
    /// ## `value`
    /// the value to set.
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    #[doc(alias = "nm_setting_option_set_boolean")]
    fn option_set_boolean(&self, opt_name: &str, value: bool) {
        unsafe {
            ffi::nm_setting_option_set_boolean(
                self.as_ref().to_glib_none().0,
                opt_name.to_glib_none().0,
                value.into_glib(),
            );
        }
    }

    /// Like nm_setting_option_set() to set a uint32 GVariant.
    /// ## `value`
    /// the value to set.
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    #[doc(alias = "nm_setting_option_set_uint32")]
    fn option_set_uint32(&self, opt_name: &str, value: u32) {
        unsafe {
            ffi::nm_setting_option_set_uint32(
                self.as_ref().to_glib_none().0,
                opt_name.to_glib_none().0,
                value,
            );
        }
    }

    /// For a given secret, stores the #NMSettingSecretFlags describing how to
    /// handle that secret.
    /// ## `secret_name`
    /// the secret key name to set flags for
    /// ## `flags`
    /// the #NMSettingSecretFlags for the secret
    ///
    /// # Returns
    ///
    /// [`true`] on success (if the given secret name was a valid property of
    /// this setting, and if that property is secret), [`false`] if not
    #[doc(alias = "nm_setting_set_secret_flags")]
    fn set_secret_flags(
        &self,
        secret_name: &str,
        flags: SettingSecretFlags,
    ) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::nm_setting_set_secret_flags(
                self.as_ref().to_glib_none().0,
                secret_name.to_glib_none().0,
                flags.into_glib(),
                &mut error,
            );
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    /// Convert the setting (including secrets!) into a string. For debugging
    /// purposes ONLY, should NOT be used for serialization of the setting,
    /// or machine-parsed in any way. The output format is not guaranteed to
    /// be stable and may change at any time.
    ///
    /// # Returns
    ///
    /// an allocated string containing a textual representation of the
    /// setting's properties and values, which the caller should
    /// free with g_free()
    #[doc(alias = "nm_setting_to_string")]
    #[doc(alias = "to_string")]
    fn to_str(&self) -> glib::GString {
        unsafe { from_glib_full(ffi::nm_setting_to_string(self.as_ref().to_glib_none().0)) }
    }

    /// Validates the setting.  Each setting's properties have allowed values, and
    /// some are dependent on other values (hence the need for @connection).  The
    /// returned #GError contains information about which property of the setting
    /// failed validation, and in what way that property failed validation.
    /// ## `connection`
    /// the #NMConnection that @self came from, or
    ///   [`None`] if @self is being verified in isolation.
    ///
    /// # Returns
    ///
    /// [`true`] if the setting is valid, [`false`] if it is not
    #[doc(alias = "nm_setting_verify")]
    fn verify(&self, connection: Option<&impl IsA<Connection>>) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::nm_setting_verify(
                self.as_ref().to_glib_none().0,
                connection.map(|p| p.as_ref()).to_glib_none().0,
                &mut error,
            );
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    /// Verifies the secrets in the setting.
    /// The returned #GError contains information about which secret of the setting
    /// failed validation, and in what way that secret failed validation.
    /// The secret validation is done separately from main setting validation, because
    /// in some cases connection failure is not desired just for the secrets.
    /// ## `connection`
    /// the #NMConnection that @self came from, or
    ///   [`None`] if @self is being verified in isolation.
    ///
    /// # Returns
    ///
    /// [`true`] if the setting secrets are valid, [`false`] if they are not
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    #[doc(alias = "nm_setting_verify_secrets")]
    fn verify_secrets(&self, connection: Option<&impl IsA<Connection>>) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::nm_setting_verify_secrets(
                self.as_ref().to_glib_none().0,
                connection.map(|p| p.as_ref()).to_glib_none().0,
                &mut error,
            );
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    #[doc(alias = "name")]
    fn connect_name_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_name_trampoline<P: IsA<Setting>, F: Fn(&P) + 'static>(
            this: *mut ffi::NMSetting,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(Setting::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::name".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_name_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }
}

impl<O: IsA<Setting>> SettingExt for O {}
