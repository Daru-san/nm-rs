// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir
// from gtk-girs (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT
#![allow(deprecated)]

use crate::{ffi,ActiveConnection,Connection,DeviceCapabilities,DeviceState,DeviceStateReason,DeviceType,DhcpConfig,IPConfig,Object,RemoteConnection};
#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
use crate::{LldpNeighbor,Metered};
#[cfg(feature = "v1_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
use crate::{ConnectivityState};
#[cfg(feature = "v1_22")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
use crate::{DeviceInterfaceFlags};
use glib::{object::ObjectType as _,prelude::*,signal::{connect_raw, SignalHandlerId},translate::*};
use std::{boxed::Box as Box_,pin::Pin};

glib::wrapper! {
    ///
    ///
    /// This is an Abstract Base Class, you cannot instantiate it.
    ///
    /// ## Properties
    ///
    ///
    /// #### `active-connection`
    ///  The #NMActiveConnection object that "owns" this device during activation.
    ///
    /// Readable
    ///
    ///
    /// #### `autoconnect`
    ///  Whether the device can auto-activate a connection.
    ///
    /// The property setter is a synchronous D-Bus call. This is deprecated since 1.22.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `available-connections`
    ///  The available connections of the device
    ///
    /// Readable
    ///
    ///
    /// #### `capabilities`
    ///  The capabilities of the device.
    ///
    /// Readable
    ///
    ///
    /// #### `device-type`
    ///  The numeric type of the device.
    ///
    /// Readable
    ///
    ///
    /// #### `dhcp4-config`
    ///  The IPv4 #NMDhcpConfig of the device.
    ///
    /// Readable
    ///
    ///
    /// #### `dhcp6-config`
    ///  The IPv6 #NMDhcpConfig of the device.
    ///
    /// Readable
    ///
    ///
    /// #### `driver`
    ///  The driver of the device.
    ///
    /// Readable
    ///
    ///
    /// #### `driver-version`
    ///  The version of the device driver.
    ///
    /// Readable
    ///
    ///
    /// #### `firmware-missing`
    ///  When [`true`] indicates the device is likely missing firmware required
    /// for its operation.
    ///
    /// Readable
    ///
    ///
    /// #### `firmware-version`
    ///  The firmware version of the device.
    ///
    /// Readable
    ///
    ///
    /// #### `hw-address`
    ///  The hardware address of the device.
    ///
    /// Readable
    ///
    ///
    /// #### `interface`
    ///  The interface of the device.
    ///
    /// Readable
    ///
    ///
    /// #### `interface-flags`
    ///  The interface flags.
    ///
    /// Readable
    ///
    ///
    /// #### `ip-interface`
    ///  The IP interface of the device which should be used for all IP-related
    /// operations like addressing and routing.
    ///
    /// Readable
    ///
    ///
    /// #### `ip4-config`
    ///  The #NMIP4Config of the device.
    ///
    /// Readable
    ///
    ///
    /// #### `ip4-connectivity`
    ///  The IPv4 connectivity state of the device.
    ///
    /// Readable
    ///
    ///
    /// #### `ip6-config`
    ///  The IPv6 #NMIPConfig of the device.
    ///
    /// Readable
    ///
    ///
    /// #### `ip6-connectivity`
    ///  The IPv6 connectivity state of the device.
    ///
    /// Readable
    ///
    ///
    /// #### `lldp-neighbors`
    ///  The LLDP neighbors.
    ///
    /// Readable
    ///
    ///
    /// #### `managed`
    ///  Whether the device is managed by NetworkManager.
    ///
    /// Readable
    ///
    ///
    /// #### `metered`
    ///  Whether the device is metered.
    ///
    /// Readable
    ///
    ///
    /// #### `mtu`
    ///  The MTU of the device.
    ///
    /// Readable
    ///
    ///
    /// #### `nm-plugin-missing`
    ///  When [`true`] indicates that the NetworkManager plugin for the device
    /// is not installed.
    ///
    /// Readable
    ///
    ///
    /// #### `path`
    ///  The device path as exposed by the udev property ID_PATH.
    ///
    /// The string is backslash escaped (C escaping) for invalid
    /// characters. The escaping can be reverted with g_strcompress(),
    /// however the result may not be valid UTF-8.
    ///
    /// Readable
    ///
    ///
    /// #### `physical-port-id`
    ///  The physical port ID of the device. (See
    /// nm_device_get_physical_port_id().)
    ///
    /// Readable
    ///
    ///
    /// #### `ports`
    ///  The port devices of the controller device. For devices that cannot be
    /// controllers this is likely to be always empty.
    ///
    /// Readable
    ///
    ///
    /// #### `product`
    ///  The product string of the device.
    ///
    /// Readable
    ///
    ///
    /// #### `real`
    ///  Whether the device is real or is a placeholder device that could
    /// be created automatically by NetworkManager if one of its
    /// #NMDevice:available-connections was activated.
    ///
    /// Readable
    ///
    ///
    /// #### `state`
    ///  The state of the device.
    ///
    /// Readable
    ///
    ///
    /// #### `state-reason`
    ///  The reason for the device state.
    ///
    /// Readable
    ///
    ///
    /// #### `udi`
    ///  An operating-system specific device hardware identifier; this is not
    /// unique to a specific hardware device across reboots or hotplugs.  It
    /// is an opaque string which for some device types (Bluetooth, Modem)
    /// contains an identifier provided by the underlying hardware service daemon
    /// such as Bluez or ModemManager, and clients can use this property to
    /// request more information about the device from those services.
    ///
    /// Readable
    ///
    ///
    /// #### `vendor`
    ///  The vendor string of the device.
    ///
    /// Readable
    /// <details><summary><h4>Object</h4></summary>
    ///
    ///
    /// #### `client`
    ///  The NMClient instance as returned by nm_object_get_client().
    ///
    /// When an NMObject gets removed from the NMClient cache,
    /// the NMObject:path property stays unchanged, but this client
    /// instance gets reset to [`None`]. You can use this property to
    /// track removal of the object from the cache.
    ///
    /// Readable
    ///
    ///
    /// #### `path`
    ///  The D-Bus object path.
    ///
    /// The D-Bus path of an object instance never changes, even if the object
    /// gets removed from the cache. To see whether the object is still in the
    /// cache, check NMObject:client.
    ///
    /// Readable
    /// </details>
    ///
    /// ## Signals
    ///
    ///
    /// #### `state-changed`
    ///  Notifies the state change of a #NMDevice.
    ///
    ///
    ///
    /// # Implements
    ///
    /// [`DeviceExt`][trait@crate::prelude::DeviceExt], [`ObjectExt`][trait@crate::prelude::ObjectExt]
    #[doc(alias = "NMDevice")]
    pub struct Device(Object<ffi::NMDevice, ffi::NMDeviceClass>) @extends Object;

    match fn {
        type_ => || ffi::nm_device_get_type(),
    }
}

impl Device {
        pub const NONE: Option<&'static Device> = None;
    

    /// Generates a list of short-ish unique presentation names for the
    /// devices in @devices.
    /// ## `devices`
    /// an array of #NMDevice
    ///
    /// # Returns
    ///
    /// the device names
    #[doc(alias = "nm_device_disambiguate_names")]
    pub fn disambiguate_names(devices: &[Device]) -> Vec<glib::GString> {
        assert_initialized_main_thread!();
        let num_devices = devices.len() as _;
        unsafe {
            FromGlibPtrContainer::from_glib_full(ffi::nm_device_disambiguate_names(devices.to_glib_none().0, num_devices))
        }
    }
}

/// Trait containing all [`struct@Device`] methods.
///
/// # Implementors
///
/// [`Device6Lowpan`][struct@crate::Device6Lowpan], [`DeviceAdsl`][struct@crate::DeviceAdsl], [`DeviceBond`][struct@crate::DeviceBond], [`DeviceBridge`][struct@crate::DeviceBridge], [`DeviceBt`][struct@crate::DeviceBt], [`DeviceDummy`][struct@crate::DeviceDummy], [`DeviceEthernet`][struct@crate::DeviceEthernet], [`DeviceGeneric`][struct@crate::DeviceGeneric], [`DeviceHsr`][struct@crate::DeviceHsr], [`DeviceIPTunnel`][struct@crate::DeviceIPTunnel], [`DeviceInfiniband`][struct@crate::DeviceInfiniband], [`DeviceIpvlan`][struct@crate::DeviceIpvlan], [`DeviceLoopback`][struct@crate::DeviceLoopback], [`DeviceMacsec`][struct@crate::DeviceMacsec], [`DeviceMacvlan`][struct@crate::DeviceMacvlan], [`DeviceModem`][struct@crate::DeviceModem], [`DeviceOlpcMesh`][struct@crate::DeviceOlpcMesh], [`DeviceOvsBridge`][struct@crate::DeviceOvsBridge], [`DeviceOvsPort`][struct@crate::DeviceOvsPort], [`DevicePpp`][struct@crate::DevicePpp], [`DeviceTeam`][struct@crate::DeviceTeam], [`DeviceTun`][struct@crate::DeviceTun], [`DeviceVlan`][struct@crate::DeviceVlan], [`DeviceVrf`][struct@crate::DeviceVrf], [`DeviceVxlan`][struct@crate::DeviceVxlan], [`DeviceWifiP2P`][struct@crate::DeviceWifiP2P], [`DeviceWifi`][struct@crate::DeviceWifi], [`DeviceWimax`][struct@crate::DeviceWimax], [`DeviceWireGuard`][struct@crate::DeviceWireGuard], [`DeviceWpan`][struct@crate::DeviceWpan], [`Device`][struct@crate::Device]
pub trait DeviceExt: IsA<Device> + 'static {
    /// Validates a given connection for a given #NMDevice object and returns
    /// whether the connection may be activated with the device. For example if
    /// @self is a Wi-Fi device that supports only WEP encryption, the connection
    /// will only be valid if it is a Wi-Fi connection which describes a WEP or open
    /// network, and will not be valid if it describes a WPA network, or if it is
    /// an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
    /// device.
    ///
    /// This function does the same as nm_device_connection_valid(), i.e. checking
    /// compatibility of the given device and connection. But, in addition, it sets
    /// GError when FALSE is returned.
    /// ## `connection`
    /// an #NMConnection to validate against @self
    ///
    /// # Returns
    ///
    /// [`true`] if the connection may be activated with this device, [`false`]
    /// if is incompatible with the device's capabilities and characteristics.
    #[doc(alias = "nm_device_connection_compatible")]
    fn connection_compatible(&self, connection: &impl IsA<Connection>) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::nm_device_connection_compatible(self.as_ref().to_glib_none().0, connection.as_ref().to_glib_none().0, &mut error);
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
        }
    }

    /// Validates a given connection for a given #NMDevice object and returns
    /// whether the connection may be activated with the device. For example if
    /// @self is a Wi-Fi device that supports only WEP encryption, the connection
    /// will only be valid if it is a Wi-Fi connection which describes a WEP or open
    /// network, and will not be valid if it describes a WPA network, or if it is
    /// an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
    /// device.
    /// ## `connection`
    /// an #NMConnection to validate against @self
    ///
    /// # Returns
    ///
    /// [`true`] if the connection may be activated with this device, [`false`]
    /// if is incompatible with the device's capabilities and characteristics.
    #[doc(alias = "nm_device_connection_valid")]
    fn connection_valid(&self, connection: &impl IsA<Connection>) -> bool {
        unsafe {
            from_glib(ffi::nm_device_connection_valid(self.as_ref().to_glib_none().0, connection.as_ref().to_glib_none().0))
        }
    }

    /// Deletes the software device. Hardware devices can't be deleted.
    ///
    /// # Deprecated since 1.22
    ///
    /// Use nm_device_delete_async() or GDBusConnection.
    /// ## `cancellable`
    /// a #GCancellable, or [`None`]
    ///
    /// # Returns
    ///
    /// [`true`] on success, [`false`] on error, in which case @error
    /// will be set.
    #[cfg_attr(feature = "v1_22", deprecated = "Since 1.22")]
    #[allow(deprecated)]
    #[doc(alias = "nm_device_delete")]
    fn delete(&self, cancellable: Option<&impl IsA<gio::Cancellable>>) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::nm_device_delete(self.as_ref().to_glib_none().0, cancellable.map(|p| p.as_ref()).to_glib_none().0, &mut error);
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
        }
    }

    /// Asynchronously begins deleting the software device. Hardware devices can't
    /// be deleted.
    /// ## `cancellable`
    /// a #GCancellable, or [`None`]
    /// ## `callback`
    /// callback to be called when delete operation completes
    #[doc(alias = "nm_device_delete_async")]
    fn delete_async<P: FnOnce(Result<(), glib::Error>) + 'static>(&self, cancellable: Option<&impl IsA<gio::Cancellable>>, callback: P) {
        
                let main_context = glib::MainContext::ref_thread_default();
                let is_main_context_owner = main_context.is_owner();
                let has_acquired_main_context = (!is_main_context_owner)
                    .then(|| main_context.acquire().ok())
                    .flatten();
                assert!(
                    is_main_context_owner || has_acquired_main_context.is_some(),
                    "Async operations only allowed if the thread is owning the MainContext"
                );
        
        let user_data: Box_<glib::thread_guard::ThreadGuard<P>> = Box_::new(glib::thread_guard::ThreadGuard::new(callback));
        unsafe extern "C" fn delete_async_trampoline<P: FnOnce(Result<(), glib::Error>) + 'static>(_source_object: *mut glib::gobject_ffi::GObject, res: *mut gio::ffi::GAsyncResult, user_data: glib::ffi::gpointer) {
            let mut error = std::ptr::null_mut();
            ffi::nm_device_delete_finish(_source_object as *mut _, res, &mut error);
            let result = if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) };
            let callback: Box_<glib::thread_guard::ThreadGuard<P>> = Box_::from_raw(user_data as *mut _);
            let callback: P = callback.into_inner();
            callback(result);
        }
        let callback = delete_async_trampoline::<P>;
        unsafe {
            ffi::nm_device_delete_async(self.as_ref().to_glib_none().0, cancellable.map(|p| p.as_ref()).to_glib_none().0, Some(callback), Box_::into_raw(user_data) as *mut _);
        }
    }

    
    fn delete_future(&self) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>> {

        Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
            obj.delete_async(
                Some(cancellable),
                move |res| {
                    send.resolve(res);
                },
            );
        }))
    }

    /// Disconnects the device if currently connected, and prevents the device from
    /// automatically connecting to networks until the next manual network connection
    /// request.
    ///
    /// # Deprecated since 1.22
    ///
    /// Use nm_device_disconnect_async() or GDBusConnection.
    /// ## `cancellable`
    /// a #GCancellable, or [`None`]
    ///
    /// # Returns
    ///
    /// [`true`] on success, [`false`] on error, in which case @error will be set.
    #[cfg_attr(feature = "v1_22", deprecated = "Since 1.22")]
    #[allow(deprecated)]
    #[doc(alias = "nm_device_disconnect")]
    fn disconnect(&self, cancellable: Option<&impl IsA<gio::Cancellable>>) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::nm_device_disconnect(self.as_ref().to_glib_none().0, cancellable.map(|p| p.as_ref()).to_glib_none().0, &mut error);
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
        }
    }

    /// Asynchronously begins disconnecting the device if currently connected, and
    /// prevents the device from automatically connecting to networks until the next
    /// manual network connection request.
    /// ## `cancellable`
    /// a #GCancellable, or [`None`]
    /// ## `callback`
    /// callback to be called when the disconnect operation completes
    #[doc(alias = "nm_device_disconnect_async")]
    fn disconnect_async<P: FnOnce(Result<(), glib::Error>) + 'static>(&self, cancellable: Option<&impl IsA<gio::Cancellable>>, callback: P) {
        
                let main_context = glib::MainContext::ref_thread_default();
                let is_main_context_owner = main_context.is_owner();
                let has_acquired_main_context = (!is_main_context_owner)
                    .then(|| main_context.acquire().ok())
                    .flatten();
                assert!(
                    is_main_context_owner || has_acquired_main_context.is_some(),
                    "Async operations only allowed if the thread is owning the MainContext"
                );
        
        let user_data: Box_<glib::thread_guard::ThreadGuard<P>> = Box_::new(glib::thread_guard::ThreadGuard::new(callback));
        unsafe extern "C" fn disconnect_async_trampoline<P: FnOnce(Result<(), glib::Error>) + 'static>(_source_object: *mut glib::gobject_ffi::GObject, res: *mut gio::ffi::GAsyncResult, user_data: glib::ffi::gpointer) {
            let mut error = std::ptr::null_mut();
            ffi::nm_device_disconnect_finish(_source_object as *mut _, res, &mut error);
            let result = if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) };
            let callback: Box_<glib::thread_guard::ThreadGuard<P>> = Box_::from_raw(user_data as *mut _);
            let callback: P = callback.into_inner();
            callback(result);
        }
        let callback = disconnect_async_trampoline::<P>;
        unsafe {
            ffi::nm_device_disconnect_async(self.as_ref().to_glib_none().0, cancellable.map(|p| p.as_ref()).to_glib_none().0, Some(callback), Box_::into_raw(user_data) as *mut _);
        }
    }

    
    fn disconnect_future(&self) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>> {

        Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
            obj.disconnect_async(
                Some(cancellable),
                move |res| {
                    send.resolve(res);
                },
            );
        }))
    }

    /// Filters a given array of connections for a given #NMDevice object and returns
    /// connections which may be activated with the device. For example if @self
    /// is a Wi-Fi device that supports only WEP encryption, the returned array will
    /// contain any Wi-Fi connections in @connections that allow connection to
    /// unencrypted or WEP-enabled SSIDs.  The returned array will not contain
    /// Ethernet, Bluetooth, Wi-Fi WPA connections, or any other connection that is
    /// incompatible with the device. To get the full list of connections see
    /// nm_client_get_connections().
    /// ## `connections`
    /// an array of #NMConnections to filter
    ///
    /// # Returns
    ///
    /// an array of
    /// #NMConnections that could be activated with the given @self.  The array
    /// should be freed with g_ptr_array_unref() when it is no longer required.
    ///
    /// WARNING: the transfer annotation for this function may not work correctly
    ///   with bindings. See https://gitlab.gnome.org/GNOME/gobject-introspection/-/issues/305.
    ///   You can filter the list yourself with nm_device_connection_valid().
    #[doc(alias = "nm_device_filter_connections")]
    fn filter_connections(&self, connections: &[Connection]) -> Vec<Connection> {
        unsafe {
            FromGlibPtrContainer::from_glib_full(ffi::nm_device_filter_connections(self.as_ref().to_glib_none().0, connections.to_glib_none().0))
        }
    }

    /// Gets the #NMActiveConnection object which owns this device during activation.
    ///
    /// # Returns
    ///
    /// the #NMActiveConnection or [`None`] if the device is
    /// not part of an active connection
    #[doc(alias = "nm_device_get_active_connection")]
    #[doc(alias = "get_active_connection")]
    #[doc(alias = "active-connection")]
    fn active_connection(&self) -> ActiveConnection {
        unsafe {
            from_glib_none(ffi::nm_device_get_active_connection(self.as_ref().to_glib_none().0))
        }
    }

    /// Fetch the currently applied connection on the device.
    ///
    /// # Deprecated since 1.22
    ///
    /// Use nm_device_get_applied_connection_async() or GDBusConnection.
    /// ## `flags`
    /// the flags argument. See #NMDeviceReapplyFlags.
    /// ## `cancellable`
    /// a #GCancellable, or [`None`]
    ///
    /// # Returns
    ///
    /// a `NMConnection` with the currently applied settings
    ///   or [`None`] on error.
    ///
    /// The connection is as received from D-Bus and might not validate according
    /// to nm_connection_verify().
    ///
    /// ## `version_id`
    /// returns the current version id of
    ///   the applied connection
    #[cfg_attr(feature = "v1_22", deprecated = "Since 1.22")]
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    #[allow(deprecated)]
    #[doc(alias = "nm_device_get_applied_connection")]
    #[doc(alias = "get_applied_connection")]
    fn applied_connection(&self, flags: u32, cancellable: Option<&impl IsA<gio::Cancellable>>) -> Result<(Connection, u64), glib::Error> {
        unsafe {
            let mut version_id = std::mem::MaybeUninit::uninit();
            let mut error = std::ptr::null_mut();
            let ret = ffi::nm_device_get_applied_connection(self.as_ref().to_glib_none().0, flags, version_id.as_mut_ptr(), cancellable.map(|p| p.as_ref()).to_glib_none().0, &mut error);
            if error.is_null() { Ok((from_glib_full(ret), version_id.assume_init())) } else { Err(from_glib_full(error)) }
        }
    }

    /// Asynchronously begins and gets the currently applied connection.
    /// ## `flags`
    /// the flags argument. See #NMDeviceReapplyFlags.
    /// ## `cancellable`
    /// a #GCancellable, or [`None`]
    /// ## `callback`
    /// callback to be called when the reapply operation completes
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    #[doc(alias = "nm_device_get_applied_connection_async")]
    #[doc(alias = "get_applied_connection_async")]
    fn applied_connection_async<P: FnOnce(Result<(Connection, u64), glib::Error>) + 'static>(&self, flags: u32, cancellable: Option<&impl IsA<gio::Cancellable>>, callback: P) {
        
                let main_context = glib::MainContext::ref_thread_default();
                let is_main_context_owner = main_context.is_owner();
                let has_acquired_main_context = (!is_main_context_owner)
                    .then(|| main_context.acquire().ok())
                    .flatten();
                assert!(
                    is_main_context_owner || has_acquired_main_context.is_some(),
                    "Async operations only allowed if the thread is owning the MainContext"
                );
        
        let user_data: Box_<glib::thread_guard::ThreadGuard<P>> = Box_::new(glib::thread_guard::ThreadGuard::new(callback));
        unsafe extern "C" fn applied_connection_async_trampoline<P: FnOnce(Result<(Connection, u64), glib::Error>) + 'static>(_source_object: *mut glib::gobject_ffi::GObject, res: *mut gio::ffi::GAsyncResult, user_data: glib::ffi::gpointer) {
            let mut error = std::ptr::null_mut();
            let mut version_id = std::mem::MaybeUninit::uninit();
            let ret = ffi::nm_device_get_applied_connection_finish(_source_object as *mut _, res, version_id.as_mut_ptr(), &mut error);
            let result = if error.is_null() { Ok((from_glib_full(ret), version_id.assume_init())) } else { Err(from_glib_full(error)) };
            let callback: Box_<glib::thread_guard::ThreadGuard<P>> = Box_::from_raw(user_data as *mut _);
            let callback: P = callback.into_inner();
            callback(result);
        }
        let callback = applied_connection_async_trampoline::<P>;
        unsafe {
            ffi::nm_device_get_applied_connection_async(self.as_ref().to_glib_none().0, flags, cancellable.map(|p| p.as_ref()).to_glib_none().0, Some(callback), Box_::into_raw(user_data) as *mut _);
        }
    }

    
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    fn applied_connection_future(&self, flags: u32) -> Pin<Box_<dyn std::future::Future<Output = Result<(Connection, u64), glib::Error>> + 'static>> {

        Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
            obj.applied_connection_async(
                flags,
                Some(cancellable),
                move |res| {
                    send.resolve(res);
                },
            );
        }))
    }

    /// Whether the #NMDevice can be autoconnected.
    ///
    /// # Returns
    ///
    /// [`true`] if the device is allowed to be autoconnected
    #[doc(alias = "nm_device_get_autoconnect")]
    #[doc(alias = "get_autoconnect")]
    #[doc(alias = "autoconnect")]
    fn is_autoconnect(&self) -> bool {
        unsafe {
            from_glib(ffi::nm_device_get_autoconnect(self.as_ref().to_glib_none().0))
        }
    }

    /// Gets the #NMRemoteConnections currently known to the daemon that could
    /// be activated on @self.
    ///
    /// # Returns
    ///
    /// the #GPtrArray
    /// containing #NMRemoteConnections. This is the internal copy used by
    /// the connection, and must not be modified.
    #[doc(alias = "nm_device_get_available_connections")]
    #[doc(alias = "get_available_connections")]
    #[doc(alias = "available-connections")]
    fn available_connections(&self) -> Vec<RemoteConnection> {
        unsafe {
            FromGlibPtrContainer::from_glib_none(ffi::nm_device_get_available_connections(self.as_ref().to_glib_none().0))
        }
    }

    /// Gets the device' capabilities.
    ///
    /// # Returns
    ///
    /// the capabilities
    #[doc(alias = "nm_device_get_capabilities")]
    #[doc(alias = "get_capabilities")]
    fn capabilities(&self) -> DeviceCapabilities {
        unsafe {
            from_glib(ffi::nm_device_get_capabilities(self.as_ref().to_glib_none().0))
        }
    }

    /// The connectivity state of the device for given address family.
    /// Supported address families are `AF_INET` for IPv4, `AF_INET6`
    /// for IPv6 or `AF_UNSPEC` for any.
    /// ## `addr_family`
    /// network address family
    ///
    /// # Returns
    ///
    /// the current connectivity state
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    #[doc(alias = "nm_device_get_connectivity")]
    #[doc(alias = "get_connectivity")]
    fn connectivity(&self, addr_family: i32) -> ConnectivityState {
        unsafe {
            from_glib(ffi::nm_device_get_connectivity(self.as_ref().to_glib_none().0, addr_family))
        }
    }

    /// Gets a description of @self, based on its vendor and product names.
    ///
    /// # Returns
    ///
    /// a description of @self. If either the vendor or the
    ///   product name is unknown, this returns the interface name.
    #[doc(alias = "nm_device_get_description")]
    #[doc(alias = "get_description")]
    fn description(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_device_get_description(self.as_ref().to_glib_none().0))
        }
    }

    /// Returns the numeric type of the #NMDevice, ie Ethernet, Wi-Fi, etc.
    ///
    /// # Returns
    ///
    /// the device type
    #[doc(alias = "nm_device_get_device_type")]
    #[doc(alias = "get_device_type")]
    #[doc(alias = "device-type")]
    fn device_type(&self) -> DeviceType {
        unsafe {
            from_glib(ffi::nm_device_get_device_type(self.as_ref().to_glib_none().0))
        }
    }

    /// Gets the current IPv4 #NMDhcpConfig associated with the #NMDevice.
    ///
    /// You can alternatively use nm_active_connection_get_dhcp4_config(), which also
    /// works with VPN connections.
    ///
    /// # Returns
    ///
    /// the IPv4 #NMDhcpConfig, or [`None`] if the device is
    /// not activated or not using DHCP.
    #[doc(alias = "nm_device_get_dhcp4_config")]
    #[doc(alias = "get_dhcp4_config")]
    #[doc(alias = "dhcp4-config")]
    fn dhcp4_config(&self) -> DhcpConfig {
        unsafe {
            from_glib_none(ffi::nm_device_get_dhcp4_config(self.as_ref().to_glib_none().0))
        }
    }

    /// Gets the current IPv6 #NMDhcpConfig associated with the #NMDevice.
    ///
    /// You can alternatively use nm_active_connection_get_dhcp6_config(), which also
    /// works with VPN connections.
    ///
    /// # Returns
    ///
    /// the IPv6 #NMDhcpConfig, or [`None`] if the device is
    /// not activated or not using DHCPv6.
    #[doc(alias = "nm_device_get_dhcp6_config")]
    #[doc(alias = "get_dhcp6_config")]
    #[doc(alias = "dhcp6-config")]
    fn dhcp6_config(&self) -> DhcpConfig {
        unsafe {
            from_glib_none(ffi::nm_device_get_dhcp6_config(self.as_ref().to_glib_none().0))
        }
    }

    /// Gets the driver of the #NMDevice.
    ///
    /// # Returns
    ///
    /// the driver of the device. This is the internal string used by the
    /// device, and must not be modified.
    #[doc(alias = "nm_device_get_driver")]
    #[doc(alias = "get_driver")]
    fn driver(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_device_get_driver(self.as_ref().to_glib_none().0))
        }
    }

    /// Gets the driver version of the #NMDevice.
    ///
    /// # Returns
    ///
    /// the version of the device driver. This is the internal string used by the
    /// device, and must not be modified.
    #[doc(alias = "nm_device_get_driver_version")]
    #[doc(alias = "get_driver_version")]
    #[doc(alias = "driver-version")]
    fn driver_version(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_device_get_driver_version(self.as_ref().to_glib_none().0))
        }
    }

    /// Indicates that firmware required for the device's operation is likely
    /// to be missing.
    ///
    /// # Returns
    ///
    /// [`true`] if firmware required for the device's operation is likely
    /// to be missing.
    #[doc(alias = "nm_device_get_firmware_missing")]
    #[doc(alias = "get_firmware_missing")]
    #[doc(alias = "firmware-missing")]
    fn is_firmware_missing(&self) -> bool {
        unsafe {
            from_glib(ffi::nm_device_get_firmware_missing(self.as_ref().to_glib_none().0))
        }
    }

    /// Gets the firmware version of the #NMDevice.
    ///
    /// # Returns
    ///
    /// the firmware version of the device. This is the internal string used by the
    /// device, and must not be modified.
    #[doc(alias = "nm_device_get_firmware_version")]
    #[doc(alias = "get_firmware_version")]
    #[doc(alias = "firmware-version")]
    fn firmware_version(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_device_get_firmware_version(self.as_ref().to_glib_none().0))
        }
    }

    /// Gets the current a hardware address (MAC) for the @self.
    ///
    /// # Returns
    ///
    /// the current MAC of the device, or [`None`].
    /// This is the internal string used by the device, and must not be modified.
    #[doc(alias = "nm_device_get_hw_address")]
    #[doc(alias = "get_hw_address")]
    #[doc(alias = "hw-address")]
    fn hw_address(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_device_get_hw_address(self.as_ref().to_glib_none().0))
        }
    }

    /// Gets the interface name of the #NMDevice.
    ///
    /// # Returns
    ///
    /// the interface of the device. This is the internal string used by the
    /// device, and must not be modified.
    #[doc(alias = "nm_device_get_iface")]
    #[doc(alias = "get_iface")]
    fn iface(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_device_get_iface(self.as_ref().to_glib_none().0))
        }
    }

    /// Gets the interface flags of the device.
    ///
    /// # Returns
    ///
    /// the flags
    #[cfg(feature = "v1_22")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
    #[doc(alias = "nm_device_get_interface_flags")]
    #[doc(alias = "get_interface_flags")]
    #[doc(alias = "interface-flags")]
    fn interface_flags(&self) -> DeviceInterfaceFlags {
        unsafe {
            from_glib(ffi::nm_device_get_interface_flags(self.as_ref().to_glib_none().0))
        }
    }

    /// Gets the current IPv4 #NMIPConfig associated with the #NMDevice.
    ///
    /// You can alternatively use nm_active_connection_get_ip4_config(), which also
    /// works with VPN connections.
    ///
    /// # Returns
    ///
    /// the IPv4 #NMIPConfig, or [`None`] if the device is not
    /// activated.
    #[doc(alias = "nm_device_get_ip4_config")]
    #[doc(alias = "get_ip4_config")]
    #[doc(alias = "ip4-config")]
    fn ip4_config(&self) -> IPConfig {
        unsafe {
            from_glib_none(ffi::nm_device_get_ip4_config(self.as_ref().to_glib_none().0))
        }
    }

    /// Gets the current IPv6 #NMIPConfig associated with the #NMDevice.
    ///
    /// You can alternatively use nm_active_connection_get_ip6_config(), which also
    /// works with VPN connections.
    ///
    /// # Returns
    ///
    /// the IPv6 #NMIPConfig or [`None`] if the device is not activated.
    #[doc(alias = "nm_device_get_ip6_config")]
    #[doc(alias = "get_ip6_config")]
    #[doc(alias = "ip6-config")]
    fn ip6_config(&self) -> IPConfig {
        unsafe {
            from_glib_none(ffi::nm_device_get_ip6_config(self.as_ref().to_glib_none().0))
        }
    }

    /// Gets the IP interface name of the #NMDevice over which IP traffic flows
    /// when the device is in the ACTIVATED state.
    ///
    /// # Returns
    ///
    /// the IP traffic interface of the device. This is the internal string
    /// used by the device, and must not be modified.
    #[doc(alias = "nm_device_get_ip_iface")]
    #[doc(alias = "get_ip_iface")]
    fn ip_iface(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_device_get_ip_iface(self.as_ref().to_glib_none().0))
        }
    }

    /// Gets the list of neighbors discovered through LLDP.
    ///
    /// # Returns
    ///
    /// the #GPtrArray
    /// containing #NMLldpNeighbor<!-- -->s. This is the internal copy used by the
    /// device and must not be modified. The library never modifies the returned
    /// array and thus it is safe for callers to reference and keep using it.
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    #[doc(alias = "nm_device_get_lldp_neighbors")]
    #[doc(alias = "get_lldp_neighbors")]
    #[doc(alias = "lldp-neighbors")]
    fn lldp_neighbors(&self) -> Vec<LldpNeighbor> {
        unsafe {
            FromGlibPtrContainer::from_glib_none(ffi::nm_device_get_lldp_neighbors(self.as_ref().to_glib_none().0))
        }
    }

    /// Whether the #NMDevice is managed by NetworkManager.
    ///
    /// # Returns
    ///
    /// [`true`] if the device is managed by NetworkManager
    #[doc(alias = "nm_device_get_managed")]
    #[doc(alias = "get_managed")]
    #[doc(alias = "managed")]
    fn is_managed(&self) -> bool {
        unsafe {
            from_glib(ffi::nm_device_get_managed(self.as_ref().to_glib_none().0))
        }
    }

    /// Gets the metered setting of a #NMDevice.
    ///
    /// # Returns
    ///
    /// the metered setting.
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    #[doc(alias = "nm_device_get_metered")]
    #[doc(alias = "get_metered")]
    fn metered(&self) -> Metered {
        unsafe {
            from_glib(ffi::nm_device_get_metered(self.as_ref().to_glib_none().0))
        }
    }

    /// Gets the  MTU of the #NMDevice.
    ///
    /// # Returns
    ///
    /// the MTU of the device in bytes.
    #[doc(alias = "nm_device_get_mtu")]
    #[doc(alias = "get_mtu")]
    fn mtu(&self) -> u32 {
        unsafe {
            ffi::nm_device_get_mtu(self.as_ref().to_glib_none().0)
        }
    }

    /// Indicates that the NetworkManager plugin for the device is not installed.
    ///
    /// # Returns
    ///
    /// [`true`] if the device plugin not installed.
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    #[doc(alias = "nm_device_get_nm_plugin_missing")]
    #[doc(alias = "get_nm_plugin_missing")]
    #[doc(alias = "nm-plugin-missing")]
    fn is_nm_plugin_missing(&self) -> bool {
        unsafe {
            from_glib(ffi::nm_device_get_nm_plugin_missing(self.as_ref().to_glib_none().0))
        }
    }

    /// Gets the path of the #NMDevice as exposed by the udev property ID_PATH.
    ///
    /// # Returns
    ///
    /// the path of the device.
    ///
    /// The string is backslash escaped (C escaping) for invalid characters. The escaping
    /// can be reverted with g_strcompress(), however the result may not be valid UTF-8.
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    #[doc(alias = "nm_device_get_path")]
    #[doc(alias = "get_path")]
    fn path(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_device_get_path(self.as_ref().to_glib_none().0))
        }
    }

    /// Gets the physical port ID of the #NMDevice. If non-[`None`], this is
    /// an opaque string that can be used to recognize when
    /// seemingly-unrelated #NMDevices are actually just different virtual
    /// ports on a single physical port. (Eg, NPAR / SR-IOV.)
    ///
    /// # Returns
    ///
    /// the physical port ID of the device, or [`None`] if the port
    ///   ID is unknown. This is the internal string used by the device and
    ///   must not be modified.
    #[doc(alias = "nm_device_get_physical_port_id")]
    #[doc(alias = "get_physical_port_id")]
    #[doc(alias = "physical-port-id")]
    fn physical_port_id(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_device_get_physical_port_id(self.as_ref().to_glib_none().0))
        }
    }

    /// Gets the devices currently set as port of @self.
    ///
    /// # Returns
    ///
    /// the #GPtrArray containing #NMDevices that
    /// are ports of @self. This is the internal copy used by the device and
    /// must not be modified.
    #[cfg(feature = "v1_34")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_34")))]
    #[doc(alias = "nm_device_get_ports")]
    #[doc(alias = "get_ports")]
    fn ports(&self) -> Vec<Device> {
        unsafe {
            FromGlibPtrContainer::from_glib_none(ffi::nm_device_get_ports(self.as_ref().to_glib_none().0))
        }
    }

    /// Gets the product string of the #NMDevice.
    ///
    /// # Returns
    ///
    /// the product name of the device. This is the internal string used by the
    /// device, and must not be modified.
    ///
    /// The string is backslash escaped (C escaping) for invalid characters. The escaping
    /// can be reverted with g_strcompress(), however the result may not be valid UTF-8.
    #[doc(alias = "nm_device_get_product")]
    #[doc(alias = "get_product")]
    fn product(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_device_get_product(self.as_ref().to_glib_none().0))
        }
    }

    /// Gets the (primary) #NMSetting subtype associated with connections
    /// that can be used on @self.
    ///
    /// # Returns
    ///
    /// @self's associated #NMSetting type
    #[doc(alias = "nm_device_get_setting_type")]
    #[doc(alias = "get_setting_type")]
    fn setting_type(&self) -> glib::types::Type {
        unsafe {
            from_glib(ffi::nm_device_get_setting_type(self.as_ref().to_glib_none().0))
        }
    }

    /// Gets the current #NMDevice state.
    ///
    /// # Returns
    ///
    /// the current device state
    #[doc(alias = "nm_device_get_state")]
    #[doc(alias = "get_state")]
    fn state(&self) -> DeviceState {
        unsafe {
            from_glib(ffi::nm_device_get_state(self.as_ref().to_glib_none().0))
        }
    }

    /// Gets the reason for entering the current #NMDevice state.
    ///
    /// # Returns
    ///
    /// the reason for entering the current device state
    #[doc(alias = "nm_device_get_state_reason")]
    #[doc(alias = "get_state_reason")]
    #[doc(alias = "state-reason")]
    fn state_reason(&self) -> DeviceStateReason {
        unsafe {
            from_glib(ffi::nm_device_get_state_reason(self.as_ref().to_glib_none().0))
        }
    }

    /// Gets a (non-localized) description of the type of device that
    /// @self is.
    ///
    /// # Returns
    ///
    /// the type description of the device. This is the internal
    /// string used by the device, and must not be modified.
    #[doc(alias = "nm_device_get_type_description")]
    #[doc(alias = "get_type_description")]
    fn type_description(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_device_get_type_description(self.as_ref().to_glib_none().0))
        }
    }

    /// Gets the Unique Device Identifier of the #NMDevice.
    ///
    /// # Returns
    ///
    /// the Unique Device Identifier of the device.  This identifier may be
    /// used to gather more information about the device from various operating
    /// system services like udev or sysfs.
    #[doc(alias = "nm_device_get_udi")]
    #[doc(alias = "get_udi")]
    fn udi(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_device_get_udi(self.as_ref().to_glib_none().0))
        }
    }

    /// Gets the vendor string of the #NMDevice.
    ///
    /// # Returns
    ///
    /// the vendor name of the device. This is the internal string used by the
    /// device, and must not be modified.
    ///
    /// The string is backslash escaped (C escaping) for invalid characters. The escaping
    /// can be reverted with g_strcompress(), however the result may not be valid UTF-8.
    #[doc(alias = "nm_device_get_vendor")]
    #[doc(alias = "get_vendor")]
    fn vendor(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_device_get_vendor(self.as_ref().to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// [`true`] if the device exists, or [`false`] if it is a placeholder device
    /// that could be automatically created by NetworkManager if one of its
    /// #NMDevice:available-connections was activated.
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    #[doc(alias = "nm_device_is_real")]
    #[doc(alias = "real")]
    fn is_real(&self) -> bool {
        unsafe {
            from_glib(ffi::nm_device_is_real(self.as_ref().to_glib_none().0))
        }
    }

    /// Whether the device is a software device.
    ///
    /// # Returns
    ///
    /// [`true`] if @self is a software device, [`false`] if it is a hardware device.
    #[doc(alias = "nm_device_is_software")]
    fn is_software(&self) -> bool {
        unsafe {
            from_glib(ffi::nm_device_is_software(self.as_ref().to_glib_none().0))
        }
    }

    /// Attempts to update device with changes to the currently active connection
    /// made since it was last applied.
    ///
    /// # Deprecated since 1.22
    ///
    /// Use nm_device_reapply_async() or GDBusConnection.
    /// ## `connection`
    /// the #NMConnection to replace the applied
    ///   settings with or [`None`] to reuse existing
    /// ## `version_id`
    /// zero or the expected version id of the applied connection.
    ///   If specified and the version id mismatches, the call fails without
    ///   modification. This allows one to catch concurrent accesses.
    /// ## `flags`
    /// always set this to zero
    /// ## `cancellable`
    /// a #GCancellable, or [`None`]
    ///
    /// # Returns
    ///
    /// [`true`] on success, [`false`] on error, in which case @error will be set.
    #[cfg_attr(feature = "v1_22", deprecated = "Since 1.22")]
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    #[allow(deprecated)]
    #[doc(alias = "nm_device_reapply")]
    fn reapply(&self, connection: Option<&impl IsA<Connection>>, version_id: u64, flags: u32, cancellable: Option<&impl IsA<gio::Cancellable>>) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::nm_device_reapply(self.as_ref().to_glib_none().0, connection.map(|p| p.as_ref()).to_glib_none().0, version_id, flags, cancellable.map(|p| p.as_ref()).to_glib_none().0, &mut error);
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
        }
    }

    /// Asynchronously begins an attempt to update device with changes to the
    /// currently active connection made since it was last applied.
    /// ## `connection`
    /// the #NMConnection to replace the applied
    ///   settings with or [`None`] to reuse existing
    /// ## `version_id`
    /// zero or the expected version id of the applied
    ///   connection. If specified and the version id mismatches, the call
    ///   fails without modification. This allows one to catch concurrent
    ///   accesses.
    /// ## `flags`
    /// always set this to zero
    /// ## `cancellable`
    /// a #GCancellable, or [`None`]
    /// ## `callback`
    /// callback to be called when the reapply operation completes
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    #[doc(alias = "nm_device_reapply_async")]
    fn reapply_async<P: FnOnce(Result<(), glib::Error>) + 'static>(&self, connection: Option<&impl IsA<Connection>>, version_id: u64, flags: u32, cancellable: Option<&impl IsA<gio::Cancellable>>, callback: P) {
        
                let main_context = glib::MainContext::ref_thread_default();
                let is_main_context_owner = main_context.is_owner();
                let has_acquired_main_context = (!is_main_context_owner)
                    .then(|| main_context.acquire().ok())
                    .flatten();
                assert!(
                    is_main_context_owner || has_acquired_main_context.is_some(),
                    "Async operations only allowed if the thread is owning the MainContext"
                );
        
        let user_data: Box_<glib::thread_guard::ThreadGuard<P>> = Box_::new(glib::thread_guard::ThreadGuard::new(callback));
        unsafe extern "C" fn reapply_async_trampoline<P: FnOnce(Result<(), glib::Error>) + 'static>(_source_object: *mut glib::gobject_ffi::GObject, res: *mut gio::ffi::GAsyncResult, user_data: glib::ffi::gpointer) {
            let mut error = std::ptr::null_mut();
            ffi::nm_device_reapply_finish(_source_object as *mut _, res, &mut error);
            let result = if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) };
            let callback: Box_<glib::thread_guard::ThreadGuard<P>> = Box_::from_raw(user_data as *mut _);
            let callback: P = callback.into_inner();
            callback(result);
        }
        let callback = reapply_async_trampoline::<P>;
        unsafe {
            ffi::nm_device_reapply_async(self.as_ref().to_glib_none().0, connection.map(|p| p.as_ref()).to_glib_none().0, version_id, flags, cancellable.map(|p| p.as_ref()).to_glib_none().0, Some(callback), Box_::into_raw(user_data) as *mut _);
        }
    }

    
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    fn reapply_future(&self, connection: Option<&(impl IsA<Connection> + Clone + 'static)>, version_id: u64, flags: u32) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>> {

        let connection = connection.map(ToOwned::to_owned);
        Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
            obj.reapply_async(
                connection.as_ref().map(::std::borrow::Borrow::borrow),
                version_id,
                flags,
                Some(cancellable),
                move |res| {
                    send.resolve(res);
                },
            );
        }))
    }

    /// Enables or disables automatic activation of the #NMDevice.
    ///
    /// # Deprecated since 1.22
    ///
    /// Use the async command nm_client_dbus_set_property() on
    /// nm_object_get_path(), `NM_DBUS_INTERFACE_DEVICE` to set "Autoconnect" property to a "(b)" value.
    /// This function is deprecated because it calls a synchronous D-Bus method
    /// and modifies the content of the NMClient cache client side.
    /// ## `autoconnect`
    /// [`true`] to enable autoconnecting
    #[cfg_attr(feature = "v1_22", deprecated = "Since 1.22")]
    #[allow(deprecated)]
    #[doc(alias = "nm_device_set_autoconnect")]
    #[doc(alias = "autoconnect")]
    fn set_autoconnect(&self, autoconnect: bool) {
        unsafe {
            ffi::nm_device_set_autoconnect(self.as_ref().to_glib_none().0, autoconnect.into_glib());
        }
    }

    /// Enables or disables management of  #NMDevice by NetworkManager.
    ///
    /// # Deprecated since 1.22
    ///
    /// Use the async command nm_client_dbus_set_property() on
    /// nm_object_get_path(), interface `NM_DBUS_INTERFACE_DEVICE` to set the
    /// "Managed" property to a "(b)" boolean value.
    /// This function is deprecated because it calls a synchronous D-Bus method
    /// and modifies the content of the NMClient cache client side. Also, it does
    /// not emit a property changed signal.
    /// ## `managed`
    /// [`true`] to make the device managed by NetworkManager.
    #[cfg_attr(feature = "v1_22", deprecated = "Since 1.22")]
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    #[allow(deprecated)]
    #[doc(alias = "nm_device_set_managed")]
    fn set_managed(&self, managed: bool) {
        unsafe {
            ffi::nm_device_set_managed(self.as_ref().to_glib_none().0, managed.into_glib());
        }
    }

    /// The interface of the device.
    fn interface(&self) -> Option<glib::GString> {
        ObjectExt::property(self.as_ref(), "interface")
    }

    /// The IP interface of the device which should be used for all IP-related
    /// operations like addressing and routing.
    #[doc(alias = "ip-interface")]
    fn ip_interface(&self) -> Option<glib::GString> {
        ObjectExt::property(self.as_ref(), "ip-interface")
    }

    /// The IPv4 connectivity state of the device.
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    #[doc(alias = "ip4-connectivity")]
    fn ip4_connectivity(&self) -> ConnectivityState {
        ObjectExt::property(self.as_ref(), "ip4-connectivity")
    }

    /// The IPv6 connectivity state of the device.
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    #[doc(alias = "ip6-connectivity")]
    fn ip6_connectivity(&self) -> ConnectivityState {
        ObjectExt::property(self.as_ref(), "ip6-connectivity")
    }

    //#[cfg(not(feature = "v1_2"))]
    //#[cfg_attr(docsrs, doc(cfg(not(feature = "v1_2"))))]
    //#[doc(alias = "lldp-neighbors")]
    //fn lldp_neighbors(&self) -> /*Unimplemented*/Vec<Basic: Pointer> {
    //    ObjectExt::property(self.as_ref(), "lldp-neighbors")
    //}

    /// Notifies the state change of a #NMDevice.
    /// ## `new_state`
    /// the new state of the device
    /// ## `old_state`
    /// the previous state of the device
    /// ## `reason`
    /// the reason describing the state change
    #[doc(alias = "state-changed")]
    fn connect_state_changed<F: Fn(&Self, u32, u32, u32) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn state_changed_trampoline<P: IsA<Device>, F: Fn(&P, u32, u32, u32) + 'static>(this: *mut ffi::NMDevice, new_state: std::ffi::c_uint, old_state: std::ffi::c_uint, reason: std::ffi::c_uint, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref(), new_state, old_state, reason)
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"state-changed".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(state_changed_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "active-connection")]
    fn connect_active_connection_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_active_connection_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::active-connection".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_active_connection_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "autoconnect")]
    fn connect_autoconnect_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_autoconnect_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::autoconnect".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_autoconnect_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "available-connections")]
    fn connect_available_connections_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_available_connections_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::available-connections".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_available_connections_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "capabilities")]
    fn connect_capabilities_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_capabilities_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::capabilities".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_capabilities_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "device-type")]
    fn connect_device_type_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_device_type_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::device-type".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_device_type_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "dhcp4-config")]
    fn connect_dhcp4_config_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_dhcp4_config_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::dhcp4-config".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_dhcp4_config_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "dhcp6-config")]
    fn connect_dhcp6_config_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_dhcp6_config_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::dhcp6-config".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_dhcp6_config_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "driver")]
    fn connect_driver_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_driver_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::driver".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_driver_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "driver-version")]
    fn connect_driver_version_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_driver_version_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::driver-version".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_driver_version_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "firmware-missing")]
    fn connect_firmware_missing_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_firmware_missing_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::firmware-missing".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_firmware_missing_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "firmware-version")]
    fn connect_firmware_version_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_firmware_version_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::firmware-version".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_firmware_version_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    #[doc(alias = "hw-address")]
    fn connect_hw_address_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_hw_address_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::hw-address".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_hw_address_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "interface")]
    fn connect_interface_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_interface_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::interface".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_interface_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v1_22")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
    #[doc(alias = "interface-flags")]
    fn connect_interface_flags_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_interface_flags_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::interface-flags".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_interface_flags_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "ip-interface")]
    fn connect_ip_interface_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_ip_interface_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::ip-interface".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_ip_interface_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "ip4-config")]
    fn connect_ip4_config_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_ip4_config_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::ip4-config".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_ip4_config_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    #[doc(alias = "ip4-connectivity")]
    fn connect_ip4_connectivity_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_ip4_connectivity_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::ip4-connectivity".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_ip4_connectivity_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "ip6-config")]
    fn connect_ip6_config_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_ip6_config_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::ip6-config".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_ip6_config_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    #[doc(alias = "ip6-connectivity")]
    fn connect_ip6_connectivity_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_ip6_connectivity_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::ip6-connectivity".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_ip6_connectivity_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "lldp-neighbors")]
    fn connect_lldp_neighbors_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_lldp_neighbors_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::lldp-neighbors".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_lldp_neighbors_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "managed")]
    fn connect_managed_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_managed_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::managed".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_managed_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    #[doc(alias = "metered")]
    fn connect_metered_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_metered_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::metered".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_metered_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "mtu")]
    fn connect_mtu_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_mtu_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::mtu".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_mtu_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    #[doc(alias = "nm-plugin-missing")]
    fn connect_nm_plugin_missing_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_nm_plugin_missing_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::nm-plugin-missing".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_nm_plugin_missing_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "physical-port-id")]
    fn connect_physical_port_id_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_physical_port_id_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::physical-port-id".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_physical_port_id_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v1_34")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_34")))]
    #[doc(alias = "ports")]
    fn connect_ports_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_ports_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::ports".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_ports_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "product")]
    fn connect_product_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_product_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::product".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_product_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    #[doc(alias = "real")]
    fn connect_real_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_real_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::real".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_real_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "state")]
    fn connect_state_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_state_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::state".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_state_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "state-reason")]
    fn connect_state_reason_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_state_reason_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::state-reason".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_state_reason_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "udi")]
    fn connect_udi_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_udi_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::udi".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_udi_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "vendor")]
    fn connect_vendor_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_vendor_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::vendor".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_vendor_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }
}

impl<O: IsA<Device>> DeviceExt for O {}
