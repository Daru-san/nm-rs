// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir
// from gtk-girs (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT
#![allow(deprecated)]

use crate::{ffi,ActiveConnection,Connection,DeviceCapabilities,DeviceState,DeviceStateReason,DeviceType,DhcpConfig,IPConfig,Object,RemoteConnection};
#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
use crate::{LldpNeighbor,Metered};
#[cfg(feature = "v1_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
use crate::{ConnectivityState};
#[cfg(feature = "v1_22")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
use crate::{DeviceInterfaceFlags};
use glib::{object::ObjectType as _,prelude::*,signal::{connect_raw, SignalHandlerId},translate::*};
use std::{boxed::Box as Box_};

glib::wrapper! {
    #[doc(alias = "NMDevice")]
    pub struct Device(Object<ffi::NMDevice, ffi::NMDeviceClass>) @extends Object;

    match fn {
        type_ => || ffi::nm_device_get_type(),
    }
}

impl Device {
        pub const NONE: Option<&'static Device> = None;
    

    #[doc(alias = "nm_device_disambiguate_names")]
    pub fn disambiguate_names(devices: &[Device]) -> Vec<glib::GString> {
        assert_initialized_main_thread!();
        let num_devices = devices.len() as _;
        unsafe {
            FromGlibPtrContainer::from_glib_full(ffi::nm_device_disambiguate_names(devices.to_glib_none().0, num_devices))
        }
    }
}

pub trait DeviceExt: IsA<Device> + 'static {
    //#[doc(alias = "nm_device_connection_compatible")]
    //fn connection_compatible(&self, connection: &impl IsA<Connection>, error: /*Ignored*/Option<glib::Error>) -> bool {
    //    unsafe { TODO: call ffi:nm_device_connection_compatible() }
    //}

    #[doc(alias = "nm_device_connection_valid")]
    fn connection_valid(&self, connection: &impl IsA<Connection>) -> bool {
        unsafe {
            from_glib(ffi::nm_device_connection_valid(self.as_ref().to_glib_none().0, connection.as_ref().to_glib_none().0))
        }
    }

    //#[cfg_attr(feature = "v1_22", deprecated = "Since 1.22")]
    //#[allow(deprecated)]
    //#[doc(alias = "nm_device_delete")]
    //fn delete(&self, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<glib::Error>) -> bool {
    //    unsafe { TODO: call ffi:nm_device_delete() }
    //}

    //#[doc(alias = "nm_device_delete_async")]
    //fn delete_async<P: FnOnce(Result<(), /*Ignored*/glib::Error>) + 'static>(&self, cancellable: /*Ignored*/Option<&gio::Cancellable>, callback: P) {
    //    unsafe { TODO: call ffi:nm_device_delete_async() }
    //}

    //
    //fn delete_future(&self) -> Pin<Box_<dyn std::future::Future<Output = Result<(), /*Ignored*/glib::Error>> + 'static>> {

        //Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
        //    obj.delete_async(
        //        Some(cancellable),
        //        move |res| {
        //            send.resolve(res);
        //        },
        //    );
        //}))
    //}

    //#[cfg_attr(feature = "v1_22", deprecated = "Since 1.22")]
    //#[allow(deprecated)]
    //#[doc(alias = "nm_device_disconnect")]
    //fn disconnect(&self, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<glib::Error>) -> bool {
    //    unsafe { TODO: call ffi:nm_device_disconnect() }
    //}

    //#[doc(alias = "nm_device_disconnect_async")]
    //fn disconnect_async<P: FnOnce(Result<(), /*Ignored*/glib::Error>) + 'static>(&self, cancellable: /*Ignored*/Option<&gio::Cancellable>, callback: P) {
    //    unsafe { TODO: call ffi:nm_device_disconnect_async() }
    //}

    //
    //fn disconnect_future(&self) -> Pin<Box_<dyn std::future::Future<Output = Result<(), /*Ignored*/glib::Error>> + 'static>> {

        //Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
        //    obj.disconnect_async(
        //        Some(cancellable),
        //        move |res| {
        //            send.resolve(res);
        //        },
        //    );
        //}))
    //}

    #[doc(alias = "nm_device_filter_connections")]
    fn filter_connections(&self, connections: &[Connection]) -> Vec<Connection> {
        unsafe {
            FromGlibPtrContainer::from_glib_full(ffi::nm_device_filter_connections(self.as_ref().to_glib_none().0, connections.to_glib_none().0))
        }
    }

    #[doc(alias = "nm_device_get_active_connection")]
    #[doc(alias = "get_active_connection")]
    #[doc(alias = "active-connection")]
    fn active_connection(&self) -> ActiveConnection {
        unsafe {
            from_glib_none(ffi::nm_device_get_active_connection(self.as_ref().to_glib_none().0))
        }
    }

    //#[cfg_attr(feature = "v1_22", deprecated = "Since 1.22")]
    //#[cfg(feature = "v1_2")]
    //#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    //#[allow(deprecated)]
    //#[doc(alias = "nm_device_get_applied_connection")]
    //#[doc(alias = "get_applied_connection")]
    //fn applied_connection(&self, flags: u32, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<glib::Error>) -> Result<Connection, u64, glib::Error> {
    //    unsafe { TODO: call ffi:nm_device_get_applied_connection() }
    //}

    //#[cfg(feature = "v1_2")]
    //#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    //#[doc(alias = "nm_device_get_applied_connection_async")]
    //#[doc(alias = "get_applied_connection_async")]
    //fn applied_connection_async<P: FnOnce(Result<(Connection, u64), /*Ignored*/glib::Error>) + 'static>(&self, flags: u32, cancellable: /*Ignored*/Option<&gio::Cancellable>, callback: P) {
    //    unsafe { TODO: call ffi:nm_device_get_applied_connection_async() }
    //}

    //
    //#[cfg(feature = "v1_2")]
    //#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    //fn applied_connection_future(&self, flags: u32) -> Pin<Box_<dyn std::future::Future<Output = Result<(Connection, u64), /*Ignored*/glib::Error>> + 'static>> {

        //Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
        //    obj.applied_connection_async(
        //        flags,
        //        Some(cancellable),
        //        move |res| {
        //            send.resolve(res);
        //        },
        //    );
        //}))
    //}

    #[doc(alias = "nm_device_get_autoconnect")]
    #[doc(alias = "get_autoconnect")]
    #[doc(alias = "autoconnect")]
    fn is_autoconnect(&self) -> bool {
        unsafe {
            from_glib(ffi::nm_device_get_autoconnect(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "nm_device_get_available_connections")]
    #[doc(alias = "get_available_connections")]
    #[doc(alias = "available-connections")]
    fn available_connections(&self) -> Vec<RemoteConnection> {
        unsafe {
            FromGlibPtrContainer::from_glib_none(ffi::nm_device_get_available_connections(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "nm_device_get_capabilities")]
    #[doc(alias = "get_capabilities")]
    fn capabilities(&self) -> DeviceCapabilities {
        unsafe {
            from_glib(ffi::nm_device_get_capabilities(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    #[doc(alias = "nm_device_get_connectivity")]
    #[doc(alias = "get_connectivity")]
    fn connectivity(&self, addr_family: i32) -> ConnectivityState {
        unsafe {
            from_glib(ffi::nm_device_get_connectivity(self.as_ref().to_glib_none().0, addr_family))
        }
    }

    #[doc(alias = "nm_device_get_description")]
    #[doc(alias = "get_description")]
    fn description(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_device_get_description(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "nm_device_get_device_type")]
    #[doc(alias = "get_device_type")]
    #[doc(alias = "device-type")]
    fn device_type(&self) -> DeviceType {
        unsafe {
            from_glib(ffi::nm_device_get_device_type(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "nm_device_get_dhcp4_config")]
    #[doc(alias = "get_dhcp4_config")]
    #[doc(alias = "dhcp4-config")]
    fn dhcp4_config(&self) -> DhcpConfig {
        unsafe {
            from_glib_none(ffi::nm_device_get_dhcp4_config(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "nm_device_get_dhcp6_config")]
    #[doc(alias = "get_dhcp6_config")]
    #[doc(alias = "dhcp6-config")]
    fn dhcp6_config(&self) -> DhcpConfig {
        unsafe {
            from_glib_none(ffi::nm_device_get_dhcp6_config(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "nm_device_get_driver")]
    #[doc(alias = "get_driver")]
    fn driver(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_device_get_driver(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "nm_device_get_driver_version")]
    #[doc(alias = "get_driver_version")]
    #[doc(alias = "driver-version")]
    fn driver_version(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_device_get_driver_version(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "nm_device_get_firmware_missing")]
    #[doc(alias = "get_firmware_missing")]
    #[doc(alias = "firmware-missing")]
    fn is_firmware_missing(&self) -> bool {
        unsafe {
            from_glib(ffi::nm_device_get_firmware_missing(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "nm_device_get_firmware_version")]
    #[doc(alias = "get_firmware_version")]
    #[doc(alias = "firmware-version")]
    fn firmware_version(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_device_get_firmware_version(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "nm_device_get_hw_address")]
    #[doc(alias = "get_hw_address")]
    #[doc(alias = "hw-address")]
    fn hw_address(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_device_get_hw_address(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "nm_device_get_iface")]
    #[doc(alias = "get_iface")]
    fn iface(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_device_get_iface(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(feature = "v1_22")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
    #[doc(alias = "nm_device_get_interface_flags")]
    #[doc(alias = "get_interface_flags")]
    #[doc(alias = "interface-flags")]
    fn interface_flags(&self) -> DeviceInterfaceFlags {
        unsafe {
            from_glib(ffi::nm_device_get_interface_flags(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "nm_device_get_ip4_config")]
    #[doc(alias = "get_ip4_config")]
    #[doc(alias = "ip4-config")]
    fn ip4_config(&self) -> IPConfig {
        unsafe {
            from_glib_none(ffi::nm_device_get_ip4_config(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "nm_device_get_ip6_config")]
    #[doc(alias = "get_ip6_config")]
    #[doc(alias = "ip6-config")]
    fn ip6_config(&self) -> IPConfig {
        unsafe {
            from_glib_none(ffi::nm_device_get_ip6_config(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "nm_device_get_ip_iface")]
    #[doc(alias = "get_ip_iface")]
    fn ip_iface(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_device_get_ip_iface(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    #[doc(alias = "nm_device_get_lldp_neighbors")]
    #[doc(alias = "get_lldp_neighbors")]
    #[doc(alias = "lldp-neighbors")]
    fn lldp_neighbors(&self) -> Vec<LldpNeighbor> {
        unsafe {
            FromGlibPtrContainer::from_glib_none(ffi::nm_device_get_lldp_neighbors(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "nm_device_get_managed")]
    #[doc(alias = "get_managed")]
    #[doc(alias = "managed")]
    fn is_managed(&self) -> bool {
        unsafe {
            from_glib(ffi::nm_device_get_managed(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    #[doc(alias = "nm_device_get_metered")]
    #[doc(alias = "get_metered")]
    fn metered(&self) -> Metered {
        unsafe {
            from_glib(ffi::nm_device_get_metered(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "nm_device_get_mtu")]
    #[doc(alias = "get_mtu")]
    fn mtu(&self) -> u32 {
        unsafe {
            ffi::nm_device_get_mtu(self.as_ref().to_glib_none().0)
        }
    }

    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    #[doc(alias = "nm_device_get_nm_plugin_missing")]
    #[doc(alias = "get_nm_plugin_missing")]
    #[doc(alias = "nm-plugin-missing")]
    fn is_nm_plugin_missing(&self) -> bool {
        unsafe {
            from_glib(ffi::nm_device_get_nm_plugin_missing(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    #[doc(alias = "nm_device_get_path")]
    #[doc(alias = "get_path")]
    fn path(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_device_get_path(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "nm_device_get_physical_port_id")]
    #[doc(alias = "get_physical_port_id")]
    #[doc(alias = "physical-port-id")]
    fn physical_port_id(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_device_get_physical_port_id(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(feature = "v1_34")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_34")))]
    #[doc(alias = "nm_device_get_ports")]
    #[doc(alias = "get_ports")]
    fn ports(&self) -> Vec<Device> {
        unsafe {
            FromGlibPtrContainer::from_glib_none(ffi::nm_device_get_ports(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "nm_device_get_product")]
    #[doc(alias = "get_product")]
    fn product(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_device_get_product(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "nm_device_get_setting_type")]
    #[doc(alias = "get_setting_type")]
    fn setting_type(&self) -> glib::types::Type {
        unsafe {
            from_glib(ffi::nm_device_get_setting_type(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "nm_device_get_state")]
    #[doc(alias = "get_state")]
    fn state(&self) -> DeviceState {
        unsafe {
            from_glib(ffi::nm_device_get_state(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "nm_device_get_state_reason")]
    #[doc(alias = "get_state_reason")]
    #[doc(alias = "state-reason")]
    fn state_reason(&self) -> DeviceStateReason {
        unsafe {
            from_glib(ffi::nm_device_get_state_reason(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "nm_device_get_type_description")]
    #[doc(alias = "get_type_description")]
    fn type_description(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_device_get_type_description(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "nm_device_get_udi")]
    #[doc(alias = "get_udi")]
    fn udi(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_device_get_udi(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "nm_device_get_vendor")]
    #[doc(alias = "get_vendor")]
    fn vendor(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_device_get_vendor(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    #[doc(alias = "nm_device_is_real")]
    #[doc(alias = "real")]
    fn is_real(&self) -> bool {
        unsafe {
            from_glib(ffi::nm_device_is_real(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "nm_device_is_software")]
    fn is_software(&self) -> bool {
        unsafe {
            from_glib(ffi::nm_device_is_software(self.as_ref().to_glib_none().0))
        }
    }

    //#[cfg_attr(feature = "v1_22", deprecated = "Since 1.22")]
    //#[cfg(feature = "v1_2")]
    //#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    //#[allow(deprecated)]
    //#[doc(alias = "nm_device_reapply")]
    //fn reapply(&self, connection: Option<&impl IsA<Connection>>, version_id: u64, flags: u32, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<glib::Error>) -> bool {
    //    unsafe { TODO: call ffi:nm_device_reapply() }
    //}

    //#[cfg(feature = "v1_2")]
    //#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    //#[doc(alias = "nm_device_reapply_async")]
    //fn reapply_async<P: FnOnce(Result<(), /*Ignored*/glib::Error>) + 'static>(&self, connection: Option<&impl IsA<Connection>>, version_id: u64, flags: u32, cancellable: /*Ignored*/Option<&gio::Cancellable>, callback: P) {
    //    unsafe { TODO: call ffi:nm_device_reapply_async() }
    //}

    //
    //#[cfg(feature = "v1_2")]
    //#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    //fn reapply_future(&self, connection: Option<&(impl IsA<Connection> + Clone + 'static)>, version_id: u64, flags: u32) -> Pin<Box_<dyn std::future::Future<Output = Result<(), /*Ignored*/glib::Error>> + 'static>> {

        //let connection = connection.map(ToOwned::to_owned);
        //Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
        //    obj.reapply_async(
        //        connection.as_ref().map(::std::borrow::Borrow::borrow),
        //        version_id,
        //        flags,
        //        Some(cancellable),
        //        move |res| {
        //            send.resolve(res);
        //        },
        //    );
        //}))
    //}

    #[cfg_attr(feature = "v1_22", deprecated = "Since 1.22")]
    #[allow(deprecated)]
    #[doc(alias = "nm_device_set_autoconnect")]
    #[doc(alias = "autoconnect")]
    fn set_autoconnect(&self, autoconnect: bool) {
        unsafe {
            ffi::nm_device_set_autoconnect(self.as_ref().to_glib_none().0, autoconnect.into_glib());
        }
    }

    #[cfg_attr(feature = "v1_22", deprecated = "Since 1.22")]
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    #[allow(deprecated)]
    #[doc(alias = "nm_device_set_managed")]
    fn set_managed(&self, managed: bool) {
        unsafe {
            ffi::nm_device_set_managed(self.as_ref().to_glib_none().0, managed.into_glib());
        }
    }

    fn interface(&self) -> Option<glib::GString> {
        ObjectExt::property(self.as_ref(), "interface")
    }

    #[doc(alias = "ip-interface")]
    fn ip_interface(&self) -> Option<glib::GString> {
        ObjectExt::property(self.as_ref(), "ip-interface")
    }

    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    #[doc(alias = "ip4-connectivity")]
    fn ip4_connectivity(&self) -> ConnectivityState {
        ObjectExt::property(self.as_ref(), "ip4-connectivity")
    }

    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    #[doc(alias = "ip6-connectivity")]
    fn ip6_connectivity(&self) -> ConnectivityState {
        ObjectExt::property(self.as_ref(), "ip6-connectivity")
    }

    //#[cfg(not(feature = "v1_2"))]
    //#[cfg_attr(docsrs, doc(cfg(not(feature = "v1_2"))))]
    //#[doc(alias = "lldp-neighbors")]
    //fn lldp_neighbors(&self) -> /*Unimplemented*/Vec<Basic: Pointer> {
    //    ObjectExt::property(self.as_ref(), "lldp-neighbors")
    //}

    #[doc(alias = "state-changed")]
    fn connect_state_changed<F: Fn(&Self, u32, u32, u32) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn state_changed_trampoline<P: IsA<Device>, F: Fn(&P, u32, u32, u32) + 'static>(this: *mut ffi::NMDevice, new_state: std::ffi::c_uint, old_state: std::ffi::c_uint, reason: std::ffi::c_uint, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref(), new_state, old_state, reason)
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"state-changed".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(state_changed_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "active-connection")]
    fn connect_active_connection_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_active_connection_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::active-connection".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_active_connection_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "autoconnect")]
    fn connect_autoconnect_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_autoconnect_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::autoconnect".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_autoconnect_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "available-connections")]
    fn connect_available_connections_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_available_connections_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::available-connections".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_available_connections_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "capabilities")]
    fn connect_capabilities_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_capabilities_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::capabilities".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_capabilities_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "device-type")]
    fn connect_device_type_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_device_type_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::device-type".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_device_type_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "dhcp4-config")]
    fn connect_dhcp4_config_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_dhcp4_config_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::dhcp4-config".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_dhcp4_config_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "dhcp6-config")]
    fn connect_dhcp6_config_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_dhcp6_config_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::dhcp6-config".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_dhcp6_config_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "driver")]
    fn connect_driver_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_driver_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::driver".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_driver_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "driver-version")]
    fn connect_driver_version_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_driver_version_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::driver-version".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_driver_version_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "firmware-missing")]
    fn connect_firmware_missing_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_firmware_missing_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::firmware-missing".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_firmware_missing_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "firmware-version")]
    fn connect_firmware_version_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_firmware_version_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::firmware-version".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_firmware_version_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    #[doc(alias = "hw-address")]
    fn connect_hw_address_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_hw_address_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::hw-address".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_hw_address_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "interface")]
    fn connect_interface_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_interface_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::interface".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_interface_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v1_22")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
    #[doc(alias = "interface-flags")]
    fn connect_interface_flags_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_interface_flags_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::interface-flags".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_interface_flags_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "ip-interface")]
    fn connect_ip_interface_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_ip_interface_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::ip-interface".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_ip_interface_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "ip4-config")]
    fn connect_ip4_config_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_ip4_config_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::ip4-config".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_ip4_config_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    #[doc(alias = "ip4-connectivity")]
    fn connect_ip4_connectivity_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_ip4_connectivity_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::ip4-connectivity".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_ip4_connectivity_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "ip6-config")]
    fn connect_ip6_config_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_ip6_config_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::ip6-config".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_ip6_config_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    #[doc(alias = "ip6-connectivity")]
    fn connect_ip6_connectivity_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_ip6_connectivity_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::ip6-connectivity".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_ip6_connectivity_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "lldp-neighbors")]
    fn connect_lldp_neighbors_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_lldp_neighbors_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::lldp-neighbors".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_lldp_neighbors_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "managed")]
    fn connect_managed_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_managed_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::managed".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_managed_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    #[doc(alias = "metered")]
    fn connect_metered_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_metered_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::metered".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_metered_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "mtu")]
    fn connect_mtu_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_mtu_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::mtu".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_mtu_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    #[doc(alias = "nm-plugin-missing")]
    fn connect_nm_plugin_missing_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_nm_plugin_missing_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::nm-plugin-missing".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_nm_plugin_missing_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "physical-port-id")]
    fn connect_physical_port_id_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_physical_port_id_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::physical-port-id".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_physical_port_id_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v1_34")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_34")))]
    #[doc(alias = "ports")]
    fn connect_ports_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_ports_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::ports".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_ports_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "product")]
    fn connect_product_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_product_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::product".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_product_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    #[doc(alias = "real")]
    fn connect_real_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_real_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::real".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_real_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "state")]
    fn connect_state_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_state_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::state".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_state_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "state-reason")]
    fn connect_state_reason_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_state_reason_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::state-reason".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_state_reason_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "udi")]
    fn connect_udi_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_udi_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::udi".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_udi_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "vendor")]
    fn connect_vendor_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_vendor_trampoline<P: IsA<Device>, F: Fn(&P) + 'static>(this: *mut ffi::NMDevice, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Device::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::vendor".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_vendor_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }
}

impl<O: IsA<Device>> DeviceExt for O {}
