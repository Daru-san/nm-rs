// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir
// from gtk-girs (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use crate::{ffi};
use glib::{bitflags::bitflags,prelude::*,translate::*};

bitflags! {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "NM80211ApFlags")]
    pub struct 80211ApFlags: u32 {
        #[doc(alias = "NM_802_11_AP_FLAGS_NONE")]
        const NONE = ffi::NM_802_11_AP_FLAGS_NONE as _;
        #[doc(alias = "NM_802_11_AP_FLAGS_PRIVACY")]
        const PRIVACY = ffi::NM_802_11_AP_FLAGS_PRIVACY as _;
        #[doc(alias = "NM_802_11_AP_FLAGS_WPS")]
        const WPS = ffi::NM_802_11_AP_FLAGS_WPS as _;
        #[doc(alias = "NM_802_11_AP_FLAGS_WPS_PBC")]
        const WPS_PBC = ffi::NM_802_11_AP_FLAGS_WPS_PBC as _;
        #[doc(alias = "NM_802_11_AP_FLAGS_WPS_PIN")]
        const WPS_PIN = ffi::NM_802_11_AP_FLAGS_WPS_PIN as _;
    }
}

#[doc(hidden)]
impl IntoGlib for 80211ApFlags {
    type GlibType = ffi::NM80211ApFlags;

    #[inline]
    fn into_glib(self) -> ffi::NM80211ApFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NM80211ApFlags> for 80211ApFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::NM80211ApFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for 80211ApFlags {
                #[inline]
    #[doc(alias = "nm_802_11_ap_flags_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::nm_802_11_ap_flags_get_type()) }
                }
            }

impl glib::HasParamSpec for 80211ApFlags {
                type ParamSpec = glib::ParamSpecFlags;
                type SetValue = Self;
                type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder
                }
}

impl glib::value::ValueType for 80211ApFlags {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for 80211ApFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for 80211ApFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<80211ApFlags> for glib::Value {
    #[inline]
    fn from(v: 80211ApFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "NM80211ApSecurityFlags")]
    pub struct 80211ApSecurityFlags: u32 {
        #[doc(alias = "NM_802_11_AP_SEC_NONE")]
        const NONE = ffi::NM_802_11_AP_SEC_NONE as _;
        #[doc(alias = "NM_802_11_AP_SEC_PAIR_WEP40")]
        const PAIR_WEP40 = ffi::NM_802_11_AP_SEC_PAIR_WEP40 as _;
        #[doc(alias = "NM_802_11_AP_SEC_PAIR_WEP104")]
        const PAIR_WEP104 = ffi::NM_802_11_AP_SEC_PAIR_WEP104 as _;
        #[doc(alias = "NM_802_11_AP_SEC_PAIR_TKIP")]
        const PAIR_TKIP = ffi::NM_802_11_AP_SEC_PAIR_TKIP as _;
        #[doc(alias = "NM_802_11_AP_SEC_PAIR_CCMP")]
        const PAIR_CCMP = ffi::NM_802_11_AP_SEC_PAIR_CCMP as _;
        #[doc(alias = "NM_802_11_AP_SEC_GROUP_WEP40")]
        const GROUP_WEP40 = ffi::NM_802_11_AP_SEC_GROUP_WEP40 as _;
        #[doc(alias = "NM_802_11_AP_SEC_GROUP_WEP104")]
        const GROUP_WEP104 = ffi::NM_802_11_AP_SEC_GROUP_WEP104 as _;
        #[doc(alias = "NM_802_11_AP_SEC_GROUP_TKIP")]
        const GROUP_TKIP = ffi::NM_802_11_AP_SEC_GROUP_TKIP as _;
        #[doc(alias = "NM_802_11_AP_SEC_GROUP_CCMP")]
        const GROUP_CCMP = ffi::NM_802_11_AP_SEC_GROUP_CCMP as _;
        #[doc(alias = "NM_802_11_AP_SEC_KEY_MGMT_PSK")]
        const KEY_MGMT_PSK = ffi::NM_802_11_AP_SEC_KEY_MGMT_PSK as _;
        #[doc(alias = "NM_802_11_AP_SEC_KEY_MGMT_802_1X")]
        const KEY_MGMT_802_1X = ffi::NM_802_11_AP_SEC_KEY_MGMT_802_1X as _;
        #[doc(alias = "NM_802_11_AP_SEC_KEY_MGMT_SAE")]
        const KEY_MGMT_SAE = ffi::NM_802_11_AP_SEC_KEY_MGMT_SAE as _;
        #[doc(alias = "NM_802_11_AP_SEC_KEY_MGMT_OWE")]
        const KEY_MGMT_OWE = ffi::NM_802_11_AP_SEC_KEY_MGMT_OWE as _;
        #[doc(alias = "NM_802_11_AP_SEC_KEY_MGMT_OWE_TM")]
        const KEY_MGMT_OWE_TM = ffi::NM_802_11_AP_SEC_KEY_MGMT_OWE_TM as _;
        #[doc(alias = "NM_802_11_AP_SEC_KEY_MGMT_EAP_SUITE_B_192")]
        const KEY_MGMT_EAP_SUITE_B_192 = ffi::NM_802_11_AP_SEC_KEY_MGMT_EAP_SUITE_B_192 as _;
    }
}

#[doc(hidden)]
impl IntoGlib for 80211ApSecurityFlags {
    type GlibType = ffi::NM80211ApSecurityFlags;

    #[inline]
    fn into_glib(self) -> ffi::NM80211ApSecurityFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NM80211ApSecurityFlags> for 80211ApSecurityFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::NM80211ApSecurityFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for 80211ApSecurityFlags {
                #[inline]
    #[doc(alias = "nm_802_11_ap_security_flags_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::nm_802_11_ap_security_flags_get_type()) }
                }
            }

impl glib::HasParamSpec for 80211ApSecurityFlags {
                type ParamSpec = glib::ParamSpecFlags;
                type SetValue = Self;
                type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder
                }
}

impl glib::value::ValueType for 80211ApSecurityFlags {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for 80211ApSecurityFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for 80211ApSecurityFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<80211ApSecurityFlags> for glib::Value {
    #[inline]
    fn from(v: 80211ApSecurityFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v1_10")]
bitflags! {
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "NMActivationStateFlags")]
    pub struct ActivationStateFlags: u32 {
        #[doc(alias = "NM_ACTIVATION_STATE_FLAG_NONE")]
        const NONE = ffi::NM_ACTIVATION_STATE_FLAG_NONE as _;
        #[doc(alias = "NM_ACTIVATION_STATE_FLAG_IS_CONTROLLER")]
        const IS_CONTROLLER = ffi::NM_ACTIVATION_STATE_FLAG_IS_CONTROLLER as _;
        #[doc(alias = "NM_ACTIVATION_STATE_FLAG_IS_PORT")]
        const IS_PORT = ffi::NM_ACTIVATION_STATE_FLAG_IS_PORT as _;
        #[doc(alias = "NM_ACTIVATION_STATE_FLAG_LAYER2_READY")]
        const LAYER2_READY = ffi::NM_ACTIVATION_STATE_FLAG_LAYER2_READY as _;
        #[doc(alias = "NM_ACTIVATION_STATE_FLAG_IP4_READY")]
        const IP4_READY = ffi::NM_ACTIVATION_STATE_FLAG_IP4_READY as _;
        #[doc(alias = "NM_ACTIVATION_STATE_FLAG_IP6_READY")]
        const IP6_READY = ffi::NM_ACTIVATION_STATE_FLAG_IP6_READY as _;
        #[doc(alias = "NM_ACTIVATION_STATE_FLAG_CONTROLLER_HAS_PORTS")]
        const CONTROLLER_HAS_PORTS = ffi::NM_ACTIVATION_STATE_FLAG_CONTROLLER_HAS_PORTS as _;
        #[doc(alias = "NM_ACTIVATION_STATE_FLAG_LIFETIME_BOUND_TO_PROFILE_VISIBILITY")]
        const LIFETIME_BOUND_TO_PROFILE_VISIBILITY = ffi::NM_ACTIVATION_STATE_FLAG_LIFETIME_BOUND_TO_PROFILE_VISIBILITY as _;
        #[doc(alias = "NM_ACTIVATION_STATE_FLAG_EXTERNAL")]
        const EXTERNAL = ffi::NM_ACTIVATION_STATE_FLAG_EXTERNAL as _;
    }
}

#[cfg(feature = "v1_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
#[doc(hidden)]
impl IntoGlib for ActivationStateFlags {
    type GlibType = ffi::NMActivationStateFlags;

    #[inline]
    fn into_glib(self) -> ffi::NMActivationStateFlags {
        self.bits()
    }
}

#[cfg(feature = "v1_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
#[doc(hidden)]
impl FromGlib<ffi::NMActivationStateFlags> for ActivationStateFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::NMActivationStateFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

#[cfg(feature = "v1_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
impl StaticType for ActivationStateFlags {
                #[inline]
    #[doc(alias = "nm_activation_state_flags_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::nm_activation_state_flags_get_type()) }
                }
            }

#[cfg(feature = "v1_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
impl glib::HasParamSpec for ActivationStateFlags {
                type ParamSpec = glib::ParamSpecFlags;
                type SetValue = Self;
                type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder
                }
}

#[cfg(feature = "v1_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
impl glib::value::ValueType for ActivationStateFlags {
    type Type = Self;
}

#[cfg(feature = "v1_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
unsafe impl<'a> glib::value::FromValue<'a> for ActivationStateFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
impl ToValue for ActivationStateFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
impl From<ActivationStateFlags> for glib::Value {
    #[inline]
    fn from(v: ActivationStateFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "NMBluetoothCapabilities")]
    pub struct BluetoothCapabilities: u32 {
        #[doc(alias = "NM_BT_CAPABILITY_NONE")]
        const NONE = ffi::NM_BT_CAPABILITY_NONE as _;
        #[doc(alias = "NM_BT_CAPABILITY_DUN")]
        const DUN = ffi::NM_BT_CAPABILITY_DUN as _;
        #[doc(alias = "NM_BT_CAPABILITY_NAP")]
        const NAP = ffi::NM_BT_CAPABILITY_NAP as _;
    }
}

#[doc(hidden)]
impl IntoGlib for BluetoothCapabilities {
    type GlibType = ffi::NMBluetoothCapabilities;

    #[inline]
    fn into_glib(self) -> ffi::NMBluetoothCapabilities {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMBluetoothCapabilities> for BluetoothCapabilities {
    #[inline]
    unsafe fn from_glib(value: ffi::NMBluetoothCapabilities) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for BluetoothCapabilities {
                #[inline]
    #[doc(alias = "nm_bluetooth_capabilities_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::nm_bluetooth_capabilities_get_type()) }
                }
            }

impl glib::HasParamSpec for BluetoothCapabilities {
                type ParamSpec = glib::ParamSpecFlags;
                type SetValue = Self;
                type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder
                }
}

impl glib::value::ValueType for BluetoothCapabilities {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for BluetoothCapabilities {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for BluetoothCapabilities {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<BluetoothCapabilities> for glib::Value {
    #[inline]
    fn from(v: BluetoothCapabilities) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v1_12")]
bitflags! {
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "NMCheckpointCreateFlags")]
    pub struct CheckpointCreateFlags: u32 {
        #[doc(alias = "NM_CHECKPOINT_CREATE_FLAG_NONE")]
        const NONE = ffi::NM_CHECKPOINT_CREATE_FLAG_NONE as _;
        #[doc(alias = "NM_CHECKPOINT_CREATE_FLAG_DESTROY_ALL")]
        const DESTROY_ALL = ffi::NM_CHECKPOINT_CREATE_FLAG_DESTROY_ALL as _;
        #[doc(alias = "NM_CHECKPOINT_CREATE_FLAG_DELETE_NEW_CONNECTIONS")]
        const DELETE_NEW_CONNECTIONS = ffi::NM_CHECKPOINT_CREATE_FLAG_DELETE_NEW_CONNECTIONS as _;
        #[doc(alias = "NM_CHECKPOINT_CREATE_FLAG_DISCONNECT_NEW_DEVICES")]
        const DISCONNECT_NEW_DEVICES = ffi::NM_CHECKPOINT_CREATE_FLAG_DISCONNECT_NEW_DEVICES as _;
        #[doc(alias = "NM_CHECKPOINT_CREATE_FLAG_ALLOW_OVERLAPPING")]
        const ALLOW_OVERLAPPING = ffi::NM_CHECKPOINT_CREATE_FLAG_ALLOW_OVERLAPPING as _;
        #[doc(alias = "NM_CHECKPOINT_CREATE_FLAG_NO_PRESERVE_EXTERNAL_PORTS")]
        const NO_PRESERVE_EXTERNAL_PORTS = ffi::NM_CHECKPOINT_CREATE_FLAG_NO_PRESERVE_EXTERNAL_PORTS as _;
        #[doc(alias = "NM_CHECKPOINT_CREATE_FLAG_TRACK_INTERNAL_GLOBAL_DNS")]
        const TRACK_INTERNAL_GLOBAL_DNS = ffi::NM_CHECKPOINT_CREATE_FLAG_TRACK_INTERNAL_GLOBAL_DNS as _;
    }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
#[doc(hidden)]
impl IntoGlib for CheckpointCreateFlags {
    type GlibType = ffi::NMCheckpointCreateFlags;

    #[inline]
    fn into_glib(self) -> ffi::NMCheckpointCreateFlags {
        self.bits()
    }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
#[doc(hidden)]
impl FromGlib<ffi::NMCheckpointCreateFlags> for CheckpointCreateFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::NMCheckpointCreateFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
impl StaticType for CheckpointCreateFlags {
                #[inline]
    #[doc(alias = "nm_checkpoint_create_flags_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::nm_checkpoint_create_flags_get_type()) }
                }
            }

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
impl glib::HasParamSpec for CheckpointCreateFlags {
                type ParamSpec = glib::ParamSpecFlags;
                type SetValue = Self;
                type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder
                }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
impl glib::value::ValueType for CheckpointCreateFlags {
    type Type = Self;
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
unsafe impl<'a> glib::value::FromValue<'a> for CheckpointCreateFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
impl ToValue for CheckpointCreateFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
impl From<CheckpointCreateFlags> for glib::Value {
    #[inline]
    fn from(v: CheckpointCreateFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v1_24")]
bitflags! {
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "NMClientInstanceFlags")]
    pub struct ClientInstanceFlags: u32 {
        #[doc(alias = "NM_CLIENT_INSTANCE_FLAGS_NONE")]
        const NONE = ffi::NM_CLIENT_INSTANCE_FLAGS_NONE as _;
        #[doc(alias = "NM_CLIENT_INSTANCE_FLAGS_NO_AUTO_FETCH_PERMISSIONS")]
        const NO_AUTO_FETCH_PERMISSIONS = ffi::NM_CLIENT_INSTANCE_FLAGS_NO_AUTO_FETCH_PERMISSIONS as _;
        #[doc(alias = "NM_CLIENT_INSTANCE_FLAGS_INITIALIZED_GOOD")]
        const INITIALIZED_GOOD = ffi::NM_CLIENT_INSTANCE_FLAGS_INITIALIZED_GOOD as _;
        #[doc(alias = "NM_CLIENT_INSTANCE_FLAGS_INITIALIZED_BAD")]
        const INITIALIZED_BAD = ffi::NM_CLIENT_INSTANCE_FLAGS_INITIALIZED_BAD as _;
    }
}

#[cfg(feature = "v1_24")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
#[doc(hidden)]
impl IntoGlib for ClientInstanceFlags {
    type GlibType = ffi::NMClientInstanceFlags;

    #[inline]
    fn into_glib(self) -> ffi::NMClientInstanceFlags {
        self.bits()
    }
}

#[cfg(feature = "v1_24")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
#[doc(hidden)]
impl FromGlib<ffi::NMClientInstanceFlags> for ClientInstanceFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::NMClientInstanceFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

#[cfg(feature = "v1_24")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
impl StaticType for ClientInstanceFlags {
                #[inline]
    #[doc(alias = "nm_client_instance_flags_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::nm_client_instance_flags_get_type()) }
                }
            }

#[cfg(feature = "v1_24")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
impl glib::HasParamSpec for ClientInstanceFlags {
                type ParamSpec = glib::ParamSpecFlags;
                type SetValue = Self;
                type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder
                }
}

#[cfg(feature = "v1_24")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
impl glib::value::ValueType for ClientInstanceFlags {
    type Type = Self;
}

#[cfg(feature = "v1_24")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
unsafe impl<'a> glib::value::FromValue<'a> for ClientInstanceFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_24")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
impl ToValue for ClientInstanceFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_24")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
impl From<ClientInstanceFlags> for glib::Value {
    #[inline]
    fn from(v: ClientInstanceFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "NMConnectionSerializationFlags")]
    pub struct ConnectionSerializationFlags: u32 {
        #[doc(alias = "NM_CONNECTION_SERIALIZE_ALL")]
        const ALL = ffi::NM_CONNECTION_SERIALIZE_ALL as _;
        #[doc(alias = "NM_CONNECTION_SERIALIZE_WITH_NON_SECRET")]
        const WITH_NON_SECRET = ffi::NM_CONNECTION_SERIALIZE_WITH_NON_SECRET as _;
        #[doc(alias = "NM_CONNECTION_SERIALIZE_NO_SECRETS")]
        const NO_SECRETS = ffi::NM_CONNECTION_SERIALIZE_NO_SECRETS as _;
        #[doc(alias = "NM_CONNECTION_SERIALIZE_WITH_SECRETS")]
        const WITH_SECRETS = ffi::NM_CONNECTION_SERIALIZE_WITH_SECRETS as _;
        #[doc(alias = "NM_CONNECTION_SERIALIZE_ONLY_SECRETS")]
        const ONLY_SECRETS = ffi::NM_CONNECTION_SERIALIZE_ONLY_SECRETS as _;
        #[doc(alias = "NM_CONNECTION_SERIALIZE_WITH_SECRETS_AGENT_OWNED")]
        const WITH_SECRETS_AGENT_OWNED = ffi::NM_CONNECTION_SERIALIZE_WITH_SECRETS_AGENT_OWNED as _;
        #[doc(alias = "NM_CONNECTION_SERIALIZE_WITH_SECRETS_SYSTEM_OWNED")]
        const WITH_SECRETS_SYSTEM_OWNED = ffi::NM_CONNECTION_SERIALIZE_WITH_SECRETS_SYSTEM_OWNED as _;
        #[doc(alias = "NM_CONNECTION_SERIALIZE_WITH_SECRETS_NOT_SAVED")]
        const WITH_SECRETS_NOT_SAVED = ffi::NM_CONNECTION_SERIALIZE_WITH_SECRETS_NOT_SAVED as _;
    }
}

#[doc(hidden)]
impl IntoGlib for ConnectionSerializationFlags {
    type GlibType = ffi::NMConnectionSerializationFlags;

    #[inline]
    fn into_glib(self) -> ffi::NMConnectionSerializationFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMConnectionSerializationFlags> for ConnectionSerializationFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::NMConnectionSerializationFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for ConnectionSerializationFlags {
                #[inline]
    #[doc(alias = "nm_connection_serialization_flags_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::nm_connection_serialization_flags_get_type()) }
                }
            }

impl glib::HasParamSpec for ConnectionSerializationFlags {
                type ParamSpec = glib::ParamSpecFlags;
                type SetValue = Self;
                type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder
                }
}

impl glib::value::ValueType for ConnectionSerializationFlags {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for ConnectionSerializationFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for ConnectionSerializationFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<ConnectionSerializationFlags> for glib::Value {
    #[inline]
    fn from(v: ConnectionSerializationFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "NMDeviceCapabilities")]
    pub struct DeviceCapabilities: u32 {
        #[doc(alias = "NM_DEVICE_CAP_NONE")]
        const NONE = ffi::NM_DEVICE_CAP_NONE as _;
        #[doc(alias = "NM_DEVICE_CAP_NM_SUPPORTED")]
        const NM_SUPPORTED = ffi::NM_DEVICE_CAP_NM_SUPPORTED as _;
        #[doc(alias = "NM_DEVICE_CAP_CARRIER_DETECT")]
        const CARRIER_DETECT = ffi::NM_DEVICE_CAP_CARRIER_DETECT as _;
        #[doc(alias = "NM_DEVICE_CAP_IS_SOFTWARE")]
        const IS_SOFTWARE = ffi::NM_DEVICE_CAP_IS_SOFTWARE as _;
        #[doc(alias = "NM_DEVICE_CAP_SRIOV")]
        const SRIOV = ffi::NM_DEVICE_CAP_SRIOV as _;
    }
}

#[doc(hidden)]
impl IntoGlib for DeviceCapabilities {
    type GlibType = ffi::NMDeviceCapabilities;

    #[inline]
    fn into_glib(self) -> ffi::NMDeviceCapabilities {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMDeviceCapabilities> for DeviceCapabilities {
    #[inline]
    unsafe fn from_glib(value: ffi::NMDeviceCapabilities) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for DeviceCapabilities {
                #[inline]
    #[doc(alias = "nm_device_capabilities_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::nm_device_capabilities_get_type()) }
                }
            }

impl glib::HasParamSpec for DeviceCapabilities {
                type ParamSpec = glib::ParamSpecFlags;
                type SetValue = Self;
                type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder
                }
}

impl glib::value::ValueType for DeviceCapabilities {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for DeviceCapabilities {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for DeviceCapabilities {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<DeviceCapabilities> for glib::Value {
    #[inline]
    fn from(v: DeviceCapabilities) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v1_22")]
bitflags! {
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "NMDeviceInterfaceFlags")]
    pub struct DeviceInterfaceFlags: u32 {
        #[doc(alias = "NM_DEVICE_INTERFACE_FLAG_UP")]
        const UP = ffi::NM_DEVICE_INTERFACE_FLAG_UP as _;
        #[doc(alias = "NM_DEVICE_INTERFACE_FLAG_LOWER_UP")]
        const LOWER_UP = ffi::NM_DEVICE_INTERFACE_FLAG_LOWER_UP as _;
        #[doc(alias = "NM_DEVICE_INTERFACE_FLAG_PROMISC")]
        const PROMISC = ffi::NM_DEVICE_INTERFACE_FLAG_PROMISC as _;
        #[doc(alias = "NM_DEVICE_INTERFACE_FLAG_CARRIER")]
        const CARRIER = ffi::NM_DEVICE_INTERFACE_FLAG_CARRIER as _;
        #[doc(alias = "NM_DEVICE_INTERFACE_FLAG_LLDP_CLIENT_ENABLED")]
        const LLDP_CLIENT_ENABLED = ffi::NM_DEVICE_INTERFACE_FLAG_LLDP_CLIENT_ENABLED as _;
    }
}

#[cfg(feature = "v1_22")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
#[doc(hidden)]
impl IntoGlib for DeviceInterfaceFlags {
    type GlibType = ffi::NMDeviceInterfaceFlags;

    #[inline]
    fn into_glib(self) -> ffi::NMDeviceInterfaceFlags {
        self.bits()
    }
}

#[cfg(feature = "v1_22")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
#[doc(hidden)]
impl FromGlib<ffi::NMDeviceInterfaceFlags> for DeviceInterfaceFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::NMDeviceInterfaceFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

#[cfg(feature = "v1_22")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
impl StaticType for DeviceInterfaceFlags {
                #[inline]
    #[doc(alias = "nm_device_interface_flags_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::nm_device_interface_flags_get_type()) }
                }
            }

#[cfg(feature = "v1_22")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
impl glib::HasParamSpec for DeviceInterfaceFlags {
                type ParamSpec = glib::ParamSpecFlags;
                type SetValue = Self;
                type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder
                }
}

#[cfg(feature = "v1_22")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
impl glib::value::ValueType for DeviceInterfaceFlags {
    type Type = Self;
}

#[cfg(feature = "v1_22")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
unsafe impl<'a> glib::value::FromValue<'a> for DeviceInterfaceFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_22")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
impl ToValue for DeviceInterfaceFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_22")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
impl From<DeviceInterfaceFlags> for glib::Value {
    #[inline]
    fn from(v: DeviceInterfaceFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "NMDeviceModemCapabilities")]
    pub struct DeviceModemCapabilities: u32 {
        #[doc(alias = "NM_DEVICE_MODEM_CAPABILITY_NONE")]
        const NONE = ffi::NM_DEVICE_MODEM_CAPABILITY_NONE as _;
        #[doc(alias = "NM_DEVICE_MODEM_CAPABILITY_POTS")]
        const POTS = ffi::NM_DEVICE_MODEM_CAPABILITY_POTS as _;
        #[doc(alias = "NM_DEVICE_MODEM_CAPABILITY_CDMA_EVDO")]
        const CDMA_EVDO = ffi::NM_DEVICE_MODEM_CAPABILITY_CDMA_EVDO as _;
        #[doc(alias = "NM_DEVICE_MODEM_CAPABILITY_GSM_UMTS")]
        const GSM_UMTS = ffi::NM_DEVICE_MODEM_CAPABILITY_GSM_UMTS as _;
        #[doc(alias = "NM_DEVICE_MODEM_CAPABILITY_LTE")]
        const LTE = ffi::NM_DEVICE_MODEM_CAPABILITY_LTE as _;
        #[doc(alias = "NM_DEVICE_MODEM_CAPABILITY_5GNR")]
        const _5GNR = ffi::NM_DEVICE_MODEM_CAPABILITY_5GNR as _;
    }
}

#[doc(hidden)]
impl IntoGlib for DeviceModemCapabilities {
    type GlibType = ffi::NMDeviceModemCapabilities;

    #[inline]
    fn into_glib(self) -> ffi::NMDeviceModemCapabilities {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMDeviceModemCapabilities> for DeviceModemCapabilities {
    #[inline]
    unsafe fn from_glib(value: ffi::NMDeviceModemCapabilities) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for DeviceModemCapabilities {
                #[inline]
    #[doc(alias = "nm_device_modem_capabilities_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::nm_device_modem_capabilities_get_type()) }
                }
            }

impl glib::HasParamSpec for DeviceModemCapabilities {
                type ParamSpec = glib::ParamSpecFlags;
                type SetValue = Self;
                type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder
                }
}

impl glib::value::ValueType for DeviceModemCapabilities {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for DeviceModemCapabilities {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for DeviceModemCapabilities {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<DeviceModemCapabilities> for glib::Value {
    #[inline]
    fn from(v: DeviceModemCapabilities) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v1_42")]
bitflags! {
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "NMDeviceReapplyFlags")]
    pub struct DeviceReapplyFlags: u32 {
        #[doc(alias = "NM_DEVICE_REAPPLY_FLAGS_NONE")]
        const NONE = ffi::NM_DEVICE_REAPPLY_FLAGS_NONE as _;
        #[doc(alias = "NM_DEVICE_REAPPLY_FLAGS_PRESERVE_EXTERNAL_IP")]
        const PRESERVE_EXTERNAL_IP = ffi::NM_DEVICE_REAPPLY_FLAGS_PRESERVE_EXTERNAL_IP as _;
    }
}

#[cfg(feature = "v1_42")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
#[doc(hidden)]
impl IntoGlib for DeviceReapplyFlags {
    type GlibType = ffi::NMDeviceReapplyFlags;

    #[inline]
    fn into_glib(self) -> ffi::NMDeviceReapplyFlags {
        self.bits()
    }
}

#[cfg(feature = "v1_42")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
#[doc(hidden)]
impl FromGlib<ffi::NMDeviceReapplyFlags> for DeviceReapplyFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::NMDeviceReapplyFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

#[cfg(feature = "v1_42")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
impl StaticType for DeviceReapplyFlags {
                #[inline]
    #[doc(alias = "nm_device_reapply_flags_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::nm_device_reapply_flags_get_type()) }
                }
            }

#[cfg(feature = "v1_42")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
impl glib::HasParamSpec for DeviceReapplyFlags {
                type ParamSpec = glib::ParamSpecFlags;
                type SetValue = Self;
                type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder
                }
}

#[cfg(feature = "v1_42")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
impl glib::value::ValueType for DeviceReapplyFlags {
    type Type = Self;
}

#[cfg(feature = "v1_42")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
unsafe impl<'a> glib::value::FromValue<'a> for DeviceReapplyFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_42")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
impl ToValue for DeviceReapplyFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_42")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
impl From<DeviceReapplyFlags> for glib::Value {
    #[inline]
    fn from(v: DeviceReapplyFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "NMDeviceWifiCapabilities")]
    pub struct DeviceWifiCapabilities: u32 {
        #[doc(alias = "NM_WIFI_DEVICE_CAP_NONE")]
        const NONE = ffi::NM_WIFI_DEVICE_CAP_NONE as _;
        #[doc(alias = "NM_WIFI_DEVICE_CAP_CIPHER_WEP40")]
        const CIPHER_WEP40 = ffi::NM_WIFI_DEVICE_CAP_CIPHER_WEP40 as _;
        #[doc(alias = "NM_WIFI_DEVICE_CAP_CIPHER_WEP104")]
        const CIPHER_WEP104 = ffi::NM_WIFI_DEVICE_CAP_CIPHER_WEP104 as _;
        #[doc(alias = "NM_WIFI_DEVICE_CAP_CIPHER_TKIP")]
        const CIPHER_TKIP = ffi::NM_WIFI_DEVICE_CAP_CIPHER_TKIP as _;
        #[doc(alias = "NM_WIFI_DEVICE_CAP_CIPHER_CCMP")]
        const CIPHER_CCMP = ffi::NM_WIFI_DEVICE_CAP_CIPHER_CCMP as _;
        #[doc(alias = "NM_WIFI_DEVICE_CAP_WPA")]
        const WPA = ffi::NM_WIFI_DEVICE_CAP_WPA as _;
        #[doc(alias = "NM_WIFI_DEVICE_CAP_RSN")]
        const RSN = ffi::NM_WIFI_DEVICE_CAP_RSN as _;
        #[doc(alias = "NM_WIFI_DEVICE_CAP_AP")]
        const AP = ffi::NM_WIFI_DEVICE_CAP_AP as _;
        #[doc(alias = "NM_WIFI_DEVICE_CAP_ADHOC")]
        const ADHOC = ffi::NM_WIFI_DEVICE_CAP_ADHOC as _;
        #[doc(alias = "NM_WIFI_DEVICE_CAP_FREQ_VALID")]
        const FREQ_VALID = ffi::NM_WIFI_DEVICE_CAP_FREQ_VALID as _;
        #[doc(alias = "NM_WIFI_DEVICE_CAP_FREQ_2GHZ")]
        const FREQ_2GHZ = ffi::NM_WIFI_DEVICE_CAP_FREQ_2GHZ as _;
        #[doc(alias = "NM_WIFI_DEVICE_CAP_FREQ_5GHZ")]
        const FREQ_5GHZ = ffi::NM_WIFI_DEVICE_CAP_FREQ_5GHZ as _;
        #[doc(alias = "NM_WIFI_DEVICE_CAP_FREQ_6GHZ")]
        const FREQ_6GHZ = ffi::NM_WIFI_DEVICE_CAP_FREQ_6GHZ as _;
        #[doc(alias = "NM_WIFI_DEVICE_CAP_MESH")]
        const MESH = ffi::NM_WIFI_DEVICE_CAP_MESH as _;
        #[doc(alias = "NM_WIFI_DEVICE_CAP_IBSS_RSN")]
        const IBSS_RSN = ffi::NM_WIFI_DEVICE_CAP_IBSS_RSN as _;
    }
}

#[doc(hidden)]
impl IntoGlib for DeviceWifiCapabilities {
    type GlibType = ffi::NMDeviceWifiCapabilities;

    #[inline]
    fn into_glib(self) -> ffi::NMDeviceWifiCapabilities {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMDeviceWifiCapabilities> for DeviceWifiCapabilities {
    #[inline]
    unsafe fn from_glib(value: ffi::NMDeviceWifiCapabilities) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for DeviceWifiCapabilities {
                #[inline]
    #[doc(alias = "nm_device_wifi_capabilities_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::nm_device_wifi_capabilities_get_type()) }
                }
            }

impl glib::HasParamSpec for DeviceWifiCapabilities {
                type ParamSpec = glib::ParamSpecFlags;
                type SetValue = Self;
                type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder
                }
}

impl glib::value::ValueType for DeviceWifiCapabilities {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for DeviceWifiCapabilities {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for DeviceWifiCapabilities {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<DeviceWifiCapabilities> for glib::Value {
    #[inline]
    fn from(v: DeviceWifiCapabilities) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v1_22")]
bitflags! {
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "NMDhcpHostnameFlags")]
    pub struct DhcpHostnameFlags: u32 {
        #[doc(alias = "NM_DHCP_HOSTNAME_FLAG_NONE")]
        const NONE = ffi::NM_DHCP_HOSTNAME_FLAG_NONE as _;
        #[doc(alias = "NM_DHCP_HOSTNAME_FLAG_FQDN_SERV_UPDATE")]
        const FQDN_SERV_UPDATE = ffi::NM_DHCP_HOSTNAME_FLAG_FQDN_SERV_UPDATE as _;
        #[doc(alias = "NM_DHCP_HOSTNAME_FLAG_FQDN_ENCODED")]
        const FQDN_ENCODED = ffi::NM_DHCP_HOSTNAME_FLAG_FQDN_ENCODED as _;
        #[doc(alias = "NM_DHCP_HOSTNAME_FLAG_FQDN_NO_UPDATE")]
        const FQDN_NO_UPDATE = ffi::NM_DHCP_HOSTNAME_FLAG_FQDN_NO_UPDATE as _;
        #[doc(alias = "NM_DHCP_HOSTNAME_FLAG_FQDN_CLEAR_FLAGS")]
        const FQDN_CLEAR_FLAGS = ffi::NM_DHCP_HOSTNAME_FLAG_FQDN_CLEAR_FLAGS as _;
    }
}

#[cfg(feature = "v1_22")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
#[doc(hidden)]
impl IntoGlib for DhcpHostnameFlags {
    type GlibType = ffi::NMDhcpHostnameFlags;

    #[inline]
    fn into_glib(self) -> ffi::NMDhcpHostnameFlags {
        self.bits()
    }
}

#[cfg(feature = "v1_22")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
#[doc(hidden)]
impl FromGlib<ffi::NMDhcpHostnameFlags> for DhcpHostnameFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::NMDhcpHostnameFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

#[cfg(feature = "v1_22")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
impl StaticType for DhcpHostnameFlags {
                #[inline]
    #[doc(alias = "nm_dhcp_hostname_flags_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::nm_dhcp_hostname_flags_get_type()) }
                }
            }

#[cfg(feature = "v1_22")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
impl glib::HasParamSpec for DhcpHostnameFlags {
                type ParamSpec = glib::ParamSpecFlags;
                type SetValue = Self;
                type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder
                }
}

#[cfg(feature = "v1_22")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
impl glib::value::ValueType for DhcpHostnameFlags {
    type Type = Self;
}

#[cfg(feature = "v1_22")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
unsafe impl<'a> glib::value::FromValue<'a> for DhcpHostnameFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_22")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
impl ToValue for DhcpHostnameFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_22")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
impl From<DhcpHostnameFlags> for glib::Value {
    #[inline]
    fn from(v: DhcpHostnameFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v1_22")]
bitflags! {
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "NMIPAddressCmpFlags")]
    pub struct IPAddressCmpFlags: u32 {
        #[doc(alias = "NM_IP_ADDRESS_CMP_FLAGS_NONE")]
        const NONE = ffi::NM_IP_ADDRESS_CMP_FLAGS_NONE as _;
        #[doc(alias = "NM_IP_ADDRESS_CMP_FLAGS_WITH_ATTRS")]
        const WITH_ATTRS = ffi::NM_IP_ADDRESS_CMP_FLAGS_WITH_ATTRS as _;
    }
}

#[cfg(feature = "v1_22")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
#[doc(hidden)]
impl IntoGlib for IPAddressCmpFlags {
    type GlibType = ffi::NMIPAddressCmpFlags;

    #[inline]
    fn into_glib(self) -> ffi::NMIPAddressCmpFlags {
        self.bits()
    }
}

#[cfg(feature = "v1_22")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
#[doc(hidden)]
impl FromGlib<ffi::NMIPAddressCmpFlags> for IPAddressCmpFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::NMIPAddressCmpFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

#[cfg(feature = "v1_22")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
impl StaticType for IPAddressCmpFlags {
                #[inline]
    #[doc(alias = "nm_ip_address_cmp_flags_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::nm_ip_address_cmp_flags_get_type()) }
                }
            }

#[cfg(feature = "v1_22")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
impl glib::HasParamSpec for IPAddressCmpFlags {
                type ParamSpec = glib::ParamSpecFlags;
                type SetValue = Self;
                type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder
                }
}

#[cfg(feature = "v1_22")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
impl glib::value::ValueType for IPAddressCmpFlags {
    type Type = Self;
}

#[cfg(feature = "v1_22")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
unsafe impl<'a> glib::value::FromValue<'a> for IPAddressCmpFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_22")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
impl ToValue for IPAddressCmpFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_22")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
impl From<IPAddressCmpFlags> for glib::Value {
    #[inline]
    fn from(v: IPAddressCmpFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v1_18")]
bitflags! {
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "NMIPRoutingRuleAsStringFlags")]
    pub struct IPRoutingRuleAsStringFlags: u32 {
        #[doc(alias = "NM_IP_ROUTING_RULE_AS_STRING_FLAGS_NONE")]
        const NONE = ffi::NM_IP_ROUTING_RULE_AS_STRING_FLAGS_NONE as _;
        #[doc(alias = "NM_IP_ROUTING_RULE_AS_STRING_FLAGS_AF_INET")]
        const AF_INET = ffi::NM_IP_ROUTING_RULE_AS_STRING_FLAGS_AF_INET as _;
        #[doc(alias = "NM_IP_ROUTING_RULE_AS_STRING_FLAGS_AF_INET6")]
        const AF_INET6 = ffi::NM_IP_ROUTING_RULE_AS_STRING_FLAGS_AF_INET6 as _;
        #[doc(alias = "NM_IP_ROUTING_RULE_AS_STRING_FLAGS_VALIDATE")]
        const VALIDATE = ffi::NM_IP_ROUTING_RULE_AS_STRING_FLAGS_VALIDATE as _;
    }
}

#[cfg(feature = "v1_18")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
#[doc(hidden)]
impl IntoGlib for IPRoutingRuleAsStringFlags {
    type GlibType = ffi::NMIPRoutingRuleAsStringFlags;

    #[inline]
    fn into_glib(self) -> ffi::NMIPRoutingRuleAsStringFlags {
        self.bits()
    }
}

#[cfg(feature = "v1_18")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
#[doc(hidden)]
impl FromGlib<ffi::NMIPRoutingRuleAsStringFlags> for IPRoutingRuleAsStringFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::NMIPRoutingRuleAsStringFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

#[cfg(feature = "v1_18")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
impl StaticType for IPRoutingRuleAsStringFlags {
                #[inline]
    #[doc(alias = "nm_ip_routing_rule_as_string_flags_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::nm_ip_routing_rule_as_string_flags_get_type()) }
                }
            }

#[cfg(feature = "v1_18")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
impl glib::HasParamSpec for IPRoutingRuleAsStringFlags {
                type ParamSpec = glib::ParamSpecFlags;
                type SetValue = Self;
                type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder
                }
}

#[cfg(feature = "v1_18")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
impl glib::value::ValueType for IPRoutingRuleAsStringFlags {
    type Type = Self;
}

#[cfg(feature = "v1_18")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
unsafe impl<'a> glib::value::FromValue<'a> for IPRoutingRuleAsStringFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_18")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
impl ToValue for IPRoutingRuleAsStringFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_18")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
impl From<IPRoutingRuleAsStringFlags> for glib::Value {
    #[inline]
    fn from(v: IPRoutingRuleAsStringFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v1_12")]
bitflags! {
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "NMIPTunnelFlags")]
    pub struct IPTunnelFlags: u32 {
        #[doc(alias = "NM_IP_TUNNEL_FLAG_NONE")]
        const NONE = ffi::NM_IP_TUNNEL_FLAG_NONE as _;
        #[doc(alias = "NM_IP_TUNNEL_FLAG_IP6_IGN_ENCAP_LIMIT")]
        const IP6_IGN_ENCAP_LIMIT = ffi::NM_IP_TUNNEL_FLAG_IP6_IGN_ENCAP_LIMIT as _;
        #[doc(alias = "NM_IP_TUNNEL_FLAG_IP6_USE_ORIG_TCLASS")]
        const IP6_USE_ORIG_TCLASS = ffi::NM_IP_TUNNEL_FLAG_IP6_USE_ORIG_TCLASS as _;
        #[doc(alias = "NM_IP_TUNNEL_FLAG_IP6_USE_ORIG_FLOWLABEL")]
        const IP6_USE_ORIG_FLOWLABEL = ffi::NM_IP_TUNNEL_FLAG_IP6_USE_ORIG_FLOWLABEL as _;
        #[doc(alias = "NM_IP_TUNNEL_FLAG_IP6_MIP6_DEV")]
        const IP6_MIP6_DEV = ffi::NM_IP_TUNNEL_FLAG_IP6_MIP6_DEV as _;
        #[doc(alias = "NM_IP_TUNNEL_FLAG_IP6_RCV_DSCP_COPY")]
        const IP6_RCV_DSCP_COPY = ffi::NM_IP_TUNNEL_FLAG_IP6_RCV_DSCP_COPY as _;
        #[doc(alias = "NM_IP_TUNNEL_FLAG_IP6_USE_ORIG_FWMARK")]
        const IP6_USE_ORIG_FWMARK = ffi::NM_IP_TUNNEL_FLAG_IP6_USE_ORIG_FWMARK as _;
    }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
#[doc(hidden)]
impl IntoGlib for IPTunnelFlags {
    type GlibType = ffi::NMIPTunnelFlags;

    #[inline]
    fn into_glib(self) -> ffi::NMIPTunnelFlags {
        self.bits()
    }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
#[doc(hidden)]
impl FromGlib<ffi::NMIPTunnelFlags> for IPTunnelFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::NMIPTunnelFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
impl StaticType for IPTunnelFlags {
                #[inline]
    #[doc(alias = "nm_ip_tunnel_flags_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::nm_ip_tunnel_flags_get_type()) }
                }
            }

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
impl glib::HasParamSpec for IPTunnelFlags {
                type ParamSpec = glib::ParamSpecFlags;
                type SetValue = Self;
                type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder
                }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
impl glib::value::ValueType for IPTunnelFlags {
    type Type = Self;
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
unsafe impl<'a> glib::value::FromValue<'a> for IPTunnelFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
impl ToValue for IPTunnelFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
impl From<IPTunnelFlags> for glib::Value {
    #[inline]
    fn from(v: IPTunnelFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v1_30")]
bitflags! {
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "NMKeyfileHandlerFlags")]
    pub struct KeyfileHandlerFlags: u32 {
        #[doc(alias = "NM_KEYFILE_HANDLER_FLAGS_NONE")]
        const NONE = ffi::NM_KEYFILE_HANDLER_FLAGS_NONE as _;
    }
}

#[cfg(feature = "v1_30")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
#[doc(hidden)]
impl IntoGlib for KeyfileHandlerFlags {
    type GlibType = ffi::NMKeyfileHandlerFlags;

    #[inline]
    fn into_glib(self) -> ffi::NMKeyfileHandlerFlags {
        self.bits()
    }
}

#[cfg(feature = "v1_30")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
#[doc(hidden)]
impl FromGlib<ffi::NMKeyfileHandlerFlags> for KeyfileHandlerFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::NMKeyfileHandlerFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

#[cfg(feature = "v1_30")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
impl StaticType for KeyfileHandlerFlags {
                #[inline]
    #[doc(alias = "nm_keyfile_handler_flags_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::nm_keyfile_handler_flags_get_type()) }
                }
            }

#[cfg(feature = "v1_30")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
impl glib::HasParamSpec for KeyfileHandlerFlags {
                type ParamSpec = glib::ParamSpecFlags;
                type SetValue = Self;
                type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder
                }
}

#[cfg(feature = "v1_30")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
impl glib::value::ValueType for KeyfileHandlerFlags {
    type Type = Self;
}

#[cfg(feature = "v1_30")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
unsafe impl<'a> glib::value::FromValue<'a> for KeyfileHandlerFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_30")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
impl ToValue for KeyfileHandlerFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_30")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
impl From<KeyfileHandlerFlags> for glib::Value {
    #[inline]
    fn from(v: KeyfileHandlerFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v1_22")]
bitflags! {
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "NMManagerReloadFlags")]
    pub struct ManagerReloadFlags: u32 {
        #[doc(alias = "NM_MANAGER_RELOAD_FLAG_CONF")]
        const CONF = ffi::NM_MANAGER_RELOAD_FLAG_CONF as _;
        #[doc(alias = "NM_MANAGER_RELOAD_FLAG_DNS_RC")]
        const DNS_RC = ffi::NM_MANAGER_RELOAD_FLAG_DNS_RC as _;
        #[doc(alias = "NM_MANAGER_RELOAD_FLAG_DNS_FULL")]
        const DNS_FULL = ffi::NM_MANAGER_RELOAD_FLAG_DNS_FULL as _;
    }
}

#[cfg(feature = "v1_22")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
#[doc(hidden)]
impl IntoGlib for ManagerReloadFlags {
    type GlibType = ffi::NMManagerReloadFlags;

    #[inline]
    fn into_glib(self) -> ffi::NMManagerReloadFlags {
        self.bits()
    }
}

#[cfg(feature = "v1_22")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
#[doc(hidden)]
impl FromGlib<ffi::NMManagerReloadFlags> for ManagerReloadFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::NMManagerReloadFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

#[cfg(feature = "v1_22")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
impl StaticType for ManagerReloadFlags {
                #[inline]
    #[doc(alias = "nm_manager_reload_flags_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::nm_manager_reload_flags_get_type()) }
                }
            }

#[cfg(feature = "v1_22")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
impl glib::HasParamSpec for ManagerReloadFlags {
                type ParamSpec = glib::ParamSpecFlags;
                type SetValue = Self;
                type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder
                }
}

#[cfg(feature = "v1_22")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
impl glib::value::ValueType for ManagerReloadFlags {
    type Type = Self;
}

#[cfg(feature = "v1_22")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
unsafe impl<'a> glib::value::FromValue<'a> for ManagerReloadFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_22")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
impl ToValue for ManagerReloadFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_22")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
impl From<ManagerReloadFlags> for glib::Value {
    #[inline]
    fn from(v: ManagerReloadFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v1_40")]
bitflags! {
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_40")))]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "NMMptcpFlags")]
    pub struct MptcpFlags: u32 {
        #[doc(alias = "NM_MPTCP_FLAGS_NONE")]
        const NONE = ffi::NM_MPTCP_FLAGS_NONE as _;
        #[doc(alias = "NM_MPTCP_FLAGS_DISABLED")]
        const DISABLED = ffi::NM_MPTCP_FLAGS_DISABLED as _;
        #[doc(alias = "NM_MPTCP_FLAGS_ENABLED")]
        const ENABLED = ffi::NM_MPTCP_FLAGS_ENABLED as _;
        #[doc(alias = "NM_MPTCP_FLAGS_ALSO_WITHOUT_SYSCTL")]
        const ALSO_WITHOUT_SYSCTL = ffi::NM_MPTCP_FLAGS_ALSO_WITHOUT_SYSCTL as _;
        #[doc(alias = "NM_MPTCP_FLAGS_ALSO_WITHOUT_DEFAULT_ROUTE")]
        const ALSO_WITHOUT_DEFAULT_ROUTE = ffi::NM_MPTCP_FLAGS_ALSO_WITHOUT_DEFAULT_ROUTE as _;
        #[doc(alias = "NM_MPTCP_FLAGS_SIGNAL")]
        const SIGNAL = ffi::NM_MPTCP_FLAGS_SIGNAL as _;
        #[doc(alias = "NM_MPTCP_FLAGS_SUBFLOW")]
        const SUBFLOW = ffi::NM_MPTCP_FLAGS_SUBFLOW as _;
        #[doc(alias = "NM_MPTCP_FLAGS_BACKUP")]
        const BACKUP = ffi::NM_MPTCP_FLAGS_BACKUP as _;
        #[doc(alias = "NM_MPTCP_FLAGS_FULLMESH")]
        const FULLMESH = ffi::NM_MPTCP_FLAGS_FULLMESH as _;
    }
}

#[cfg(feature = "v1_40")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_40")))]
#[doc(hidden)]
impl IntoGlib for MptcpFlags {
    type GlibType = ffi::NMMptcpFlags;

    #[inline]
    fn into_glib(self) -> ffi::NMMptcpFlags {
        self.bits()
    }
}

#[cfg(feature = "v1_40")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_40")))]
#[doc(hidden)]
impl FromGlib<ffi::NMMptcpFlags> for MptcpFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::NMMptcpFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

#[cfg(feature = "v1_40")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_40")))]
impl StaticType for MptcpFlags {
                #[inline]
    #[doc(alias = "nm_mptcp_flags_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::nm_mptcp_flags_get_type()) }
                }
            }

#[cfg(feature = "v1_40")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_40")))]
impl glib::HasParamSpec for MptcpFlags {
                type ParamSpec = glib::ParamSpecFlags;
                type SetValue = Self;
                type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder
                }
}

#[cfg(feature = "v1_40")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_40")))]
impl glib::value::ValueType for MptcpFlags {
    type Type = Self;
}

#[cfg(feature = "v1_40")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_40")))]
unsafe impl<'a> glib::value::FromValue<'a> for MptcpFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_40")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_40")))]
impl ToValue for MptcpFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_40")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_40")))]
impl From<MptcpFlags> for glib::Value {
    #[inline]
    fn from(v: MptcpFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v1_38")]
bitflags! {
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_38")))]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "NMRadioFlags")]
    pub struct RadioFlags: u32 {
        #[doc(alias = "NM_RADIO_FLAG_NONE")]
        const NONE = ffi::NM_RADIO_FLAG_NONE as _;
        #[doc(alias = "NM_RADIO_FLAG_WLAN_AVAILABLE")]
        const WLAN_AVAILABLE = ffi::NM_RADIO_FLAG_WLAN_AVAILABLE as _;
        #[doc(alias = "NM_RADIO_FLAG_WWAN_AVAILABLE")]
        const WWAN_AVAILABLE = ffi::NM_RADIO_FLAG_WWAN_AVAILABLE as _;
    }
}

#[cfg(feature = "v1_38")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_38")))]
#[doc(hidden)]
impl IntoGlib for RadioFlags {
    type GlibType = ffi::NMRadioFlags;

    #[inline]
    fn into_glib(self) -> ffi::NMRadioFlags {
        self.bits()
    }
}

#[cfg(feature = "v1_38")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_38")))]
#[doc(hidden)]
impl FromGlib<ffi::NMRadioFlags> for RadioFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::NMRadioFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

#[cfg(feature = "v1_38")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_38")))]
impl StaticType for RadioFlags {
                #[inline]
    #[doc(alias = "nm_radio_flags_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::nm_radio_flags_get_type()) }
                }
            }

#[cfg(feature = "v1_38")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_38")))]
impl glib::HasParamSpec for RadioFlags {
                type ParamSpec = glib::ParamSpecFlags;
                type SetValue = Self;
                type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder
                }
}

#[cfg(feature = "v1_38")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_38")))]
impl glib::value::ValueType for RadioFlags {
    type Type = Self;
}

#[cfg(feature = "v1_38")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_38")))]
unsafe impl<'a> glib::value::FromValue<'a> for RadioFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_38")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_38")))]
impl ToValue for RadioFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_38")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_38")))]
impl From<RadioFlags> for glib::Value {
    #[inline]
    fn from(v: RadioFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "NMSecretAgentCapabilities")]
    pub struct SecretAgentCapabilities: u32 {
        #[doc(alias = "NM_SECRET_AGENT_CAPABILITY_NONE")]
        const NONE = ffi::NM_SECRET_AGENT_CAPABILITY_NONE as _;
        #[doc(alias = "NM_SECRET_AGENT_CAPABILITY_VPN_HINTS")]
        const VPN_HINTS = ffi::NM_SECRET_AGENT_CAPABILITY_VPN_HINTS as _;
        #[doc(alias = "NM_SECRET_AGENT_CAPABILITY_LAST")]
        const LAST = ffi::NM_SECRET_AGENT_CAPABILITY_LAST as _;
    }
}

#[doc(hidden)]
impl IntoGlib for SecretAgentCapabilities {
    type GlibType = ffi::NMSecretAgentCapabilities;

    #[inline]
    fn into_glib(self) -> ffi::NMSecretAgentCapabilities {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMSecretAgentCapabilities> for SecretAgentCapabilities {
    #[inline]
    unsafe fn from_glib(value: ffi::NMSecretAgentCapabilities) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for SecretAgentCapabilities {
                #[inline]
    #[doc(alias = "nm_secret_agent_capabilities_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::nm_secret_agent_capabilities_get_type()) }
                }
            }

impl glib::HasParamSpec for SecretAgentCapabilities {
                type ParamSpec = glib::ParamSpecFlags;
                type SetValue = Self;
                type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder
                }
}

impl glib::value::ValueType for SecretAgentCapabilities {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for SecretAgentCapabilities {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for SecretAgentCapabilities {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<SecretAgentCapabilities> for glib::Value {
    #[inline]
    fn from(v: SecretAgentCapabilities) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "NMSecretAgentGetSecretsFlags")]
    pub struct SecretAgentGetSecretsFlags: u32 {
        #[doc(alias = "NM_SECRET_AGENT_GET_SECRETS_FLAG_NONE")]
        const NONE = ffi::NM_SECRET_AGENT_GET_SECRETS_FLAG_NONE as _;
        #[doc(alias = "NM_SECRET_AGENT_GET_SECRETS_FLAG_ALLOW_INTERACTION")]
        const ALLOW_INTERACTION = ffi::NM_SECRET_AGENT_GET_SECRETS_FLAG_ALLOW_INTERACTION as _;
        #[doc(alias = "NM_SECRET_AGENT_GET_SECRETS_FLAG_REQUEST_NEW")]
        const REQUEST_NEW = ffi::NM_SECRET_AGENT_GET_SECRETS_FLAG_REQUEST_NEW as _;
        #[doc(alias = "NM_SECRET_AGENT_GET_SECRETS_FLAG_USER_REQUESTED")]
        const USER_REQUESTED = ffi::NM_SECRET_AGENT_GET_SECRETS_FLAG_USER_REQUESTED as _;
        #[doc(alias = "NM_SECRET_AGENT_GET_SECRETS_FLAG_WPS_PBC_ACTIVE")]
        const WPS_PBC_ACTIVE = ffi::NM_SECRET_AGENT_GET_SECRETS_FLAG_WPS_PBC_ACTIVE as _;
        #[doc(alias = "NM_SECRET_AGENT_GET_SECRETS_FLAG_ONLY_SYSTEM")]
        const ONLY_SYSTEM = ffi::NM_SECRET_AGENT_GET_SECRETS_FLAG_ONLY_SYSTEM as _;
        #[doc(alias = "NM_SECRET_AGENT_GET_SECRETS_FLAG_NO_ERRORS")]
        const NO_ERRORS = ffi::NM_SECRET_AGENT_GET_SECRETS_FLAG_NO_ERRORS as _;
    }
}

#[doc(hidden)]
impl IntoGlib for SecretAgentGetSecretsFlags {
    type GlibType = ffi::NMSecretAgentGetSecretsFlags;

    #[inline]
    fn into_glib(self) -> ffi::NMSecretAgentGetSecretsFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMSecretAgentGetSecretsFlags> for SecretAgentGetSecretsFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::NMSecretAgentGetSecretsFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for SecretAgentGetSecretsFlags {
                #[inline]
    #[doc(alias = "nm_secret_agent_get_secrets_flags_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::nm_secret_agent_get_secrets_flags_get_type()) }
                }
            }

impl glib::HasParamSpec for SecretAgentGetSecretsFlags {
                type ParamSpec = glib::ParamSpecFlags;
                type SetValue = Self;
                type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder
                }
}

impl glib::value::ValueType for SecretAgentGetSecretsFlags {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for SecretAgentGetSecretsFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for SecretAgentGetSecretsFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<SecretAgentGetSecretsFlags> for glib::Value {
    #[inline]
    fn from(v: SecretAgentGetSecretsFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v1_8")]
bitflags! {
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "NMSetting8021xAuthFlags")]
    pub struct Setting8021xAuthFlags: u32 {
        #[doc(alias = "NM_SETTING_802_1X_AUTH_FLAGS_NONE")]
        const NONE = ffi::NM_SETTING_802_1X_AUTH_FLAGS_NONE as _;
        #[doc(alias = "NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_0_DISABLE")]
        const TLS_1_0_DISABLE = ffi::NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_0_DISABLE as _;
        #[doc(alias = "NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_1_DISABLE")]
        const TLS_1_1_DISABLE = ffi::NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_1_DISABLE as _;
        #[doc(alias = "NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_2_DISABLE")]
        const TLS_1_2_DISABLE = ffi::NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_2_DISABLE as _;
        #[doc(alias = "NM_SETTING_802_1X_AUTH_FLAGS_TLS_DISABLE_TIME_CHECKS")]
        const TLS_DISABLE_TIME_CHECKS = ffi::NM_SETTING_802_1X_AUTH_FLAGS_TLS_DISABLE_TIME_CHECKS as _;
        #[doc(alias = "NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_3_DISABLE")]
        const TLS_1_3_DISABLE = ffi::NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_3_DISABLE as _;
        #[doc(alias = "NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_0_ENABLE")]
        const TLS_1_0_ENABLE = ffi::NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_0_ENABLE as _;
        #[doc(alias = "NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_1_ENABLE")]
        const TLS_1_1_ENABLE = ffi::NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_1_ENABLE as _;
        #[doc(alias = "NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_2_ENABLE")]
        const TLS_1_2_ENABLE = ffi::NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_2_ENABLE as _;
        #[doc(alias = "NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_3_ENABLE")]
        const TLS_1_3_ENABLE = ffi::NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_3_ENABLE as _;
        #[doc(alias = "NM_SETTING_802_1X_AUTH_FLAGS_ALL")]
        const ALL = ffi::NM_SETTING_802_1X_AUTH_FLAGS_ALL as _;
    }
}

#[cfg(feature = "v1_8")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
#[doc(hidden)]
impl IntoGlib for Setting8021xAuthFlags {
    type GlibType = ffi::NMSetting8021xAuthFlags;

    #[inline]
    fn into_glib(self) -> ffi::NMSetting8021xAuthFlags {
        self.bits()
    }
}

#[cfg(feature = "v1_8")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
#[doc(hidden)]
impl FromGlib<ffi::NMSetting8021xAuthFlags> for Setting8021xAuthFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::NMSetting8021xAuthFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

#[cfg(feature = "v1_8")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
impl StaticType for Setting8021xAuthFlags {
                #[inline]
    #[doc(alias = "nm_setting_802_1x_auth_flags_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::nm_setting_802_1x_auth_flags_get_type()) }
                }
            }

#[cfg(feature = "v1_8")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
impl glib::HasParamSpec for Setting8021xAuthFlags {
                type ParamSpec = glib::ParamSpecFlags;
                type SetValue = Self;
                type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder
                }
}

#[cfg(feature = "v1_8")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
impl glib::value::ValueType for Setting8021xAuthFlags {
    type Type = Self;
}

#[cfg(feature = "v1_8")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
unsafe impl<'a> glib::value::FromValue<'a> for Setting8021xAuthFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_8")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
impl ToValue for Setting8021xAuthFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_8")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
impl From<Setting8021xAuthFlags> for glib::Value {
    #[inline]
    fn from(v: Setting8021xAuthFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "NMSettingDcbFlags")]
    pub struct SettingDcbFlags: u32 {
        #[doc(alias = "NM_SETTING_DCB_FLAG_NONE")]
        const NONE = ffi::NM_SETTING_DCB_FLAG_NONE as _;
        #[doc(alias = "NM_SETTING_DCB_FLAG_ENABLE")]
        const ENABLE = ffi::NM_SETTING_DCB_FLAG_ENABLE as _;
        #[doc(alias = "NM_SETTING_DCB_FLAG_ADVERTISE")]
        const ADVERTISE = ffi::NM_SETTING_DCB_FLAG_ADVERTISE as _;
        #[doc(alias = "NM_SETTING_DCB_FLAG_WILLING")]
        const WILLING = ffi::NM_SETTING_DCB_FLAG_WILLING as _;
    }
}

#[doc(hidden)]
impl IntoGlib for SettingDcbFlags {
    type GlibType = ffi::NMSettingDcbFlags;

    #[inline]
    fn into_glib(self) -> ffi::NMSettingDcbFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMSettingDcbFlags> for SettingDcbFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::NMSettingDcbFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for SettingDcbFlags {
                #[inline]
    #[doc(alias = "nm_setting_dcb_flags_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::nm_setting_dcb_flags_get_type()) }
                }
            }

impl glib::HasParamSpec for SettingDcbFlags {
                type ParamSpec = glib::ParamSpecFlags;
                type SetValue = Self;
                type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder
                }
}

impl glib::value::ValueType for SettingDcbFlags {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for SettingDcbFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for SettingDcbFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<SettingDcbFlags> for glib::Value {
    #[inline]
    fn from(v: SettingDcbFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v1_52")]
bitflags! {
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "NMSettingEthtoolFecMode")]
    pub struct SettingEthtoolFecMode: u32 {
        #[doc(alias = "NM_SETTING_ETHTOOL_FEC_MODE_AUTO")]
        const AUTO = ffi::NM_SETTING_ETHTOOL_FEC_MODE_AUTO as _;
        #[doc(alias = "NM_SETTING_ETHTOOL_FEC_MODE_OFF")]
        const OFF = ffi::NM_SETTING_ETHTOOL_FEC_MODE_OFF as _;
        #[doc(alias = "NM_SETTING_ETHTOOL_FEC_MODE_RS")]
        const RS = ffi::NM_SETTING_ETHTOOL_FEC_MODE_RS as _;
        #[doc(alias = "NM_SETTING_ETHTOOL_FEC_MODE_BASER")]
        const BASER = ffi::NM_SETTING_ETHTOOL_FEC_MODE_BASER as _;
        #[doc(alias = "NM_SETTING_ETHTOOL_FEC_MODE_LLRS")]
        const LLRS = ffi::NM_SETTING_ETHTOOL_FEC_MODE_LLRS as _;
    }
}

#[cfg(feature = "v1_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
#[doc(hidden)]
impl IntoGlib for SettingEthtoolFecMode {
    type GlibType = ffi::NMSettingEthtoolFecMode;

    #[inline]
    fn into_glib(self) -> ffi::NMSettingEthtoolFecMode {
        self.bits()
    }
}

#[cfg(feature = "v1_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
#[doc(hidden)]
impl FromGlib<ffi::NMSettingEthtoolFecMode> for SettingEthtoolFecMode {
    #[inline]
    unsafe fn from_glib(value: ffi::NMSettingEthtoolFecMode) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

#[cfg(feature = "v1_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
impl StaticType for SettingEthtoolFecMode {
                #[inline]
    #[doc(alias = "nm_setting_ethtool_fec_mode_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::nm_setting_ethtool_fec_mode_get_type()) }
                }
            }

#[cfg(feature = "v1_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
impl glib::HasParamSpec for SettingEthtoolFecMode {
                type ParamSpec = glib::ParamSpecFlags;
                type SetValue = Self;
                type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder
                }
}

#[cfg(feature = "v1_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
impl glib::value::ValueType for SettingEthtoolFecMode {
    type Type = Self;
}

#[cfg(feature = "v1_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
unsafe impl<'a> glib::value::FromValue<'a> for SettingEthtoolFecMode {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
impl ToValue for SettingEthtoolFecMode {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
impl From<SettingEthtoolFecMode> for glib::Value {
    #[inline]
    fn from(v: SettingEthtoolFecMode) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "NMSettingSecretFlags")]
    pub struct SettingSecretFlags: u32 {
        #[doc(alias = "NM_SETTING_SECRET_FLAG_NONE")]
        const NONE = ffi::NM_SETTING_SECRET_FLAG_NONE as _;
        #[doc(alias = "NM_SETTING_SECRET_FLAG_AGENT_OWNED")]
        const AGENT_OWNED = ffi::NM_SETTING_SECRET_FLAG_AGENT_OWNED as _;
        #[doc(alias = "NM_SETTING_SECRET_FLAG_NOT_SAVED")]
        const NOT_SAVED = ffi::NM_SETTING_SECRET_FLAG_NOT_SAVED as _;
        #[doc(alias = "NM_SETTING_SECRET_FLAG_NOT_REQUIRED")]
        const NOT_REQUIRED = ffi::NM_SETTING_SECRET_FLAG_NOT_REQUIRED as _;
    }
}

#[doc(hidden)]
impl IntoGlib for SettingSecretFlags {
    type GlibType = ffi::NMSettingSecretFlags;

    #[inline]
    fn into_glib(self) -> ffi::NMSettingSecretFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMSettingSecretFlags> for SettingSecretFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::NMSettingSecretFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for SettingSecretFlags {
                #[inline]
    #[doc(alias = "nm_setting_secret_flags_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::nm_setting_secret_flags_get_type()) }
                }
            }

impl glib::HasParamSpec for SettingSecretFlags {
                type ParamSpec = glib::ParamSpecFlags;
                type SetValue = Self;
                type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder
                }
}

impl glib::value::ValueType for SettingSecretFlags {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for SettingSecretFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for SettingSecretFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<SettingSecretFlags> for glib::Value {
    #[inline]
    fn from(v: SettingSecretFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v1_2")]
bitflags! {
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "NMSettingWiredWakeOnLan")]
    pub struct SettingWiredWakeOnLan: u32 {
        #[doc(alias = "NM_SETTING_WIRED_WAKE_ON_LAN_PHY")]
        const PHY = ffi::NM_SETTING_WIRED_WAKE_ON_LAN_PHY as _;
        #[doc(alias = "NM_SETTING_WIRED_WAKE_ON_LAN_UNICAST")]
        const UNICAST = ffi::NM_SETTING_WIRED_WAKE_ON_LAN_UNICAST as _;
        #[doc(alias = "NM_SETTING_WIRED_WAKE_ON_LAN_MULTICAST")]
        const MULTICAST = ffi::NM_SETTING_WIRED_WAKE_ON_LAN_MULTICAST as _;
        #[doc(alias = "NM_SETTING_WIRED_WAKE_ON_LAN_BROADCAST")]
        const BROADCAST = ffi::NM_SETTING_WIRED_WAKE_ON_LAN_BROADCAST as _;
        #[doc(alias = "NM_SETTING_WIRED_WAKE_ON_LAN_ARP")]
        const ARP = ffi::NM_SETTING_WIRED_WAKE_ON_LAN_ARP as _;
        #[doc(alias = "NM_SETTING_WIRED_WAKE_ON_LAN_MAGIC")]
        const MAGIC = ffi::NM_SETTING_WIRED_WAKE_ON_LAN_MAGIC as _;
        #[doc(alias = "NM_SETTING_WIRED_WAKE_ON_LAN_DEFAULT")]
        const DEFAULT = ffi::NM_SETTING_WIRED_WAKE_ON_LAN_DEFAULT as _;
        #[doc(alias = "NM_SETTING_WIRED_WAKE_ON_LAN_IGNORE")]
        const IGNORE = ffi::NM_SETTING_WIRED_WAKE_ON_LAN_IGNORE as _;
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
#[doc(hidden)]
impl IntoGlib for SettingWiredWakeOnLan {
    type GlibType = ffi::NMSettingWiredWakeOnLan;

    #[inline]
    fn into_glib(self) -> ffi::NMSettingWiredWakeOnLan {
        self.bits()
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
#[doc(hidden)]
impl FromGlib<ffi::NMSettingWiredWakeOnLan> for SettingWiredWakeOnLan {
    #[inline]
    unsafe fn from_glib(value: ffi::NMSettingWiredWakeOnLan) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
impl StaticType for SettingWiredWakeOnLan {
                #[inline]
    #[doc(alias = "nm_setting_wired_wake_on_lan_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::nm_setting_wired_wake_on_lan_get_type()) }
                }
            }

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
impl glib::HasParamSpec for SettingWiredWakeOnLan {
                type ParamSpec = glib::ParamSpecFlags;
                type SetValue = Self;
                type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder
                }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
impl glib::value::ValueType for SettingWiredWakeOnLan {
    type Type = Self;
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
unsafe impl<'a> glib::value::FromValue<'a> for SettingWiredWakeOnLan {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
impl ToValue for SettingWiredWakeOnLan {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
impl From<SettingWiredWakeOnLan> for glib::Value {
    #[inline]
    fn from(v: SettingWiredWakeOnLan) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v1_10")]
bitflags! {
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "NMSettingWirelessSecurityWpsMethod")]
    pub struct SettingWirelessSecurityWpsMethod: u32 {
        #[doc(alias = "NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_DEFAULT")]
        const DEFAULT = ffi::NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_DEFAULT as _;
        #[doc(alias = "NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_DISABLED")]
        const DISABLED = ffi::NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_DISABLED as _;
        #[doc(alias = "NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_AUTO")]
        const AUTO = ffi::NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_AUTO as _;
        #[doc(alias = "NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_PBC")]
        const PBC = ffi::NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_PBC as _;
        #[doc(alias = "NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_PIN")]
        const PIN = ffi::NM_SETTING_WIRELESS_SECURITY_WPS_METHOD_PIN as _;
    }
}

#[cfg(feature = "v1_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
#[doc(hidden)]
impl IntoGlib for SettingWirelessSecurityWpsMethod {
    type GlibType = ffi::NMSettingWirelessSecurityWpsMethod;

    #[inline]
    fn into_glib(self) -> ffi::NMSettingWirelessSecurityWpsMethod {
        self.bits()
    }
}

#[cfg(feature = "v1_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
#[doc(hidden)]
impl FromGlib<ffi::NMSettingWirelessSecurityWpsMethod> for SettingWirelessSecurityWpsMethod {
    #[inline]
    unsafe fn from_glib(value: ffi::NMSettingWirelessSecurityWpsMethod) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

#[cfg(feature = "v1_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
impl StaticType for SettingWirelessSecurityWpsMethod {
                #[inline]
    #[doc(alias = "nm_setting_wireless_security_wps_method_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::nm_setting_wireless_security_wps_method_get_type()) }
                }
            }

#[cfg(feature = "v1_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
impl glib::HasParamSpec for SettingWirelessSecurityWpsMethod {
                type ParamSpec = glib::ParamSpecFlags;
                type SetValue = Self;
                type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder
                }
}

#[cfg(feature = "v1_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
impl glib::value::ValueType for SettingWirelessSecurityWpsMethod {
    type Type = Self;
}

#[cfg(feature = "v1_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
unsafe impl<'a> glib::value::FromValue<'a> for SettingWirelessSecurityWpsMethod {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
impl ToValue for SettingWirelessSecurityWpsMethod {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
impl From<SettingWirelessSecurityWpsMethod> for glib::Value {
    #[inline]
    fn from(v: SettingWirelessSecurityWpsMethod) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v1_12")]
bitflags! {
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "NMSettingWirelessWakeOnWLan")]
    pub struct SettingWirelessWakeOnWLan: u32 {
        #[doc(alias = "NM_SETTING_WIRELESS_WAKE_ON_WLAN_ANY")]
        const ANY = ffi::NM_SETTING_WIRELESS_WAKE_ON_WLAN_ANY as _;
        #[doc(alias = "NM_SETTING_WIRELESS_WAKE_ON_WLAN_DISCONNECT")]
        const DISCONNECT = ffi::NM_SETTING_WIRELESS_WAKE_ON_WLAN_DISCONNECT as _;
        #[doc(alias = "NM_SETTING_WIRELESS_WAKE_ON_WLAN_MAGIC")]
        const MAGIC = ffi::NM_SETTING_WIRELESS_WAKE_ON_WLAN_MAGIC as _;
        #[doc(alias = "NM_SETTING_WIRELESS_WAKE_ON_WLAN_GTK_REKEY_FAILURE")]
        const GTK_REKEY_FAILURE = ffi::NM_SETTING_WIRELESS_WAKE_ON_WLAN_GTK_REKEY_FAILURE as _;
        #[doc(alias = "NM_SETTING_WIRELESS_WAKE_ON_WLAN_EAP_IDENTITY_REQUEST")]
        const EAP_IDENTITY_REQUEST = ffi::NM_SETTING_WIRELESS_WAKE_ON_WLAN_EAP_IDENTITY_REQUEST as _;
        #[doc(alias = "NM_SETTING_WIRELESS_WAKE_ON_WLAN_4WAY_HANDSHAKE")]
        const _4WAY_HANDSHAKE = ffi::NM_SETTING_WIRELESS_WAKE_ON_WLAN_4WAY_HANDSHAKE as _;
        #[doc(alias = "NM_SETTING_WIRELESS_WAKE_ON_WLAN_RFKILL_RELEASE")]
        const RFKILL_RELEASE = ffi::NM_SETTING_WIRELESS_WAKE_ON_WLAN_RFKILL_RELEASE as _;
        #[doc(alias = "NM_SETTING_WIRELESS_WAKE_ON_WLAN_TCP")]
        const TCP = ffi::NM_SETTING_WIRELESS_WAKE_ON_WLAN_TCP as _;
        #[doc(alias = "NM_SETTING_WIRELESS_WAKE_ON_WLAN_ALL")]
        const ALL = ffi::NM_SETTING_WIRELESS_WAKE_ON_WLAN_ALL as _;
        #[doc(alias = "NM_SETTING_WIRELESS_WAKE_ON_WLAN_DEFAULT")]
        const DEFAULT = ffi::NM_SETTING_WIRELESS_WAKE_ON_WLAN_DEFAULT as _;
        #[doc(alias = "NM_SETTING_WIRELESS_WAKE_ON_WLAN_IGNORE")]
        const IGNORE = ffi::NM_SETTING_WIRELESS_WAKE_ON_WLAN_IGNORE as _;
    }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
#[doc(hidden)]
impl IntoGlib for SettingWirelessWakeOnWLan {
    type GlibType = ffi::NMSettingWirelessWakeOnWLan;

    #[inline]
    fn into_glib(self) -> ffi::NMSettingWirelessWakeOnWLan {
        self.bits()
    }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
#[doc(hidden)]
impl FromGlib<ffi::NMSettingWirelessWakeOnWLan> for SettingWirelessWakeOnWLan {
    #[inline]
    unsafe fn from_glib(value: ffi::NMSettingWirelessWakeOnWLan) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
impl StaticType for SettingWirelessWakeOnWLan {
                #[inline]
    #[doc(alias = "nm_setting_wireless_wake_on_wlan_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::nm_setting_wireless_wake_on_wlan_get_type()) }
                }
            }

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
impl glib::HasParamSpec for SettingWirelessWakeOnWLan {
                type ParamSpec = glib::ParamSpecFlags;
                type SetValue = Self;
                type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder
                }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
impl glib::value::ValueType for SettingWirelessWakeOnWLan {
    type Type = Self;
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
unsafe impl<'a> glib::value::FromValue<'a> for SettingWirelessWakeOnWLan {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
impl ToValue for SettingWirelessWakeOnWLan {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
impl From<SettingWirelessWakeOnWLan> for glib::Value {
    #[inline]
    fn from(v: SettingWirelessWakeOnWLan) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v1_20")]
bitflags! {
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "NMSettingsAddConnection2Flags")]
    pub struct SettingsAddConnection2Flags: u32 {
        #[doc(alias = "NM_SETTINGS_ADD_CONNECTION2_FLAG_NONE")]
        const NONE = ffi::NM_SETTINGS_ADD_CONNECTION2_FLAG_NONE as _;
        #[doc(alias = "NM_SETTINGS_ADD_CONNECTION2_FLAG_TO_DISK")]
        const TO_DISK = ffi::NM_SETTINGS_ADD_CONNECTION2_FLAG_TO_DISK as _;
        #[doc(alias = "NM_SETTINGS_ADD_CONNECTION2_FLAG_IN_MEMORY")]
        const IN_MEMORY = ffi::NM_SETTINGS_ADD_CONNECTION2_FLAG_IN_MEMORY as _;
        #[doc(alias = "NM_SETTINGS_ADD_CONNECTION2_FLAG_BLOCK_AUTOCONNECT")]
        const BLOCK_AUTOCONNECT = ffi::NM_SETTINGS_ADD_CONNECTION2_FLAG_BLOCK_AUTOCONNECT as _;
    }
}

#[cfg(feature = "v1_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
#[doc(hidden)]
impl IntoGlib for SettingsAddConnection2Flags {
    type GlibType = ffi::NMSettingsAddConnection2Flags;

    #[inline]
    fn into_glib(self) -> ffi::NMSettingsAddConnection2Flags {
        self.bits()
    }
}

#[cfg(feature = "v1_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
#[doc(hidden)]
impl FromGlib<ffi::NMSettingsAddConnection2Flags> for SettingsAddConnection2Flags {
    #[inline]
    unsafe fn from_glib(value: ffi::NMSettingsAddConnection2Flags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

#[cfg(feature = "v1_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
impl StaticType for SettingsAddConnection2Flags {
                #[inline]
    #[doc(alias = "nm_settings_add_connection2_flags_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::nm_settings_add_connection2_flags_get_type()) }
                }
            }

#[cfg(feature = "v1_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
impl glib::HasParamSpec for SettingsAddConnection2Flags {
                type ParamSpec = glib::ParamSpecFlags;
                type SetValue = Self;
                type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder
                }
}

#[cfg(feature = "v1_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
impl glib::value::ValueType for SettingsAddConnection2Flags {
    type Type = Self;
}

#[cfg(feature = "v1_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
unsafe impl<'a> glib::value::FromValue<'a> for SettingsAddConnection2Flags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
impl ToValue for SettingsAddConnection2Flags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
impl From<SettingsAddConnection2Flags> for glib::Value {
    #[inline]
    fn from(v: SettingsAddConnection2Flags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v1_12")]
bitflags! {
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "NMSettingsConnectionFlags")]
    pub struct SettingsConnectionFlags: u32 {
        #[doc(alias = "NM_SETTINGS_CONNECTION_FLAG_NONE")]
        const NONE = ffi::NM_SETTINGS_CONNECTION_FLAG_NONE as _;
        #[doc(alias = "NM_SETTINGS_CONNECTION_FLAG_UNSAVED")]
        const UNSAVED = ffi::NM_SETTINGS_CONNECTION_FLAG_UNSAVED as _;
        #[doc(alias = "NM_SETTINGS_CONNECTION_FLAG_NM_GENERATED")]
        const NM_GENERATED = ffi::NM_SETTINGS_CONNECTION_FLAG_NM_GENERATED as _;
        #[doc(alias = "NM_SETTINGS_CONNECTION_FLAG_VOLATILE")]
        const VOLATILE = ffi::NM_SETTINGS_CONNECTION_FLAG_VOLATILE as _;
        #[doc(alias = "NM_SETTINGS_CONNECTION_FLAG_EXTERNAL")]
        const EXTERNAL = ffi::NM_SETTINGS_CONNECTION_FLAG_EXTERNAL as _;
    }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
#[doc(hidden)]
impl IntoGlib for SettingsConnectionFlags {
    type GlibType = ffi::NMSettingsConnectionFlags;

    #[inline]
    fn into_glib(self) -> ffi::NMSettingsConnectionFlags {
        self.bits()
    }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
#[doc(hidden)]
impl FromGlib<ffi::NMSettingsConnectionFlags> for SettingsConnectionFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::NMSettingsConnectionFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
impl StaticType for SettingsConnectionFlags {
                #[inline]
    #[doc(alias = "nm_settings_connection_flags_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::nm_settings_connection_flags_get_type()) }
                }
            }

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
impl glib::HasParamSpec for SettingsConnectionFlags {
                type ParamSpec = glib::ParamSpecFlags;
                type SetValue = Self;
                type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder
                }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
impl glib::value::ValueType for SettingsConnectionFlags {
    type Type = Self;
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
unsafe impl<'a> glib::value::FromValue<'a> for SettingsConnectionFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
impl ToValue for SettingsConnectionFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
impl From<SettingsConnectionFlags> for glib::Value {
    #[inline]
    fn from(v: SettingsConnectionFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v1_12")]
bitflags! {
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "NMSettingsUpdate2Flags")]
    pub struct SettingsUpdate2Flags: u32 {
        #[doc(alias = "NM_SETTINGS_UPDATE2_FLAG_NONE")]
        const NONE = ffi::NM_SETTINGS_UPDATE2_FLAG_NONE as _;
        #[doc(alias = "NM_SETTINGS_UPDATE2_FLAG_TO_DISK")]
        const TO_DISK = ffi::NM_SETTINGS_UPDATE2_FLAG_TO_DISK as _;
        #[doc(alias = "NM_SETTINGS_UPDATE2_FLAG_IN_MEMORY")]
        const IN_MEMORY = ffi::NM_SETTINGS_UPDATE2_FLAG_IN_MEMORY as _;
        #[doc(alias = "NM_SETTINGS_UPDATE2_FLAG_IN_MEMORY_DETACHED")]
        const IN_MEMORY_DETACHED = ffi::NM_SETTINGS_UPDATE2_FLAG_IN_MEMORY_DETACHED as _;
        #[doc(alias = "NM_SETTINGS_UPDATE2_FLAG_IN_MEMORY_ONLY")]
        const IN_MEMORY_ONLY = ffi::NM_SETTINGS_UPDATE2_FLAG_IN_MEMORY_ONLY as _;
        #[doc(alias = "NM_SETTINGS_UPDATE2_FLAG_VOLATILE")]
        const VOLATILE = ffi::NM_SETTINGS_UPDATE2_FLAG_VOLATILE as _;
        #[doc(alias = "NM_SETTINGS_UPDATE2_FLAG_BLOCK_AUTOCONNECT")]
        const BLOCK_AUTOCONNECT = ffi::NM_SETTINGS_UPDATE2_FLAG_BLOCK_AUTOCONNECT as _;
        #[doc(alias = "NM_SETTINGS_UPDATE2_FLAG_NO_REAPPLY")]
        const NO_REAPPLY = ffi::NM_SETTINGS_UPDATE2_FLAG_NO_REAPPLY as _;
    }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
#[doc(hidden)]
impl IntoGlib for SettingsUpdate2Flags {
    type GlibType = ffi::NMSettingsUpdate2Flags;

    #[inline]
    fn into_glib(self) -> ffi::NMSettingsUpdate2Flags {
        self.bits()
    }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
#[doc(hidden)]
impl FromGlib<ffi::NMSettingsUpdate2Flags> for SettingsUpdate2Flags {
    #[inline]
    unsafe fn from_glib(value: ffi::NMSettingsUpdate2Flags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
impl StaticType for SettingsUpdate2Flags {
                #[inline]
    #[doc(alias = "nm_settings_update2_flags_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::nm_settings_update2_flags_get_type()) }
                }
            }

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
impl glib::HasParamSpec for SettingsUpdate2Flags {
                type ParamSpec = glib::ParamSpecFlags;
                type SetValue = Self;
                type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder
                }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
impl glib::value::ValueType for SettingsUpdate2Flags {
    type Type = Self;
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
unsafe impl<'a> glib::value::FromValue<'a> for SettingsUpdate2Flags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
impl ToValue for SettingsUpdate2Flags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
impl From<SettingsUpdate2Flags> for glib::Value {
    #[inline]
    fn from(v: SettingsUpdate2Flags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v1_12")]
bitflags! {
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "NMTeamLinkWatcherArpPingFlags")]
    pub struct TeamLinkWatcherArpPingFlags: u32 {
        #[doc(alias = "NM_TEAM_LINK_WATCHER_ARP_PING_FLAG_VALIDATE_ACTIVE")]
        const VALIDATE_ACTIVE = ffi::NM_TEAM_LINK_WATCHER_ARP_PING_FLAG_VALIDATE_ACTIVE as _;
        #[doc(alias = "NM_TEAM_LINK_WATCHER_ARP_PING_FLAG_VALIDATE_INACTIVE")]
        const VALIDATE_INACTIVE = ffi::NM_TEAM_LINK_WATCHER_ARP_PING_FLAG_VALIDATE_INACTIVE as _;
        #[doc(alias = "NM_TEAM_LINK_WATCHER_ARP_PING_FLAG_SEND_ALWAYS")]
        const SEND_ALWAYS = ffi::NM_TEAM_LINK_WATCHER_ARP_PING_FLAG_SEND_ALWAYS as _;
    }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
#[doc(hidden)]
impl IntoGlib for TeamLinkWatcherArpPingFlags {
    type GlibType = ffi::NMTeamLinkWatcherArpPingFlags;

    #[inline]
    fn into_glib(self) -> ffi::NMTeamLinkWatcherArpPingFlags {
        self.bits()
    }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
#[doc(hidden)]
impl FromGlib<ffi::NMTeamLinkWatcherArpPingFlags> for TeamLinkWatcherArpPingFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::NMTeamLinkWatcherArpPingFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
impl StaticType for TeamLinkWatcherArpPingFlags {
                #[inline]
    #[doc(alias = "nm_team_link_watcher_arp_ping_flags_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::nm_team_link_watcher_arp_ping_flags_get_type()) }
                }
            }

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
impl glib::HasParamSpec for TeamLinkWatcherArpPingFlags {
                type ParamSpec = glib::ParamSpecFlags;
                type SetValue = Self;
                type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder
                }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
impl glib::value::ValueType for TeamLinkWatcherArpPingFlags {
    type Type = Self;
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
unsafe impl<'a> glib::value::FromValue<'a> for TeamLinkWatcherArpPingFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
impl ToValue for TeamLinkWatcherArpPingFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
impl From<TeamLinkWatcherArpPingFlags> for glib::Value {
    #[inline]
    fn from(v: TeamLinkWatcherArpPingFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "NMVlanFlags")]
    pub struct VlanFlags: u32 {
        #[doc(alias = "NM_VLAN_FLAG_REORDER_HEADERS")]
        const REORDER_HEADERS = ffi::NM_VLAN_FLAG_REORDER_HEADERS as _;
        #[doc(alias = "NM_VLAN_FLAG_GVRP")]
        const GVRP = ffi::NM_VLAN_FLAG_GVRP as _;
        #[doc(alias = "NM_VLAN_FLAG_LOOSE_BINDING")]
        const LOOSE_BINDING = ffi::NM_VLAN_FLAG_LOOSE_BINDING as _;
        #[doc(alias = "NM_VLAN_FLAG_MVRP")]
        const MVRP = ffi::NM_VLAN_FLAG_MVRP as _;
    }
}

#[doc(hidden)]
impl IntoGlib for VlanFlags {
    type GlibType = ffi::NMVlanFlags;

    #[inline]
    fn into_glib(self) -> ffi::NMVlanFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMVlanFlags> for VlanFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::NMVlanFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for VlanFlags {
                #[inline]
    #[doc(alias = "nm_vlan_flags_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::nm_vlan_flags_get_type()) }
                }
            }

impl glib::HasParamSpec for VlanFlags {
                type ParamSpec = glib::ParamSpecFlags;
                type SetValue = Self;
                type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder
                }
}

impl glib::value::ValueType for VlanFlags {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for VlanFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for VlanFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<VlanFlags> for glib::Value {
    #[inline]
    fn from(v: VlanFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "NMVpnEditorPluginCapability")]
    pub struct VpnEditorPluginCapability: u32 {
        #[doc(alias = "NM_VPN_EDITOR_PLUGIN_CAPABILITY_NONE")]
        const NONE = ffi::NM_VPN_EDITOR_PLUGIN_CAPABILITY_NONE as _;
        #[doc(alias = "NM_VPN_EDITOR_PLUGIN_CAPABILITY_IMPORT")]
        const IMPORT = ffi::NM_VPN_EDITOR_PLUGIN_CAPABILITY_IMPORT as _;
        #[doc(alias = "NM_VPN_EDITOR_PLUGIN_CAPABILITY_EXPORT")]
        const EXPORT = ffi::NM_VPN_EDITOR_PLUGIN_CAPABILITY_EXPORT as _;
        #[doc(alias = "NM_VPN_EDITOR_PLUGIN_CAPABILITY_IPV6")]
        const IPV6 = ffi::NM_VPN_EDITOR_PLUGIN_CAPABILITY_IPV6 as _;
        #[doc(alias = "NM_VPN_EDITOR_PLUGIN_CAPABILITY_NO_EDITOR")]
        const NO_EDITOR = ffi::NM_VPN_EDITOR_PLUGIN_CAPABILITY_NO_EDITOR as _;
    }
}

#[doc(hidden)]
impl IntoGlib for VpnEditorPluginCapability {
    type GlibType = ffi::NMVpnEditorPluginCapability;

    #[inline]
    fn into_glib(self) -> ffi::NMVpnEditorPluginCapability {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMVpnEditorPluginCapability> for VpnEditorPluginCapability {
    #[inline]
    unsafe fn from_glib(value: ffi::NMVpnEditorPluginCapability) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for VpnEditorPluginCapability {
                #[inline]
    #[doc(alias = "nm_vpn_editor_plugin_capability_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::nm_vpn_editor_plugin_capability_get_type()) }
                }
            }

impl glib::HasParamSpec for VpnEditorPluginCapability {
                type ParamSpec = glib::ParamSpecFlags;
                type SetValue = Self;
                type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder
                }
}

impl glib::value::ValueType for VpnEditorPluginCapability {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for VpnEditorPluginCapability {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for VpnEditorPluginCapability {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<VpnEditorPluginCapability> for glib::Value {
    #[inline]
    fn from(v: VpnEditorPluginCapability) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

