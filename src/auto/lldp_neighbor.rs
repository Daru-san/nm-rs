// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir
// from gtk-girs (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use crate::{ffi};
#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
use glib::{translate::*};

glib::wrapper! {
    #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct LldpNeighbor(Shared<ffi::NMLldpNeighbor>);

    match fn {
        ref => |ptr| ffi::nm_lldp_neighbor_ref(ptr),
        unref => |ptr| ffi::nm_lldp_neighbor_unref(ptr),
        type_ => || ffi::nm_lldp_neighbor_get_type(),
    }
}

impl LldpNeighbor {
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    #[doc(alias = "nm_lldp_neighbor_new")]
    pub fn new() -> LldpNeighbor {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::nm_lldp_neighbor_new())
        }
    }

    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    #[doc(alias = "nm_lldp_neighbor_get_attr_names")]
    #[doc(alias = "get_attr_names")]
    pub fn attr_names(&self) -> Vec<glib::GString> {
        unsafe {
            FromGlibPtrContainer::from_glib_full(ffi::nm_lldp_neighbor_get_attr_names(self.to_glib_none().0))
        }
    }

    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    #[doc(alias = "nm_lldp_neighbor_get_attr_string_value")]
    #[doc(alias = "get_attr_string_value")]
    pub fn attr_string_value(&self, name: &str) -> Option<Option<glib::GString>> {
        unsafe {
            let mut out_value = std::ptr::null();
            let ret = from_glib(ffi::nm_lldp_neighbor_get_attr_string_value(self.to_glib_none().0, name.to_glib_none().0, &mut out_value));
            if ret { Some(from_glib_none(out_value)) } else { None }
        }
    }

    //#[cfg(feature = "v1_2")]
    //#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    //#[doc(alias = "nm_lldp_neighbor_get_attr_type")]
    //#[doc(alias = "get_attr_type")]
    //pub fn attr_type(&self, name: &str) -> /*Ignored*/glib::VariantType {
    //    unsafe { TODO: call ffi:nm_lldp_neighbor_get_attr_type() }
    //}

    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    #[doc(alias = "nm_lldp_neighbor_get_attr_uint_value")]
    #[doc(alias = "get_attr_uint_value")]
    pub fn attr_uint_value(&self, name: &str) -> Option<u32> {
        unsafe {
            let mut out_value = std::mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::nm_lldp_neighbor_get_attr_uint_value(self.to_glib_none().0, name.to_glib_none().0, out_value.as_mut_ptr()));
            if ret { Some(out_value.assume_init()) } else { None }
        }
    }

    //#[cfg(feature = "v1_18")]
    //#[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    //#[doc(alias = "nm_lldp_neighbor_get_attr_value")]
    //#[doc(alias = "get_attr_value")]
    //pub fn attr_value(&self, name: &str) -> /*Ignored*/glib::Variant {
    //    unsafe { TODO: call ffi:nm_lldp_neighbor_get_attr_value() }
    //}
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
impl Default for LldpNeighbor {
                     fn default() -> Self {
                         Self::new()
                     }
                 }
