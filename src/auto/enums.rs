// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir
// from gtk-girs (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use crate::ffi;
use glib::{prelude::*, translate::*};

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum NM80211Mode {
    #[doc(alias = "NM_802_11_MODE_UNKNOWN")]
    Unknown,
    #[doc(alias = "NM_802_11_MODE_ADHOC")]
    Adhoc,
    #[doc(alias = "NM_802_11_MODE_INFRA")]
    Infra,
    #[doc(alias = "NM_802_11_MODE_AP")]
    Ap,
    #[doc(alias = "NM_802_11_MODE_MESH")]
    Mesh,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for NM80211Mode {
    type GlibType = ffi::NM80211Mode;

    #[inline]
    fn into_glib(self) -> ffi::NM80211Mode {
        match self {
            Self::Unknown => ffi::NM_802_11_MODE_UNKNOWN,
            Self::Adhoc => ffi::NM_802_11_MODE_ADHOC,
            Self::Infra => ffi::NM_802_11_MODE_INFRA,
            Self::Ap => ffi::NM_802_11_MODE_AP,
            Self::Mesh => ffi::NM_802_11_MODE_MESH,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NM80211Mode> for NM80211Mode {
    #[inline]
    unsafe fn from_glib(value: ffi::NM80211Mode) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_802_11_MODE_UNKNOWN => Self::Unknown,
            ffi::NM_802_11_MODE_ADHOC => Self::Adhoc,
            ffi::NM_802_11_MODE_INFRA => Self::Infra,
            ffi::NM_802_11_MODE_AP => Self::Ap,
            ffi::NM_802_11_MODE_MESH => Self::Mesh,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for NM80211Mode {
    #[inline]
    #[doc(alias = "nm_802_11_mode_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_802_11_mode_get_type()) }
    }
}

impl glib::HasParamSpec for NM80211Mode {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for NM80211Mode {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for NM80211Mode {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for NM80211Mode {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<NM80211Mode> for glib::Value {
    #[inline]
    fn from(v: NM80211Mode) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// #NMActiveConnectionState values indicate the state of a connection to a
/// specific network while it is starting, connected, or disconnecting from that
/// network.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMActiveConnectionState")]
pub enum ActiveConnectionState {
    /// the state of the connection is unknown
    #[doc(alias = "NM_ACTIVE_CONNECTION_STATE_UNKNOWN")]
    Unknown,
    /// a network connection is being prepared
    #[doc(alias = "NM_ACTIVE_CONNECTION_STATE_ACTIVATING")]
    Activating,
    /// there is a connection to the network
    #[doc(alias = "NM_ACTIVE_CONNECTION_STATE_ACTIVATED")]
    Activated,
    /// the network connection is being
    ///   torn down and cleaned up
    #[doc(alias = "NM_ACTIVE_CONNECTION_STATE_DEACTIVATING")]
    Deactivating,
    /// the network connection is disconnected
    ///   and will be removed
    #[doc(alias = "NM_ACTIVE_CONNECTION_STATE_DEACTIVATED")]
    Deactivated,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for ActiveConnectionState {
    type GlibType = ffi::NMActiveConnectionState;

    #[inline]
    fn into_glib(self) -> ffi::NMActiveConnectionState {
        match self {
            Self::Unknown => ffi::NM_ACTIVE_CONNECTION_STATE_UNKNOWN,
            Self::Activating => ffi::NM_ACTIVE_CONNECTION_STATE_ACTIVATING,
            Self::Activated => ffi::NM_ACTIVE_CONNECTION_STATE_ACTIVATED,
            Self::Deactivating => ffi::NM_ACTIVE_CONNECTION_STATE_DEACTIVATING,
            Self::Deactivated => ffi::NM_ACTIVE_CONNECTION_STATE_DEACTIVATED,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMActiveConnectionState> for ActiveConnectionState {
    #[inline]
    unsafe fn from_glib(value: ffi::NMActiveConnectionState) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_ACTIVE_CONNECTION_STATE_UNKNOWN => Self::Unknown,
            ffi::NM_ACTIVE_CONNECTION_STATE_ACTIVATING => Self::Activating,
            ffi::NM_ACTIVE_CONNECTION_STATE_ACTIVATED => Self::Activated,
            ffi::NM_ACTIVE_CONNECTION_STATE_DEACTIVATING => Self::Deactivating,
            ffi::NM_ACTIVE_CONNECTION_STATE_DEACTIVATED => Self::Deactivated,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for ActiveConnectionState {
    #[inline]
    #[doc(alias = "nm_active_connection_state_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_active_connection_state_get_type()) }
    }
}

impl glib::HasParamSpec for ActiveConnectionState {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for ActiveConnectionState {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for ActiveConnectionState {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ActiveConnectionState {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<ActiveConnectionState> for glib::Value {
    #[inline]
    fn from(v: ActiveConnectionState) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// Active connection state reasons.
#[cfg(feature = "v1_8")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMActiveConnectionStateReason")]
pub enum ActiveConnectionStateReason {
    /// The reason for the active connection
    ///   state change is unknown.
    #[doc(alias = "NM_ACTIVE_CONNECTION_STATE_REASON_UNKNOWN")]
    Unknown,
    /// No reason was given for the active
    ///   connection state change.
    #[doc(alias = "NM_ACTIVE_CONNECTION_STATE_REASON_NONE")]
    None,
    /// The active connection changed
    ///   state because the user disconnected it.
    #[doc(alias = "NM_ACTIVE_CONNECTION_STATE_REASON_USER_DISCONNECTED")]
    UserDisconnected,
    /// The active connection
    ///   changed state because the device it was using was disconnected.
    #[doc(alias = "NM_ACTIVE_CONNECTION_STATE_REASON_DEVICE_DISCONNECTED")]
    DeviceDisconnected,
    /// The service providing the
    ///   VPN connection was stopped.
    #[doc(alias = "NM_ACTIVE_CONNECTION_STATE_REASON_SERVICE_STOPPED")]
    ServiceStopped,
    /// The IP config of the active
    ///   connection was invalid.
    #[doc(alias = "NM_ACTIVE_CONNECTION_STATE_REASON_IP_CONFIG_INVALID")]
    IpConfigInvalid,
    /// The connection attempt to
    ///   the VPN service timed out.
    #[doc(alias = "NM_ACTIVE_CONNECTION_STATE_REASON_CONNECT_TIMEOUT")]
    ConnectTimeout,
    /// A timeout occurred
    ///   while starting the service providing the VPN connection.
    #[doc(alias = "NM_ACTIVE_CONNECTION_STATE_REASON_SERVICE_START_TIMEOUT")]
    ServiceStartTimeout,
    /// Starting the service
    ///   providing the VPN connection failed.
    #[doc(alias = "NM_ACTIVE_CONNECTION_STATE_REASON_SERVICE_START_FAILED")]
    ServiceStartFailed,
    /// Necessary secrets for the
    ///   connection were not provided.
    #[doc(alias = "NM_ACTIVE_CONNECTION_STATE_REASON_NO_SECRETS")]
    NoSecrets,
    /// Authentication to the
    ///   server failed.
    #[doc(alias = "NM_ACTIVE_CONNECTION_STATE_REASON_LOGIN_FAILED")]
    LoginFailed,
    /// The connection was
    ///   deleted from settings.
    #[doc(alias = "NM_ACTIVE_CONNECTION_STATE_REASON_CONNECTION_REMOVED")]
    ConnectionRemoved,
    /// Master connection of this
    ///   connection failed to activate.
    #[doc(alias = "NM_ACTIVE_CONNECTION_STATE_REASON_DEPENDENCY_FAILED")]
    DependencyFailed,
    /// Could not create the
    ///   software device link.
    #[doc(alias = "NM_ACTIVE_CONNECTION_STATE_REASON_DEVICE_REALIZE_FAILED")]
    DeviceRealizeFailed,
    /// The device this connection
    ///   depended on disappeared.
    #[doc(alias = "NM_ACTIVE_CONNECTION_STATE_REASON_DEVICE_REMOVED")]
    DeviceRemoved,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v1_8")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
#[doc(hidden)]
impl IntoGlib for ActiveConnectionStateReason {
    type GlibType = ffi::NMActiveConnectionStateReason;

    fn into_glib(self) -> ffi::NMActiveConnectionStateReason {
        match self {
            Self::Unknown => ffi::NM_ACTIVE_CONNECTION_STATE_REASON_UNKNOWN,
            Self::None => ffi::NM_ACTIVE_CONNECTION_STATE_REASON_NONE,
            Self::UserDisconnected => ffi::NM_ACTIVE_CONNECTION_STATE_REASON_USER_DISCONNECTED,
            Self::DeviceDisconnected => ffi::NM_ACTIVE_CONNECTION_STATE_REASON_DEVICE_DISCONNECTED,
            Self::ServiceStopped => ffi::NM_ACTIVE_CONNECTION_STATE_REASON_SERVICE_STOPPED,
            Self::IpConfigInvalid => ffi::NM_ACTIVE_CONNECTION_STATE_REASON_IP_CONFIG_INVALID,
            Self::ConnectTimeout => ffi::NM_ACTIVE_CONNECTION_STATE_REASON_CONNECT_TIMEOUT,
            Self::ServiceStartTimeout => {
                ffi::NM_ACTIVE_CONNECTION_STATE_REASON_SERVICE_START_TIMEOUT
            }
            Self::ServiceStartFailed => ffi::NM_ACTIVE_CONNECTION_STATE_REASON_SERVICE_START_FAILED,
            Self::NoSecrets => ffi::NM_ACTIVE_CONNECTION_STATE_REASON_NO_SECRETS,
            Self::LoginFailed => ffi::NM_ACTIVE_CONNECTION_STATE_REASON_LOGIN_FAILED,
            Self::ConnectionRemoved => ffi::NM_ACTIVE_CONNECTION_STATE_REASON_CONNECTION_REMOVED,
            Self::DependencyFailed => ffi::NM_ACTIVE_CONNECTION_STATE_REASON_DEPENDENCY_FAILED,
            Self::DeviceRealizeFailed => {
                ffi::NM_ACTIVE_CONNECTION_STATE_REASON_DEVICE_REALIZE_FAILED
            }
            Self::DeviceRemoved => ffi::NM_ACTIVE_CONNECTION_STATE_REASON_DEVICE_REMOVED,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v1_8")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
#[doc(hidden)]
impl FromGlib<ffi::NMActiveConnectionStateReason> for ActiveConnectionStateReason {
    unsafe fn from_glib(value: ffi::NMActiveConnectionStateReason) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_ACTIVE_CONNECTION_STATE_REASON_UNKNOWN => Self::Unknown,
            ffi::NM_ACTIVE_CONNECTION_STATE_REASON_NONE => Self::None,
            ffi::NM_ACTIVE_CONNECTION_STATE_REASON_USER_DISCONNECTED => Self::UserDisconnected,
            ffi::NM_ACTIVE_CONNECTION_STATE_REASON_DEVICE_DISCONNECTED => Self::DeviceDisconnected,
            ffi::NM_ACTIVE_CONNECTION_STATE_REASON_SERVICE_STOPPED => Self::ServiceStopped,
            ffi::NM_ACTIVE_CONNECTION_STATE_REASON_IP_CONFIG_INVALID => Self::IpConfigInvalid,
            ffi::NM_ACTIVE_CONNECTION_STATE_REASON_CONNECT_TIMEOUT => Self::ConnectTimeout,
            ffi::NM_ACTIVE_CONNECTION_STATE_REASON_SERVICE_START_TIMEOUT => {
                Self::ServiceStartTimeout
            }
            ffi::NM_ACTIVE_CONNECTION_STATE_REASON_SERVICE_START_FAILED => Self::ServiceStartFailed,
            ffi::NM_ACTIVE_CONNECTION_STATE_REASON_NO_SECRETS => Self::NoSecrets,
            ffi::NM_ACTIVE_CONNECTION_STATE_REASON_LOGIN_FAILED => Self::LoginFailed,
            ffi::NM_ACTIVE_CONNECTION_STATE_REASON_CONNECTION_REMOVED => Self::ConnectionRemoved,
            ffi::NM_ACTIVE_CONNECTION_STATE_REASON_DEPENDENCY_FAILED => Self::DependencyFailed,
            ffi::NM_ACTIVE_CONNECTION_STATE_REASON_DEVICE_REALIZE_FAILED => {
                Self::DeviceRealizeFailed
            }
            ffi::NM_ACTIVE_CONNECTION_STATE_REASON_DEVICE_REMOVED => Self::DeviceRemoved,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v1_8")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
impl StaticType for ActiveConnectionStateReason {
    #[inline]
    #[doc(alias = "nm_active_connection_state_reason_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_active_connection_state_reason_get_type()) }
    }
}

#[cfg(feature = "v1_8")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
impl glib::HasParamSpec for ActiveConnectionStateReason {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v1_8")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
impl glib::value::ValueType for ActiveConnectionStateReason {
    type Type = Self;
}

#[cfg(feature = "v1_8")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
unsafe impl<'a> glib::value::FromValue<'a> for ActiveConnectionStateReason {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_8")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
impl ToValue for ActiveConnectionStateReason {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_8")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
impl From<ActiveConnectionStateReason> for glib::Value {
    #[inline]
    fn from(v: ActiveConnectionStateReason) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// Errors returned from the secret-agent manager.
///
/// These errors may be returned from operations that could cause secrets to be
/// requested (such as nm_client_activate_connection()), and correspond to D-Bus
/// errors in the "org.freedesktop.NetworkManager.AgentManager" namespace.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMAgentManagerError")]
pub enum AgentManagerError {
    /// unknown or unspecified error
    #[doc(alias = "NM_AGENT_MANAGER_ERROR_FAILED")]
    Failed,
    /// The caller does not have permission
    ///   to register a secret agent, or is trying to register the same secret agent
    ///   twice.
    #[doc(alias = "NM_AGENT_MANAGER_ERROR_PERMISSION_DENIED")]
    PermissionDenied,
    /// The identifier is not a valid
    ///   secret agent identifier.
    #[doc(alias = "NM_AGENT_MANAGER_ERROR_INVALID_IDENTIFIER")]
    InvalidIdentifier,
    /// The caller tried to unregister an agent
    ///   that was not registered.
    #[doc(alias = "NM_AGENT_MANAGER_ERROR_NOT_REGISTERED")]
    NotRegistered,
    /// No secret agent returned secrets for this
    ///   request
    #[doc(alias = "NM_AGENT_MANAGER_ERROR_NO_SECRETS")]
    NoSecrets,
    /// The user canceled the secrets request.
    #[doc(alias = "NM_AGENT_MANAGER_ERROR_USER_CANCELED")]
    UserCanceled,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for AgentManagerError {
    type GlibType = ffi::NMAgentManagerError;

    #[inline]
    fn into_glib(self) -> ffi::NMAgentManagerError {
        match self {
            Self::Failed => ffi::NM_AGENT_MANAGER_ERROR_FAILED,
            Self::PermissionDenied => ffi::NM_AGENT_MANAGER_ERROR_PERMISSION_DENIED,
            Self::InvalidIdentifier => ffi::NM_AGENT_MANAGER_ERROR_INVALID_IDENTIFIER,
            Self::NotRegistered => ffi::NM_AGENT_MANAGER_ERROR_NOT_REGISTERED,
            Self::NoSecrets => ffi::NM_AGENT_MANAGER_ERROR_NO_SECRETS,
            Self::UserCanceled => ffi::NM_AGENT_MANAGER_ERROR_USER_CANCELED,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMAgentManagerError> for AgentManagerError {
    #[inline]
    unsafe fn from_glib(value: ffi::NMAgentManagerError) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_AGENT_MANAGER_ERROR_FAILED => Self::Failed,
            ffi::NM_AGENT_MANAGER_ERROR_PERMISSION_DENIED => Self::PermissionDenied,
            ffi::NM_AGENT_MANAGER_ERROR_INVALID_IDENTIFIER => Self::InvalidIdentifier,
            ffi::NM_AGENT_MANAGER_ERROR_NOT_REGISTERED => Self::NotRegistered,
            ffi::NM_AGENT_MANAGER_ERROR_NO_SECRETS => Self::NoSecrets,
            ffi::NM_AGENT_MANAGER_ERROR_USER_CANCELED => Self::UserCanceled,
            value => Self::__Unknown(value),
        }
    }
}

impl glib::error::ErrorDomain for AgentManagerError {
    #[inline]
    fn domain() -> glib::Quark {
        skip_assert_initialized!();

        unsafe { from_glib(ffi::nm_agent_manager_error_quark()) }
    }

    #[inline]
    fn code(self) -> i32 {
        self.into_glib()
    }

    #[inline]
    #[allow(clippy::match_single_binding)]
    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match unsafe { from_glib(code) } {
            Self::__Unknown(_) => Some(Self::Failed),
            value => Some(value),
        }
    }
}

impl StaticType for AgentManagerError {
    #[inline]
    #[doc(alias = "nm_agent_manager_error_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_agent_manager_error_get_type()) }
    }
}

impl glib::HasParamSpec for AgentManagerError {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for AgentManagerError {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for AgentManagerError {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for AgentManagerError {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<AgentManagerError> for glib::Value {
    #[inline]
    fn from(v: AgentManagerError) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// #NMCapability names the numbers in the Capabilities property.
/// Capabilities are positive numbers. They are part of stable API
/// and a certain capability number is guaranteed not to change.
///
/// The range 0x7000 - 0x7FFF of capabilities is guaranteed not to be
/// used by upstream NetworkManager. It could thus be used for downstream
/// extensions.
#[cfg(feature = "v1_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMCapability")]
pub enum Capability {
    /// Teams can be managed. This means the team device plugin
    ///   is loaded.
    #[doc(alias = "NM_CAPABILITY_TEAM")]
    Team,
    /// OpenVSwitch can be managed. This means the OVS device plugin
    ///   is loaded. Since: 1.24.
    #[doc(alias = "NM_CAPABILITY_OVS")]
    Ovs,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v1_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
#[doc(hidden)]
impl IntoGlib for Capability {
    type GlibType = ffi::NMCapability;

    #[inline]
    fn into_glib(self) -> ffi::NMCapability {
        match self {
            Self::Team => ffi::NM_CAPABILITY_TEAM,
            Self::Ovs => ffi::NM_CAPABILITY_OVS,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v1_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
#[doc(hidden)]
impl FromGlib<ffi::NMCapability> for Capability {
    #[inline]
    unsafe fn from_glib(value: ffi::NMCapability) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_CAPABILITY_TEAM => Self::Team,
            ffi::NM_CAPABILITY_OVS => Self::Ovs,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v1_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
impl StaticType for Capability {
    #[inline]
    #[doc(alias = "nm_capability_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_capability_get_type()) }
    }
}

#[cfg(feature = "v1_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
impl glib::HasParamSpec for Capability {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v1_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
impl glib::value::ValueType for Capability {
    type Type = Self;
}

#[cfg(feature = "v1_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
unsafe impl<'a> glib::value::FromValue<'a> for Capability {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
impl ToValue for Capability {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
impl From<Capability> for glib::Value {
    #[inline]
    fn from(v: Capability) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// Describes errors that may result from operations involving a #NMClient.
///
/// D-Bus operations may also return errors from other domains, including
/// #NMManagerError, #NMSettingsError, #NMAgentManagerError, and #NMConnectionError.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMClientError")]
pub enum ClientError {
    /// unknown or unclassified error
    #[doc(alias = "NM_CLIENT_ERROR_FAILED")]
    Failed,
    /// an operation that requires NetworkManager
    ///   failed because NetworkManager is not running
    #[doc(alias = "NM_CLIENT_ERROR_MANAGER_NOT_RUNNING")]
    ManagerNotRunning,
    /// NetworkManager claimed that an
    ///   operation succeeded, but the object that was allegedly created (eg,
    ///   #NMRemoteConnection, #NMActiveConnection) was apparently destroyed before
    ///   #NMClient could create a representation of it.
    #[doc(alias = "NM_CLIENT_ERROR_OBJECT_CREATION_FAILED")]
    ObjectCreationFailed,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for ClientError {
    type GlibType = ffi::NMClientError;

    #[inline]
    fn into_glib(self) -> ffi::NMClientError {
        match self {
            Self::Failed => ffi::NM_CLIENT_ERROR_FAILED,
            Self::ManagerNotRunning => ffi::NM_CLIENT_ERROR_MANAGER_NOT_RUNNING,
            Self::ObjectCreationFailed => ffi::NM_CLIENT_ERROR_OBJECT_CREATION_FAILED,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMClientError> for ClientError {
    #[inline]
    unsafe fn from_glib(value: ffi::NMClientError) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_CLIENT_ERROR_FAILED => Self::Failed,
            ffi::NM_CLIENT_ERROR_MANAGER_NOT_RUNNING => Self::ManagerNotRunning,
            ffi::NM_CLIENT_ERROR_OBJECT_CREATION_FAILED => Self::ObjectCreationFailed,
            value => Self::__Unknown(value),
        }
    }
}

impl glib::error::ErrorDomain for ClientError {
    #[inline]
    fn domain() -> glib::Quark {
        skip_assert_initialized!();

        unsafe { from_glib(ffi::nm_client_error_quark()) }
    }

    #[inline]
    fn code(self) -> i32 {
        self.into_glib()
    }

    #[inline]
    #[allow(clippy::match_single_binding)]
    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match unsafe { from_glib(code) } {
            Self::__Unknown(_) => Some(Self::Failed),
            value => Some(value),
        }
    }
}

impl StaticType for ClientError {
    #[inline]
    #[doc(alias = "nm_client_error_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_client_error_get_type()) }
    }
}

impl glib::HasParamSpec for ClientError {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for ClientError {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for ClientError {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ClientError {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<ClientError> for glib::Value {
    #[inline]
    fn from(v: ClientError) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// #NMClientPermission values indicate various permissions that NetworkManager
/// clients can obtain to perform certain tasks on behalf of the current user.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMClientPermission")]
pub enum ClientPermission {
    /// unknown or no permission
    #[doc(alias = "NM_CLIENT_PERMISSION_NONE")]
    None,
    /// controls whether networking
    ///  can be globally enabled or disabled
    #[doc(alias = "NM_CLIENT_PERMISSION_ENABLE_DISABLE_NETWORK")]
    EnableDisableNetwork,
    /// controls whether Wi-Fi can be
    ///  globally enabled or disabled
    #[doc(alias = "NM_CLIENT_PERMISSION_ENABLE_DISABLE_WIFI")]
    EnableDisableWifi,
    /// controls whether WWAN (3G) can be
    ///  globally enabled or disabled
    #[doc(alias = "NM_CLIENT_PERMISSION_ENABLE_DISABLE_WWAN")]
    EnableDisableWwan,
    /// controls whether WiMAX can be
    ///  globally enabled or disabled
    #[doc(alias = "NM_CLIENT_PERMISSION_ENABLE_DISABLE_WIMAX")]
    EnableDisableWimax,
    /// controls whether the client can ask
    ///  NetworkManager to sleep and wake
    #[doc(alias = "NM_CLIENT_PERMISSION_SLEEP_WAKE")]
    SleepWake,
    /// controls whether networking connections
    ///  can be started, stopped, and changed
    #[doc(alias = "NM_CLIENT_PERMISSION_NETWORK_CONTROL")]
    NetworkControl,
    /// controls whether a password
    ///  protected Wi-Fi hotspot can be created
    #[doc(alias = "NM_CLIENT_PERMISSION_WIFI_SHARE_PROTECTED")]
    WifiShareProtected,
    /// controls whether an open Wi-Fi hotspot
    ///  can be created
    #[doc(alias = "NM_CLIENT_PERMISSION_WIFI_SHARE_OPEN")]
    WifiShareOpen,
    /// controls whether connections
    ///  that are available to all users can be modified
    #[doc(alias = "NM_CLIENT_PERMISSION_SETTINGS_MODIFY_SYSTEM")]
    SettingsModifySystem,
    /// controls whether connections
    ///  owned by the current user can be modified
    #[doc(alias = "NM_CLIENT_PERMISSION_SETTINGS_MODIFY_OWN")]
    SettingsModifyOwn,
    /// controls whether the
    ///  persistent hostname can be changed
    #[doc(alias = "NM_CLIENT_PERMISSION_SETTINGS_MODIFY_HOSTNAME")]
    SettingsModifyHostname,
    /// modify persistent global
    ///  DNS configuration
    #[doc(alias = "NM_CLIENT_PERMISSION_SETTINGS_MODIFY_GLOBAL_DNS")]
    SettingsModifyGlobalDns,
    /// controls access to Reload.
    #[doc(alias = "NM_CLIENT_PERMISSION_RELOAD")]
    Reload,
    /// permission to create checkpoints.
    #[doc(alias = "NM_CLIENT_PERMISSION_CHECKPOINT_ROLLBACK")]
    CheckpointRollback,
    /// controls whether device
    ///  statistics can be globally enabled or disabled
    #[doc(alias = "NM_CLIENT_PERMISSION_ENABLE_DISABLE_STATISTICS")]
    EnableDisableStatistics,
    /// controls whether
    ///  connectivity check can be enabled or disabled
    #[doc(alias = "NM_CLIENT_PERMISSION_ENABLE_DISABLE_CONNECTIVITY_CHECK")]
    EnableDisableConnectivityCheck,
    /// controls whether wifi scans can be performed
    #[doc(alias = "NM_CLIENT_PERMISSION_WIFI_SCAN")]
    WifiScan,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for ClientPermission {
    type GlibType = ffi::NMClientPermission;

    fn into_glib(self) -> ffi::NMClientPermission {
        match self {
            Self::None => ffi::NM_CLIENT_PERMISSION_NONE,
            Self::EnableDisableNetwork => ffi::NM_CLIENT_PERMISSION_ENABLE_DISABLE_NETWORK,
            Self::EnableDisableWifi => ffi::NM_CLIENT_PERMISSION_ENABLE_DISABLE_WIFI,
            Self::EnableDisableWwan => ffi::NM_CLIENT_PERMISSION_ENABLE_DISABLE_WWAN,
            Self::EnableDisableWimax => ffi::NM_CLIENT_PERMISSION_ENABLE_DISABLE_WIMAX,
            Self::SleepWake => ffi::NM_CLIENT_PERMISSION_SLEEP_WAKE,
            Self::NetworkControl => ffi::NM_CLIENT_PERMISSION_NETWORK_CONTROL,
            Self::WifiShareProtected => ffi::NM_CLIENT_PERMISSION_WIFI_SHARE_PROTECTED,
            Self::WifiShareOpen => ffi::NM_CLIENT_PERMISSION_WIFI_SHARE_OPEN,
            Self::SettingsModifySystem => ffi::NM_CLIENT_PERMISSION_SETTINGS_MODIFY_SYSTEM,
            Self::SettingsModifyOwn => ffi::NM_CLIENT_PERMISSION_SETTINGS_MODIFY_OWN,
            Self::SettingsModifyHostname => ffi::NM_CLIENT_PERMISSION_SETTINGS_MODIFY_HOSTNAME,
            Self::SettingsModifyGlobalDns => ffi::NM_CLIENT_PERMISSION_SETTINGS_MODIFY_GLOBAL_DNS,
            Self::Reload => ffi::NM_CLIENT_PERMISSION_RELOAD,
            Self::CheckpointRollback => ffi::NM_CLIENT_PERMISSION_CHECKPOINT_ROLLBACK,
            Self::EnableDisableStatistics => ffi::NM_CLIENT_PERMISSION_ENABLE_DISABLE_STATISTICS,
            Self::EnableDisableConnectivityCheck => {
                ffi::NM_CLIENT_PERMISSION_ENABLE_DISABLE_CONNECTIVITY_CHECK
            }
            Self::WifiScan => ffi::NM_CLIENT_PERMISSION_WIFI_SCAN,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMClientPermission> for ClientPermission {
    unsafe fn from_glib(value: ffi::NMClientPermission) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_CLIENT_PERMISSION_NONE => Self::None,
            ffi::NM_CLIENT_PERMISSION_ENABLE_DISABLE_NETWORK => Self::EnableDisableNetwork,
            ffi::NM_CLIENT_PERMISSION_ENABLE_DISABLE_WIFI => Self::EnableDisableWifi,
            ffi::NM_CLIENT_PERMISSION_ENABLE_DISABLE_WWAN => Self::EnableDisableWwan,
            ffi::NM_CLIENT_PERMISSION_ENABLE_DISABLE_WIMAX => Self::EnableDisableWimax,
            ffi::NM_CLIENT_PERMISSION_SLEEP_WAKE => Self::SleepWake,
            ffi::NM_CLIENT_PERMISSION_NETWORK_CONTROL => Self::NetworkControl,
            ffi::NM_CLIENT_PERMISSION_WIFI_SHARE_PROTECTED => Self::WifiShareProtected,
            ffi::NM_CLIENT_PERMISSION_WIFI_SHARE_OPEN => Self::WifiShareOpen,
            ffi::NM_CLIENT_PERMISSION_SETTINGS_MODIFY_SYSTEM => Self::SettingsModifySystem,
            ffi::NM_CLIENT_PERMISSION_SETTINGS_MODIFY_OWN => Self::SettingsModifyOwn,
            ffi::NM_CLIENT_PERMISSION_SETTINGS_MODIFY_HOSTNAME => Self::SettingsModifyHostname,
            ffi::NM_CLIENT_PERMISSION_SETTINGS_MODIFY_GLOBAL_DNS => Self::SettingsModifyGlobalDns,
            ffi::NM_CLIENT_PERMISSION_RELOAD => Self::Reload,
            ffi::NM_CLIENT_PERMISSION_CHECKPOINT_ROLLBACK => Self::CheckpointRollback,
            ffi::NM_CLIENT_PERMISSION_ENABLE_DISABLE_STATISTICS => Self::EnableDisableStatistics,
            ffi::NM_CLIENT_PERMISSION_ENABLE_DISABLE_CONNECTIVITY_CHECK => {
                Self::EnableDisableConnectivityCheck
            }
            ffi::NM_CLIENT_PERMISSION_WIFI_SCAN => Self::WifiScan,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for ClientPermission {
    #[inline]
    #[doc(alias = "nm_client_permission_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_client_permission_get_type()) }
    }
}

impl glib::HasParamSpec for ClientPermission {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for ClientPermission {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for ClientPermission {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ClientPermission {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<ClientPermission> for glib::Value {
    #[inline]
    fn from(v: ClientPermission) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// #NMClientPermissionResult values indicate what authorizations and permissions
/// the user requires to obtain a given #NMClientPermission
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMClientPermissionResult")]
pub enum ClientPermissionResult {
    /// unknown or no authorization
    #[doc(alias = "NM_CLIENT_PERMISSION_RESULT_UNKNOWN")]
    Unknown,
    /// the permission is available
    #[doc(alias = "NM_CLIENT_PERMISSION_RESULT_YES")]
    Yes,
    /// authorization is necessary before the
    ///  permission is available
    #[doc(alias = "NM_CLIENT_PERMISSION_RESULT_AUTH")]
    Auth,
    /// permission to perform the operation is
    ///  denied by system policy
    #[doc(alias = "NM_CLIENT_PERMISSION_RESULT_NO")]
    No,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for ClientPermissionResult {
    type GlibType = ffi::NMClientPermissionResult;

    #[inline]
    fn into_glib(self) -> ffi::NMClientPermissionResult {
        match self {
            Self::Unknown => ffi::NM_CLIENT_PERMISSION_RESULT_UNKNOWN,
            Self::Yes => ffi::NM_CLIENT_PERMISSION_RESULT_YES,
            Self::Auth => ffi::NM_CLIENT_PERMISSION_RESULT_AUTH,
            Self::No => ffi::NM_CLIENT_PERMISSION_RESULT_NO,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMClientPermissionResult> for ClientPermissionResult {
    #[inline]
    unsafe fn from_glib(value: ffi::NMClientPermissionResult) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_CLIENT_PERMISSION_RESULT_UNKNOWN => Self::Unknown,
            ffi::NM_CLIENT_PERMISSION_RESULT_YES => Self::Yes,
            ffi::NM_CLIENT_PERMISSION_RESULT_AUTH => Self::Auth,
            ffi::NM_CLIENT_PERMISSION_RESULT_NO => Self::No,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for ClientPermissionResult {
    #[inline]
    #[doc(alias = "nm_client_permission_result_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_client_permission_result_get_type()) }
    }
}

impl glib::HasParamSpec for ClientPermissionResult {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for ClientPermissionResult {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for ClientPermissionResult {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ClientPermissionResult {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<ClientPermissionResult> for glib::Value {
    #[inline]
    fn from(v: ClientPermissionResult) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// Describes errors that may result from operations involving a #NMConnection
/// or its #NMSettings.
///
/// These errors may be returned directly from #NMConnection and #NMSetting
/// methods, or may be returned from D-Bus operations (eg on #NMClient or
/// #NMDevice), where they correspond to errors in the
/// "org.freedesktop.NetworkManager.Settings.Connection" namespace.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMConnectionError")]
pub enum ConnectionError {
    /// unknown or unclassified error
    #[doc(alias = "NM_CONNECTION_ERROR_FAILED")]
    Failed,
    /// the #NMConnection object
    ///   did not contain the specified #NMSetting object
    #[doc(alias = "NM_CONNECTION_ERROR_SETTING_NOT_FOUND")]
    SettingNotFound,
    /// the #NMConnection did not contain the
    ///   requested #NMSetting property
    #[doc(alias = "NM_CONNECTION_ERROR_PROPERTY_NOT_FOUND")]
    PropertyNotFound,
    /// an operation which requires a secret
    ///   was attempted on a non-secret property
    #[doc(alias = "NM_CONNECTION_ERROR_PROPERTY_NOT_SECRET")]
    PropertyNotSecret,
    /// the #NMConnection object is missing an
    ///   #NMSetting which is required for its configuration. The error message will
    ///   always be prefixed with "&lt;setting-name>: ", where "&lt;setting-name>" is the
    ///   name of the setting that is missing.
    #[doc(alias = "NM_CONNECTION_ERROR_MISSING_SETTING")]
    MissingSetting,
    /// the #NMConnection object contains an
    ///   invalid or inappropriate #NMSetting. The error message will always be
    ///   prefixed with "&lt;setting-name>: ", where "&lt;setting-name>" is the name of the
    ///   setting that is invalid.
    #[doc(alias = "NM_CONNECTION_ERROR_INVALID_SETTING")]
    InvalidSetting,
    /// the #NMConnection object is invalid
    ///   because it is missing a required property. The error message will always be
    ///   prefixed with "&lt;setting-name>.&lt;property-name>: ", where "&lt;setting-name>" is
    ///   the name of the setting with the missing property, and "&lt;property-name>" is
    ///   the property that is missing.
    #[doc(alias = "NM_CONNECTION_ERROR_MISSING_PROPERTY")]
    MissingProperty,
    /// the #NMConnection object is invalid
    ///   because a property has an invalid value. The error message will always be
    ///   prefixed with "&lt;setting-name>.&lt;property-name>: ", where "&lt;setting-name>" is
    ///   the name of the setting with the invalid property, and "&lt;property-name>" is
    ///   the property that is invalid.
    #[doc(alias = "NM_CONNECTION_ERROR_INVALID_PROPERTY")]
    InvalidProperty,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for ConnectionError {
    type GlibType = ffi::NMConnectionError;

    #[inline]
    fn into_glib(self) -> ffi::NMConnectionError {
        match self {
            Self::Failed => ffi::NM_CONNECTION_ERROR_FAILED,
            Self::SettingNotFound => ffi::NM_CONNECTION_ERROR_SETTING_NOT_FOUND,
            Self::PropertyNotFound => ffi::NM_CONNECTION_ERROR_PROPERTY_NOT_FOUND,
            Self::PropertyNotSecret => ffi::NM_CONNECTION_ERROR_PROPERTY_NOT_SECRET,
            Self::MissingSetting => ffi::NM_CONNECTION_ERROR_MISSING_SETTING,
            Self::InvalidSetting => ffi::NM_CONNECTION_ERROR_INVALID_SETTING,
            Self::MissingProperty => ffi::NM_CONNECTION_ERROR_MISSING_PROPERTY,
            Self::InvalidProperty => ffi::NM_CONNECTION_ERROR_INVALID_PROPERTY,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMConnectionError> for ConnectionError {
    #[inline]
    unsafe fn from_glib(value: ffi::NMConnectionError) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_CONNECTION_ERROR_FAILED => Self::Failed,
            ffi::NM_CONNECTION_ERROR_SETTING_NOT_FOUND => Self::SettingNotFound,
            ffi::NM_CONNECTION_ERROR_PROPERTY_NOT_FOUND => Self::PropertyNotFound,
            ffi::NM_CONNECTION_ERROR_PROPERTY_NOT_SECRET => Self::PropertyNotSecret,
            ffi::NM_CONNECTION_ERROR_MISSING_SETTING => Self::MissingSetting,
            ffi::NM_CONNECTION_ERROR_INVALID_SETTING => Self::InvalidSetting,
            ffi::NM_CONNECTION_ERROR_MISSING_PROPERTY => Self::MissingProperty,
            ffi::NM_CONNECTION_ERROR_INVALID_PROPERTY => Self::InvalidProperty,
            value => Self::__Unknown(value),
        }
    }
}

impl glib::error::ErrorDomain for ConnectionError {
    #[inline]
    fn domain() -> glib::Quark {
        skip_assert_initialized!();

        unsafe { from_glib(ffi::nm_connection_error_quark()) }
    }

    #[inline]
    fn code(self) -> i32 {
        self.into_glib()
    }

    #[inline]
    #[allow(clippy::match_single_binding)]
    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match unsafe { from_glib(code) } {
            Self::__Unknown(_) => Some(Self::Failed),
            value => Some(value),
        }
    }
}

impl StaticType for ConnectionError {
    #[inline]
    #[doc(alias = "nm_connection_error_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_connection_error_get_type()) }
    }
}

impl glib::HasParamSpec for ConnectionError {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for ConnectionError {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for ConnectionError {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ConnectionError {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<ConnectionError> for glib::Value {
    #[inline]
    fn from(v: ConnectionError) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v1_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMConnectionMultiConnect")]
pub enum ConnectionMultiConnect {
    /// indicates that the per-connection
    ///   setting is unspecified. In this case, it will fallback to the default
    ///   value, which is [`Single`][Self::Single].
    #[doc(alias = "NM_CONNECTION_MULTI_CONNECT_DEFAULT")]
    Default,
    /// the connection profile can only
    ///   be active once at each moment. Activating a profile that is already active,
    ///   will first deactivate it.
    #[doc(alias = "NM_CONNECTION_MULTI_CONNECT_SINGLE")]
    Single,
    /// the profile can
    ///   be manually activated multiple times on different devices. However,
    ///   regarding autoconnect, the profile will autoconnect only if it is
    ///   currently not connected otherwise.
    #[doc(alias = "NM_CONNECTION_MULTI_CONNECT_MANUAL_MULTIPLE")]
    ManualMultiple,
    /// the profile can autoactivate
    ///   and be manually activated multiple times together.
    #[doc(alias = "NM_CONNECTION_MULTI_CONNECT_MULTIPLE")]
    Multiple,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v1_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
#[doc(hidden)]
impl IntoGlib for ConnectionMultiConnect {
    type GlibType = ffi::NMConnectionMultiConnect;

    #[inline]
    fn into_glib(self) -> ffi::NMConnectionMultiConnect {
        match self {
            Self::Default => ffi::NM_CONNECTION_MULTI_CONNECT_DEFAULT,
            Self::Single => ffi::NM_CONNECTION_MULTI_CONNECT_SINGLE,
            Self::ManualMultiple => ffi::NM_CONNECTION_MULTI_CONNECT_MANUAL_MULTIPLE,
            Self::Multiple => ffi::NM_CONNECTION_MULTI_CONNECT_MULTIPLE,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v1_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
#[doc(hidden)]
impl FromGlib<ffi::NMConnectionMultiConnect> for ConnectionMultiConnect {
    #[inline]
    unsafe fn from_glib(value: ffi::NMConnectionMultiConnect) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_CONNECTION_MULTI_CONNECT_DEFAULT => Self::Default,
            ffi::NM_CONNECTION_MULTI_CONNECT_SINGLE => Self::Single,
            ffi::NM_CONNECTION_MULTI_CONNECT_MANUAL_MULTIPLE => Self::ManualMultiple,
            ffi::NM_CONNECTION_MULTI_CONNECT_MULTIPLE => Self::Multiple,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v1_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
impl StaticType for ConnectionMultiConnect {
    #[inline]
    #[doc(alias = "nm_connection_multi_connect_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_connection_multi_connect_get_type()) }
    }
}

#[cfg(feature = "v1_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
impl glib::HasParamSpec for ConnectionMultiConnect {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v1_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
impl glib::value::ValueType for ConnectionMultiConnect {
    type Type = Self;
}

#[cfg(feature = "v1_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
unsafe impl<'a> glib::value::FromValue<'a> for ConnectionMultiConnect {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
impl ToValue for ConnectionMultiConnect {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
impl From<ConnectionMultiConnect> for glib::Value {
    #[inline]
    fn from(v: ConnectionMultiConnect) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMConnectivityState")]
pub enum ConnectivityState {
    /// Network connectivity is unknown. This means the
    ///   connectivity checks are disabled (e.g. on server installations) or has
    ///   not run yet. The graphical shell should assume the Internet connection
    ///   might be available and not present a captive portal window.
    #[doc(alias = "NM_CONNECTIVITY_UNKNOWN")]
    Unknown,
    /// The host is not connected to any network. There's
    ///   no active connection that contains a default route to the internet and
    ///   thus it makes no sense to even attempt a connectivity check. The graphical
    ///   shell should use this state to indicate the network connection is unavailable.
    #[doc(alias = "NM_CONNECTIVITY_NONE")]
    None,
    /// The Internet connection is hijacked by a captive
    ///   portal gateway. The graphical shell may open a sandboxed web browser window
    ///   (because the captive portals typically attempt a man-in-the-middle attacks
    ///   against the https connections) for the purpose of authenticating to a gateway
    ///   and retrigger the connectivity check with CheckConnectivity() when the
    ///   browser window is dismissed.
    #[doc(alias = "NM_CONNECTIVITY_PORTAL")]
    Portal,
    /// The host is connected to a network, does not appear
    ///   to be able to reach the full Internet, but a captive portal has not been
    ///   detected.
    #[doc(alias = "NM_CONNECTIVITY_LIMITED")]
    Limited,
    /// The host is connected to a network, and
    ///   appears to be able to reach the full Internet.
    #[doc(alias = "NM_CONNECTIVITY_FULL")]
    Full,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for ConnectivityState {
    type GlibType = ffi::NMConnectivityState;

    #[inline]
    fn into_glib(self) -> ffi::NMConnectivityState {
        match self {
            Self::Unknown => ffi::NM_CONNECTIVITY_UNKNOWN,
            Self::None => ffi::NM_CONNECTIVITY_NONE,
            Self::Portal => ffi::NM_CONNECTIVITY_PORTAL,
            Self::Limited => ffi::NM_CONNECTIVITY_LIMITED,
            Self::Full => ffi::NM_CONNECTIVITY_FULL,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMConnectivityState> for ConnectivityState {
    #[inline]
    unsafe fn from_glib(value: ffi::NMConnectivityState) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_CONNECTIVITY_UNKNOWN => Self::Unknown,
            ffi::NM_CONNECTIVITY_NONE => Self::None,
            ffi::NM_CONNECTIVITY_PORTAL => Self::Portal,
            ffi::NM_CONNECTIVITY_LIMITED => Self::Limited,
            ffi::NM_CONNECTIVITY_FULL => Self::Full,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for ConnectivityState {
    #[inline]
    #[doc(alias = "nm_connectivity_state_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_connectivity_state_get_type()) }
    }
}

impl glib::HasParamSpec for ConnectivityState {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for ConnectivityState {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for ConnectivityState {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ConnectivityState {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<ConnectivityState> for glib::Value {
    #[inline]
    fn from(v: ConnectivityState) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// Cryptography-related errors that can be returned from some nm-utils methods,
/// and some #NMSetting8021x operations.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMCryptoError")]
pub enum CryptoError {
    /// generic failure
    #[doc(alias = "NM_CRYPTO_ERROR_FAILED")]
    Failed,
    /// the certificate or key data provided
    ///   was invalid
    #[doc(alias = "NM_CRYPTO_ERROR_INVALID_DATA")]
    InvalidData,
    /// the password was invalid
    #[doc(alias = "NM_CRYPTO_ERROR_INVALID_PASSWORD")]
    InvalidPassword,
    /// the data uses an unknown cipher
    #[doc(alias = "NM_CRYPTO_ERROR_UNKNOWN_CIPHER")]
    UnknownCipher,
    /// decryption failed
    #[doc(alias = "NM_CRYPTO_ERROR_DECRYPTION_FAILED")]
    DecryptionFailed,
    /// encryption failed
    #[doc(alias = "NM_CRYPTO_ERROR_ENCRYPTION_FAILED")]
    EncryptionFailed,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for CryptoError {
    type GlibType = ffi::NMCryptoError;

    #[inline]
    fn into_glib(self) -> ffi::NMCryptoError {
        match self {
            Self::Failed => ffi::NM_CRYPTO_ERROR_FAILED,
            Self::InvalidData => ffi::NM_CRYPTO_ERROR_INVALID_DATA,
            Self::InvalidPassword => ffi::NM_CRYPTO_ERROR_INVALID_PASSWORD,
            Self::UnknownCipher => ffi::NM_CRYPTO_ERROR_UNKNOWN_CIPHER,
            Self::DecryptionFailed => ffi::NM_CRYPTO_ERROR_DECRYPTION_FAILED,
            Self::EncryptionFailed => ffi::NM_CRYPTO_ERROR_ENCRYPTION_FAILED,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMCryptoError> for CryptoError {
    #[inline]
    unsafe fn from_glib(value: ffi::NMCryptoError) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_CRYPTO_ERROR_FAILED => Self::Failed,
            ffi::NM_CRYPTO_ERROR_INVALID_DATA => Self::InvalidData,
            ffi::NM_CRYPTO_ERROR_INVALID_PASSWORD => Self::InvalidPassword,
            ffi::NM_CRYPTO_ERROR_UNKNOWN_CIPHER => Self::UnknownCipher,
            ffi::NM_CRYPTO_ERROR_DECRYPTION_FAILED => Self::DecryptionFailed,
            ffi::NM_CRYPTO_ERROR_ENCRYPTION_FAILED => Self::EncryptionFailed,
            value => Self::__Unknown(value),
        }
    }
}

impl glib::error::ErrorDomain for CryptoError {
    #[inline]
    fn domain() -> glib::Quark {
        skip_assert_initialized!();

        unsafe { from_glib(ffi::nm_crypto_error_quark()) }
    }

    #[inline]
    fn code(self) -> i32 {
        self.into_glib()
    }

    #[inline]
    #[allow(clippy::match_single_binding)]
    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match unsafe { from_glib(code) } {
            Self::__Unknown(_) => Some(Self::Failed),
            value => Some(value),
        }
    }
}

impl StaticType for CryptoError {
    #[inline]
    #[doc(alias = "nm_crypto_error_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_crypto_error_get_type()) }
    }
}

impl glib::HasParamSpec for CryptoError {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for CryptoError {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for CryptoError {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for CryptoError {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<CryptoError> for glib::Value {
    #[inline]
    fn from(v: CryptoError) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// Device-related errors.
///
/// These errors may be returned directly from #NMDevice methods, or may be
/// returned from D-Bus operations (where they correspond to errors in the
/// "org.freedesktop.NetworkManager.Device" namespace).
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMDeviceError")]
pub enum DeviceError {
    /// unknown or unclassified error
    #[doc(alias = "NM_DEVICE_ERROR_FAILED")]
    Failed,
    /// NetworkManager failed to create the device
    #[doc(alias = "NM_DEVICE_ERROR_CREATION_FAILED")]
    CreationFailed,
    /// the specified connection is not valid
    #[doc(alias = "NM_DEVICE_ERROR_INVALID_CONNECTION")]
    InvalidConnection,
    /// the specified connection is not
    ///   compatible with this device.
    #[doc(alias = "NM_DEVICE_ERROR_INCOMPATIBLE_CONNECTION")]
    IncompatibleConnection,
    /// the device does not have an active connection
    #[doc(alias = "NM_DEVICE_ERROR_NOT_ACTIVE")]
    NotActive,
    /// the requested operation is only valid on
    ///   software devices.
    #[doc(alias = "NM_DEVICE_ERROR_NOT_SOFTWARE")]
    NotSoftware,
    /// the requested operation is not allowed at
    ///   this time.
    #[doc(alias = "NM_DEVICE_ERROR_NOT_ALLOWED")]
    NotAllowed,
    /// the "specific object" in the
    ///   activation request (eg, the #NMAccessPoint or #NMWimaxNsp) was not
    ///   found.
    #[doc(alias = "NM_DEVICE_ERROR_SPECIFIC_OBJECT_NOT_FOUND")]
    SpecificObjectNotFound,
    /// the version id did not match.
    #[doc(alias = "NM_DEVICE_ERROR_VERSION_ID_MISMATCH")]
    VersionIdMismatch,
    /// the requested operation could not
    ///   be completed due to missing dependencies.
    #[doc(alias = "NM_DEVICE_ERROR_MISSING_DEPENDENCIES")]
    MissingDependencies,
    /// invalid argument. Since: 1.16.
    #[doc(alias = "NM_DEVICE_ERROR_INVALID_ARGUMENT")]
    InvalidArgument,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for DeviceError {
    type GlibType = ffi::NMDeviceError;

    #[inline]
    fn into_glib(self) -> ffi::NMDeviceError {
        match self {
            Self::Failed => ffi::NM_DEVICE_ERROR_FAILED,
            Self::CreationFailed => ffi::NM_DEVICE_ERROR_CREATION_FAILED,
            Self::InvalidConnection => ffi::NM_DEVICE_ERROR_INVALID_CONNECTION,
            Self::IncompatibleConnection => ffi::NM_DEVICE_ERROR_INCOMPATIBLE_CONNECTION,
            Self::NotActive => ffi::NM_DEVICE_ERROR_NOT_ACTIVE,
            Self::NotSoftware => ffi::NM_DEVICE_ERROR_NOT_SOFTWARE,
            Self::NotAllowed => ffi::NM_DEVICE_ERROR_NOT_ALLOWED,
            Self::SpecificObjectNotFound => ffi::NM_DEVICE_ERROR_SPECIFIC_OBJECT_NOT_FOUND,
            Self::VersionIdMismatch => ffi::NM_DEVICE_ERROR_VERSION_ID_MISMATCH,
            Self::MissingDependencies => ffi::NM_DEVICE_ERROR_MISSING_DEPENDENCIES,
            Self::InvalidArgument => ffi::NM_DEVICE_ERROR_INVALID_ARGUMENT,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMDeviceError> for DeviceError {
    #[inline]
    unsafe fn from_glib(value: ffi::NMDeviceError) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_DEVICE_ERROR_FAILED => Self::Failed,
            ffi::NM_DEVICE_ERROR_CREATION_FAILED => Self::CreationFailed,
            ffi::NM_DEVICE_ERROR_INVALID_CONNECTION => Self::InvalidConnection,
            ffi::NM_DEVICE_ERROR_INCOMPATIBLE_CONNECTION => Self::IncompatibleConnection,
            ffi::NM_DEVICE_ERROR_NOT_ACTIVE => Self::NotActive,
            ffi::NM_DEVICE_ERROR_NOT_SOFTWARE => Self::NotSoftware,
            ffi::NM_DEVICE_ERROR_NOT_ALLOWED => Self::NotAllowed,
            ffi::NM_DEVICE_ERROR_SPECIFIC_OBJECT_NOT_FOUND => Self::SpecificObjectNotFound,
            ffi::NM_DEVICE_ERROR_VERSION_ID_MISMATCH => Self::VersionIdMismatch,
            ffi::NM_DEVICE_ERROR_MISSING_DEPENDENCIES => Self::MissingDependencies,
            ffi::NM_DEVICE_ERROR_INVALID_ARGUMENT => Self::InvalidArgument,
            value => Self::__Unknown(value),
        }
    }
}

impl glib::error::ErrorDomain for DeviceError {
    #[inline]
    fn domain() -> glib::Quark {
        skip_assert_initialized!();

        unsafe { from_glib(ffi::nm_device_error_quark()) }
    }

    #[inline]
    fn code(self) -> i32 {
        self.into_glib()
    }

    #[inline]
    #[allow(clippy::match_single_binding)]
    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match unsafe { from_glib(code) } {
            Self::__Unknown(_) => Some(Self::Failed),
            value => Some(value),
        }
    }
}

impl StaticType for DeviceError {
    #[inline]
    #[doc(alias = "nm_device_error_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_device_error_get_type()) }
    }
}

impl glib::HasParamSpec for DeviceError {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for DeviceError {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for DeviceError {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for DeviceError {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<DeviceError> for glib::Value {
    #[inline]
    fn from(v: DeviceError) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMDeviceState")]
pub enum DeviceState {
    /// the device's state is unknown
    #[doc(alias = "NM_DEVICE_STATE_UNKNOWN")]
    Unknown,
    /// the device is recognized, but not managed by
    ///   NetworkManager
    #[doc(alias = "NM_DEVICE_STATE_UNMANAGED")]
    Unmanaged,
    /// the device is managed by NetworkManager, but
    ///   is not available for use.  Reasons may include the wireless switched off,
    ///   missing firmware, no ethernet carrier, missing supplicant or modem manager,
    ///   etc.
    #[doc(alias = "NM_DEVICE_STATE_UNAVAILABLE")]
    Unavailable,
    /// the device can be activated, but is currently
    ///   idle and not connected to a network.
    #[doc(alias = "NM_DEVICE_STATE_DISCONNECTED")]
    Disconnected,
    /// the device is preparing the connection to the
    ///   network.  This may include operations like changing the MAC address,
    ///   setting physical link properties, and anything else required to connect
    ///   to the requested network.
    #[doc(alias = "NM_DEVICE_STATE_PREPARE")]
    Prepare,
    /// the device is connecting to the requested network.
    ///   This may include operations like associating with the Wi-Fi AP, dialing
    ///   the modem, connecting to the remote Bluetooth device, etc.
    #[doc(alias = "NM_DEVICE_STATE_CONFIG")]
    Config,
    /// the device requires more information to continue
    ///   connecting to the requested network.  This includes secrets like WiFi
    ///   passphrases, login passwords, PIN codes, etc.
    #[doc(alias = "NM_DEVICE_STATE_NEED_AUTH")]
    NeedAuth,
    /// the device is requesting IPv4 and/or IPv6
    ///   addresses and routing information from the network.
    #[doc(alias = "NM_DEVICE_STATE_IP_CONFIG")]
    IpConfig,
    /// the device is checking whether further action is
    ///   required for the requested network connection.  This may include checking
    ///   whether only local network access is available, whether a captive portal
    ///   is blocking access to the Internet, etc.
    #[doc(alias = "NM_DEVICE_STATE_IP_CHECK")]
    IpCheck,
    /// the device is waiting for a secondary
    ///   connection (like a VPN) which must activated before the device can be
    ///   activated
    #[doc(alias = "NM_DEVICE_STATE_SECONDARIES")]
    Secondaries,
    /// the device has a network connection, either local
    ///   or global.
    #[doc(alias = "NM_DEVICE_STATE_ACTIVATED")]
    Activated,
    /// a disconnection from the current network
    ///   connection was requested, and the device is cleaning up resources used for
    ///   that connection.  The network connection may still be valid.
    #[doc(alias = "NM_DEVICE_STATE_DEACTIVATING")]
    Deactivating,
    /// the device failed to connect to the requested
    ///   network and is cleaning up the connection request
    #[doc(alias = "NM_DEVICE_STATE_FAILED")]
    Failed,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for DeviceState {
    type GlibType = ffi::NMDeviceState;

    fn into_glib(self) -> ffi::NMDeviceState {
        match self {
            Self::Unknown => ffi::NM_DEVICE_STATE_UNKNOWN,
            Self::Unmanaged => ffi::NM_DEVICE_STATE_UNMANAGED,
            Self::Unavailable => ffi::NM_DEVICE_STATE_UNAVAILABLE,
            Self::Disconnected => ffi::NM_DEVICE_STATE_DISCONNECTED,
            Self::Prepare => ffi::NM_DEVICE_STATE_PREPARE,
            Self::Config => ffi::NM_DEVICE_STATE_CONFIG,
            Self::NeedAuth => ffi::NM_DEVICE_STATE_NEED_AUTH,
            Self::IpConfig => ffi::NM_DEVICE_STATE_IP_CONFIG,
            Self::IpCheck => ffi::NM_DEVICE_STATE_IP_CHECK,
            Self::Secondaries => ffi::NM_DEVICE_STATE_SECONDARIES,
            Self::Activated => ffi::NM_DEVICE_STATE_ACTIVATED,
            Self::Deactivating => ffi::NM_DEVICE_STATE_DEACTIVATING,
            Self::Failed => ffi::NM_DEVICE_STATE_FAILED,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMDeviceState> for DeviceState {
    unsafe fn from_glib(value: ffi::NMDeviceState) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_DEVICE_STATE_UNKNOWN => Self::Unknown,
            ffi::NM_DEVICE_STATE_UNMANAGED => Self::Unmanaged,
            ffi::NM_DEVICE_STATE_UNAVAILABLE => Self::Unavailable,
            ffi::NM_DEVICE_STATE_DISCONNECTED => Self::Disconnected,
            ffi::NM_DEVICE_STATE_PREPARE => Self::Prepare,
            ffi::NM_DEVICE_STATE_CONFIG => Self::Config,
            ffi::NM_DEVICE_STATE_NEED_AUTH => Self::NeedAuth,
            ffi::NM_DEVICE_STATE_IP_CONFIG => Self::IpConfig,
            ffi::NM_DEVICE_STATE_IP_CHECK => Self::IpCheck,
            ffi::NM_DEVICE_STATE_SECONDARIES => Self::Secondaries,
            ffi::NM_DEVICE_STATE_ACTIVATED => Self::Activated,
            ffi::NM_DEVICE_STATE_DEACTIVATING => Self::Deactivating,
            ffi::NM_DEVICE_STATE_FAILED => Self::Failed,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for DeviceState {
    #[inline]
    #[doc(alias = "nm_device_state_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_device_state_get_type()) }
    }
}

impl glib::HasParamSpec for DeviceState {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for DeviceState {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for DeviceState {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for DeviceState {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<DeviceState> for glib::Value {
    #[inline]
    fn from(v: DeviceState) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// Device state change reason codes
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMDeviceStateReason")]
pub enum DeviceStateReason {
    /// No reason given
    #[doc(alias = "NM_DEVICE_STATE_REASON_NONE")]
    None,
    /// Unknown error
    #[doc(alias = "NM_DEVICE_STATE_REASON_UNKNOWN")]
    Unknown,
    /// Device is now managed
    #[doc(alias = "NM_DEVICE_STATE_REASON_NOW_MANAGED")]
    NowManaged,
    /// Device is now unmanaged
    #[doc(alias = "NM_DEVICE_STATE_REASON_NOW_UNMANAGED")]
    NowUnmanaged,
    /// The device could not be readied for configuration
    #[doc(alias = "NM_DEVICE_STATE_REASON_CONFIG_FAILED")]
    ConfigFailed,
    /// IP configuration could not be reserved (no available address, timeout, etc)
    #[doc(alias = "NM_DEVICE_STATE_REASON_IP_CONFIG_UNAVAILABLE")]
    IpConfigUnavailable,
    /// The IP config is no longer valid
    #[doc(alias = "NM_DEVICE_STATE_REASON_IP_CONFIG_EXPIRED")]
    IpConfigExpired,
    /// Secrets were required, but not provided
    #[doc(alias = "NM_DEVICE_STATE_REASON_NO_SECRETS")]
    NoSecrets,
    /// 802.1x supplicant disconnected
    #[doc(alias = "NM_DEVICE_STATE_REASON_SUPPLICANT_DISCONNECT")]
    SupplicantDisconnect,
    /// 802.1x supplicant configuration failed
    #[doc(alias = "NM_DEVICE_STATE_REASON_SUPPLICANT_CONFIG_FAILED")]
    SupplicantConfigFailed,
    /// 802.1x supplicant failed
    #[doc(alias = "NM_DEVICE_STATE_REASON_SUPPLICANT_FAILED")]
    SupplicantFailed,
    /// 802.1x supplicant took too long to authenticate
    #[doc(alias = "NM_DEVICE_STATE_REASON_SUPPLICANT_TIMEOUT")]
    SupplicantTimeout,
    /// PPP service failed to start
    #[doc(alias = "NM_DEVICE_STATE_REASON_PPP_START_FAILED")]
    PppStartFailed,
    /// PPP service disconnected
    #[doc(alias = "NM_DEVICE_STATE_REASON_PPP_DISCONNECT")]
    PppDisconnect,
    /// PPP failed
    #[doc(alias = "NM_DEVICE_STATE_REASON_PPP_FAILED")]
    PppFailed,
    /// DHCP client failed to start
    #[doc(alias = "NM_DEVICE_STATE_REASON_DHCP_START_FAILED")]
    DhcpStartFailed,
    /// DHCP client error
    #[doc(alias = "NM_DEVICE_STATE_REASON_DHCP_ERROR")]
    DhcpError,
    /// DHCP client failed
    #[doc(alias = "NM_DEVICE_STATE_REASON_DHCP_FAILED")]
    DhcpFailed,
    /// Shared connection service failed to start
    #[doc(alias = "NM_DEVICE_STATE_REASON_SHARED_START_FAILED")]
    SharedStartFailed,
    /// Shared connection service failed
    #[doc(alias = "NM_DEVICE_STATE_REASON_SHARED_FAILED")]
    SharedFailed,
    /// AutoIP service failed to start
    #[doc(alias = "NM_DEVICE_STATE_REASON_AUTOIP_START_FAILED")]
    AutoipStartFailed,
    /// AutoIP service error
    #[doc(alias = "NM_DEVICE_STATE_REASON_AUTOIP_ERROR")]
    AutoipError,
    /// AutoIP service failed
    #[doc(alias = "NM_DEVICE_STATE_REASON_AUTOIP_FAILED")]
    AutoipFailed,
    /// The line is busy
    #[doc(alias = "NM_DEVICE_STATE_REASON_MODEM_BUSY")]
    ModemBusy,
    /// No dial tone
    #[doc(alias = "NM_DEVICE_STATE_REASON_MODEM_NO_DIAL_TONE")]
    ModemNoDialTone,
    /// No carrier could be established
    #[doc(alias = "NM_DEVICE_STATE_REASON_MODEM_NO_CARRIER")]
    ModemNoCarrier,
    /// The dialing request timed out
    #[doc(alias = "NM_DEVICE_STATE_REASON_MODEM_DIAL_TIMEOUT")]
    ModemDialTimeout,
    /// The dialing attempt failed
    #[doc(alias = "NM_DEVICE_STATE_REASON_MODEM_DIAL_FAILED")]
    ModemDialFailed,
    /// Modem initialization failed
    #[doc(alias = "NM_DEVICE_STATE_REASON_MODEM_INIT_FAILED")]
    ModemInitFailed,
    /// Failed to select the specified APN
    #[doc(alias = "NM_DEVICE_STATE_REASON_GSM_APN_FAILED")]
    GsmApnFailed,
    /// Not searching for networks
    #[doc(alias = "NM_DEVICE_STATE_REASON_GSM_REGISTRATION_NOT_SEARCHING")]
    GsmRegistrationNotSearching,
    /// Network registration denied
    #[doc(alias = "NM_DEVICE_STATE_REASON_GSM_REGISTRATION_DENIED")]
    GsmRegistrationDenied,
    /// Network registration timed out
    #[doc(alias = "NM_DEVICE_STATE_REASON_GSM_REGISTRATION_TIMEOUT")]
    GsmRegistrationTimeout,
    /// Failed to register with the requested network
    #[doc(alias = "NM_DEVICE_STATE_REASON_GSM_REGISTRATION_FAILED")]
    GsmRegistrationFailed,
    /// PIN check failed
    #[doc(alias = "NM_DEVICE_STATE_REASON_GSM_PIN_CHECK_FAILED")]
    GsmPinCheckFailed,
    /// Necessary firmware for the device may be missing
    #[doc(alias = "NM_DEVICE_STATE_REASON_FIRMWARE_MISSING")]
    FirmwareMissing,
    /// The device was removed
    #[doc(alias = "NM_DEVICE_STATE_REASON_REMOVED")]
    Removed,
    /// NetworkManager went to sleep
    #[doc(alias = "NM_DEVICE_STATE_REASON_SLEEPING")]
    Sleeping,
    /// The device's active connection disappeared
    #[doc(alias = "NM_DEVICE_STATE_REASON_CONNECTION_REMOVED")]
    ConnectionRemoved,
    /// Device disconnected by user or client
    #[doc(alias = "NM_DEVICE_STATE_REASON_USER_REQUESTED")]
    UserRequested,
    /// Carrier/link changed
    #[doc(alias = "NM_DEVICE_STATE_REASON_CARRIER")]
    Carrier,
    /// The device's existing connection was assumed
    #[doc(alias = "NM_DEVICE_STATE_REASON_CONNECTION_ASSUMED")]
    ConnectionAssumed,
    /// The supplicant is now available
    #[doc(alias = "NM_DEVICE_STATE_REASON_SUPPLICANT_AVAILABLE")]
    SupplicantAvailable,
    /// The modem could not be found
    #[doc(alias = "NM_DEVICE_STATE_REASON_MODEM_NOT_FOUND")]
    ModemNotFound,
    /// The Bluetooth connection failed or timed out
    #[doc(alias = "NM_DEVICE_STATE_REASON_BT_FAILED")]
    BtFailed,
    /// GSM Modem's SIM Card not inserted
    #[doc(alias = "NM_DEVICE_STATE_REASON_GSM_SIM_NOT_INSERTED")]
    GsmSimNotInserted,
    /// GSM Modem's SIM Pin required
    #[doc(alias = "NM_DEVICE_STATE_REASON_GSM_SIM_PIN_REQUIRED")]
    GsmSimPinRequired,
    /// GSM Modem's SIM Puk required
    #[doc(alias = "NM_DEVICE_STATE_REASON_GSM_SIM_PUK_REQUIRED")]
    GsmSimPukRequired,
    /// GSM Modem's SIM wrong
    #[doc(alias = "NM_DEVICE_STATE_REASON_GSM_SIM_WRONG")]
    GsmSimWrong,
    /// InfiniBand device does not support connected mode
    #[doc(alias = "NM_DEVICE_STATE_REASON_INFINIBAND_MODE")]
    InfinibandMode,
    /// A dependency of the connection failed
    #[doc(alias = "NM_DEVICE_STATE_REASON_DEPENDENCY_FAILED")]
    DependencyFailed,
    /// Problem with the RFC 2684 Ethernet over ADSL bridge
    #[doc(alias = "NM_DEVICE_STATE_REASON_BR2684_FAILED")]
    Br2684Failed,
    /// ModemManager not running
    #[doc(alias = "NM_DEVICE_STATE_REASON_MODEM_MANAGER_UNAVAILABLE")]
    ModemManagerUnavailable,
    /// The Wi-Fi network could not be found
    #[doc(alias = "NM_DEVICE_STATE_REASON_SSID_NOT_FOUND")]
    SsidNotFound,
    /// A secondary connection of the base connection failed
    #[doc(alias = "NM_DEVICE_STATE_REASON_SECONDARY_CONNECTION_FAILED")]
    SecondaryConnectionFailed,
    /// DCB or FCoE setup failed
    #[doc(alias = "NM_DEVICE_STATE_REASON_DCB_FCOE_FAILED")]
    DcbFcoeFailed,
    /// teamd control failed
    #[doc(alias = "NM_DEVICE_STATE_REASON_TEAMD_CONTROL_FAILED")]
    TeamdControlFailed,
    /// Modem failed or no longer available
    #[doc(alias = "NM_DEVICE_STATE_REASON_MODEM_FAILED")]
    ModemFailed,
    /// Modem now ready and available
    #[doc(alias = "NM_DEVICE_STATE_REASON_MODEM_AVAILABLE")]
    ModemAvailable,
    /// SIM PIN was incorrect
    #[doc(alias = "NM_DEVICE_STATE_REASON_SIM_PIN_INCORRECT")]
    SimPinIncorrect,
    /// New connection activation was enqueued
    #[doc(alias = "NM_DEVICE_STATE_REASON_NEW_ACTIVATION")]
    NewActivation,
    /// the device's parent changed
    #[doc(alias = "NM_DEVICE_STATE_REASON_PARENT_CHANGED")]
    ParentChanged,
    /// the device parent's management changed
    #[doc(alias = "NM_DEVICE_STATE_REASON_PARENT_MANAGED_CHANGED")]
    ParentManagedChanged,
    /// problem communicating with Open vSwitch database
    #[doc(alias = "NM_DEVICE_STATE_REASON_OVSDB_FAILED")]
    OvsdbFailed,
    /// a duplicate IP address was detected
    #[doc(alias = "NM_DEVICE_STATE_REASON_IP_ADDRESS_DUPLICATE")]
    IpAddressDuplicate,
    /// The selected IP method is not supported
    #[doc(alias = "NM_DEVICE_STATE_REASON_IP_METHOD_UNSUPPORTED")]
    IpMethodUnsupported,
    /// configuration of SR-IOV parameters failed
    #[doc(alias = "NM_DEVICE_STATE_REASON_SRIOV_CONFIGURATION_FAILED")]
    SriovConfigurationFailed,
    /// The Wi-Fi P2P peer could not be found
    #[doc(alias = "NM_DEVICE_STATE_REASON_PEER_NOT_FOUND")]
    PeerNotFound,
    /// The device handler dispatcher returned an
    ///   error. Since: 1.46
    #[doc(alias = "NM_DEVICE_STATE_REASON_DEVICE_HANDLER_FAILED")]
    DeviceHandlerFailed,
    /// The device is unmanaged because the device type
    ///   is unmanaged by default. Since: 1.48
    #[doc(alias = "NM_DEVICE_STATE_REASON_UNMANAGED_BY_DEFAULT")]
    UnmanagedByDefault,
    /// The device is unmanaged because it is an
    ///   external device and is unconfigured (down or without addresses). Since: 1.48
    #[doc(alias = "NM_DEVICE_STATE_REASON_UNMANAGED_EXTERNAL_DOWN")]
    UnmanagedExternalDown,
    /// The device is unmanaged because the link is
    ///   not initialized by udev. Since: 1.48
    #[doc(alias = "NM_DEVICE_STATE_REASON_UNMANAGED_LINK_NOT_INIT")]
    UnmanagedLinkNotInit,
    /// The device is unmanaged because NetworkManager is
    ///   quitting. Since: 1.48
    #[doc(alias = "NM_DEVICE_STATE_REASON_UNMANAGED_QUITTING")]
    UnmanagedQuitting,
    /// The device is unmanaged because networking is
    ///   disabled or the system is suspended. Since: 1.48
    #[doc(alias = "NM_DEVICE_STATE_REASON_UNMANAGED_SLEEPING")]
    UnmanagedSleeping,
    /// The device is unmanaged by user decision in
    ///   NetworkManager.conf ('unmanaged' in a [device*] section). Since: 1.48
    #[doc(alias = "NM_DEVICE_STATE_REASON_UNMANAGED_USER_CONF")]
    UnmanagedUserConf,
    /// The device is unmanaged by explicit user
    ///   decision (e.g. 'nmcli device set $DEV managed no'). Since: 1.48
    #[doc(alias = "NM_DEVICE_STATE_REASON_UNMANAGED_USER_EXPLICIT")]
    UnmanagedUserExplicit,
    /// The device is unmanaged by user decision
    ///   via settings plugin ('unmanaged-devices' for keyfile or 'NM_CONTROLLED=no' for ifcfg-rh).
    ///   Since: 1.48
    #[doc(alias = "NM_DEVICE_STATE_REASON_UNMANAGED_USER_SETTINGS")]
    UnmanagedUserSettings,
    /// The device is unmanaged via udev rule. Since: 1.48
    #[doc(alias = "NM_DEVICE_STATE_REASON_UNMANAGED_USER_UDEV")]
    UnmanagedUserUdev,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for DeviceStateReason {
    type GlibType = ffi::NMDeviceStateReason;

    fn into_glib(self) -> ffi::NMDeviceStateReason {
        match self {
            Self::None => ffi::NM_DEVICE_STATE_REASON_NONE,
            Self::Unknown => ffi::NM_DEVICE_STATE_REASON_UNKNOWN,
            Self::NowManaged => ffi::NM_DEVICE_STATE_REASON_NOW_MANAGED,
            Self::NowUnmanaged => ffi::NM_DEVICE_STATE_REASON_NOW_UNMANAGED,
            Self::ConfigFailed => ffi::NM_DEVICE_STATE_REASON_CONFIG_FAILED,
            Self::IpConfigUnavailable => ffi::NM_DEVICE_STATE_REASON_IP_CONFIG_UNAVAILABLE,
            Self::IpConfigExpired => ffi::NM_DEVICE_STATE_REASON_IP_CONFIG_EXPIRED,
            Self::NoSecrets => ffi::NM_DEVICE_STATE_REASON_NO_SECRETS,
            Self::SupplicantDisconnect => ffi::NM_DEVICE_STATE_REASON_SUPPLICANT_DISCONNECT,
            Self::SupplicantConfigFailed => ffi::NM_DEVICE_STATE_REASON_SUPPLICANT_CONFIG_FAILED,
            Self::SupplicantFailed => ffi::NM_DEVICE_STATE_REASON_SUPPLICANT_FAILED,
            Self::SupplicantTimeout => ffi::NM_DEVICE_STATE_REASON_SUPPLICANT_TIMEOUT,
            Self::PppStartFailed => ffi::NM_DEVICE_STATE_REASON_PPP_START_FAILED,
            Self::PppDisconnect => ffi::NM_DEVICE_STATE_REASON_PPP_DISCONNECT,
            Self::PppFailed => ffi::NM_DEVICE_STATE_REASON_PPP_FAILED,
            Self::DhcpStartFailed => ffi::NM_DEVICE_STATE_REASON_DHCP_START_FAILED,
            Self::DhcpError => ffi::NM_DEVICE_STATE_REASON_DHCP_ERROR,
            Self::DhcpFailed => ffi::NM_DEVICE_STATE_REASON_DHCP_FAILED,
            Self::SharedStartFailed => ffi::NM_DEVICE_STATE_REASON_SHARED_START_FAILED,
            Self::SharedFailed => ffi::NM_DEVICE_STATE_REASON_SHARED_FAILED,
            Self::AutoipStartFailed => ffi::NM_DEVICE_STATE_REASON_AUTOIP_START_FAILED,
            Self::AutoipError => ffi::NM_DEVICE_STATE_REASON_AUTOIP_ERROR,
            Self::AutoipFailed => ffi::NM_DEVICE_STATE_REASON_AUTOIP_FAILED,
            Self::ModemBusy => ffi::NM_DEVICE_STATE_REASON_MODEM_BUSY,
            Self::ModemNoDialTone => ffi::NM_DEVICE_STATE_REASON_MODEM_NO_DIAL_TONE,
            Self::ModemNoCarrier => ffi::NM_DEVICE_STATE_REASON_MODEM_NO_CARRIER,
            Self::ModemDialTimeout => ffi::NM_DEVICE_STATE_REASON_MODEM_DIAL_TIMEOUT,
            Self::ModemDialFailed => ffi::NM_DEVICE_STATE_REASON_MODEM_DIAL_FAILED,
            Self::ModemInitFailed => ffi::NM_DEVICE_STATE_REASON_MODEM_INIT_FAILED,
            Self::GsmApnFailed => ffi::NM_DEVICE_STATE_REASON_GSM_APN_FAILED,
            Self::GsmRegistrationNotSearching => {
                ffi::NM_DEVICE_STATE_REASON_GSM_REGISTRATION_NOT_SEARCHING
            }
            Self::GsmRegistrationDenied => ffi::NM_DEVICE_STATE_REASON_GSM_REGISTRATION_DENIED,
            Self::GsmRegistrationTimeout => ffi::NM_DEVICE_STATE_REASON_GSM_REGISTRATION_TIMEOUT,
            Self::GsmRegistrationFailed => ffi::NM_DEVICE_STATE_REASON_GSM_REGISTRATION_FAILED,
            Self::GsmPinCheckFailed => ffi::NM_DEVICE_STATE_REASON_GSM_PIN_CHECK_FAILED,
            Self::FirmwareMissing => ffi::NM_DEVICE_STATE_REASON_FIRMWARE_MISSING,
            Self::Removed => ffi::NM_DEVICE_STATE_REASON_REMOVED,
            Self::Sleeping => ffi::NM_DEVICE_STATE_REASON_SLEEPING,
            Self::ConnectionRemoved => ffi::NM_DEVICE_STATE_REASON_CONNECTION_REMOVED,
            Self::UserRequested => ffi::NM_DEVICE_STATE_REASON_USER_REQUESTED,
            Self::Carrier => ffi::NM_DEVICE_STATE_REASON_CARRIER,
            Self::ConnectionAssumed => ffi::NM_DEVICE_STATE_REASON_CONNECTION_ASSUMED,
            Self::SupplicantAvailable => ffi::NM_DEVICE_STATE_REASON_SUPPLICANT_AVAILABLE,
            Self::ModemNotFound => ffi::NM_DEVICE_STATE_REASON_MODEM_NOT_FOUND,
            Self::BtFailed => ffi::NM_DEVICE_STATE_REASON_BT_FAILED,
            Self::GsmSimNotInserted => ffi::NM_DEVICE_STATE_REASON_GSM_SIM_NOT_INSERTED,
            Self::GsmSimPinRequired => ffi::NM_DEVICE_STATE_REASON_GSM_SIM_PIN_REQUIRED,
            Self::GsmSimPukRequired => ffi::NM_DEVICE_STATE_REASON_GSM_SIM_PUK_REQUIRED,
            Self::GsmSimWrong => ffi::NM_DEVICE_STATE_REASON_GSM_SIM_WRONG,
            Self::InfinibandMode => ffi::NM_DEVICE_STATE_REASON_INFINIBAND_MODE,
            Self::DependencyFailed => ffi::NM_DEVICE_STATE_REASON_DEPENDENCY_FAILED,
            Self::Br2684Failed => ffi::NM_DEVICE_STATE_REASON_BR2684_FAILED,
            Self::ModemManagerUnavailable => ffi::NM_DEVICE_STATE_REASON_MODEM_MANAGER_UNAVAILABLE,
            Self::SsidNotFound => ffi::NM_DEVICE_STATE_REASON_SSID_NOT_FOUND,
            Self::SecondaryConnectionFailed => {
                ffi::NM_DEVICE_STATE_REASON_SECONDARY_CONNECTION_FAILED
            }
            Self::DcbFcoeFailed => ffi::NM_DEVICE_STATE_REASON_DCB_FCOE_FAILED,
            Self::TeamdControlFailed => ffi::NM_DEVICE_STATE_REASON_TEAMD_CONTROL_FAILED,
            Self::ModemFailed => ffi::NM_DEVICE_STATE_REASON_MODEM_FAILED,
            Self::ModemAvailable => ffi::NM_DEVICE_STATE_REASON_MODEM_AVAILABLE,
            Self::SimPinIncorrect => ffi::NM_DEVICE_STATE_REASON_SIM_PIN_INCORRECT,
            Self::NewActivation => ffi::NM_DEVICE_STATE_REASON_NEW_ACTIVATION,
            Self::ParentChanged => ffi::NM_DEVICE_STATE_REASON_PARENT_CHANGED,
            Self::ParentManagedChanged => ffi::NM_DEVICE_STATE_REASON_PARENT_MANAGED_CHANGED,
            Self::OvsdbFailed => ffi::NM_DEVICE_STATE_REASON_OVSDB_FAILED,
            Self::IpAddressDuplicate => ffi::NM_DEVICE_STATE_REASON_IP_ADDRESS_DUPLICATE,
            Self::IpMethodUnsupported => ffi::NM_DEVICE_STATE_REASON_IP_METHOD_UNSUPPORTED,
            Self::SriovConfigurationFailed => {
                ffi::NM_DEVICE_STATE_REASON_SRIOV_CONFIGURATION_FAILED
            }
            Self::PeerNotFound => ffi::NM_DEVICE_STATE_REASON_PEER_NOT_FOUND,
            Self::DeviceHandlerFailed => ffi::NM_DEVICE_STATE_REASON_DEVICE_HANDLER_FAILED,
            Self::UnmanagedByDefault => ffi::NM_DEVICE_STATE_REASON_UNMANAGED_BY_DEFAULT,
            Self::UnmanagedExternalDown => ffi::NM_DEVICE_STATE_REASON_UNMANAGED_EXTERNAL_DOWN,
            Self::UnmanagedLinkNotInit => ffi::NM_DEVICE_STATE_REASON_UNMANAGED_LINK_NOT_INIT,
            Self::UnmanagedQuitting => ffi::NM_DEVICE_STATE_REASON_UNMANAGED_QUITTING,
            Self::UnmanagedSleeping => ffi::NM_DEVICE_STATE_REASON_UNMANAGED_SLEEPING,
            Self::UnmanagedUserConf => ffi::NM_DEVICE_STATE_REASON_UNMANAGED_USER_CONF,
            Self::UnmanagedUserExplicit => ffi::NM_DEVICE_STATE_REASON_UNMANAGED_USER_EXPLICIT,
            Self::UnmanagedUserSettings => ffi::NM_DEVICE_STATE_REASON_UNMANAGED_USER_SETTINGS,
            Self::UnmanagedUserUdev => ffi::NM_DEVICE_STATE_REASON_UNMANAGED_USER_UDEV,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMDeviceStateReason> for DeviceStateReason {
    unsafe fn from_glib(value: ffi::NMDeviceStateReason) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_DEVICE_STATE_REASON_NONE => Self::None,
            ffi::NM_DEVICE_STATE_REASON_UNKNOWN => Self::Unknown,
            ffi::NM_DEVICE_STATE_REASON_NOW_MANAGED => Self::NowManaged,
            ffi::NM_DEVICE_STATE_REASON_NOW_UNMANAGED => Self::NowUnmanaged,
            ffi::NM_DEVICE_STATE_REASON_CONFIG_FAILED => Self::ConfigFailed,
            ffi::NM_DEVICE_STATE_REASON_IP_CONFIG_UNAVAILABLE => Self::IpConfigUnavailable,
            ffi::NM_DEVICE_STATE_REASON_IP_CONFIG_EXPIRED => Self::IpConfigExpired,
            ffi::NM_DEVICE_STATE_REASON_NO_SECRETS => Self::NoSecrets,
            ffi::NM_DEVICE_STATE_REASON_SUPPLICANT_DISCONNECT => Self::SupplicantDisconnect,
            ffi::NM_DEVICE_STATE_REASON_SUPPLICANT_CONFIG_FAILED => Self::SupplicantConfigFailed,
            ffi::NM_DEVICE_STATE_REASON_SUPPLICANT_FAILED => Self::SupplicantFailed,
            ffi::NM_DEVICE_STATE_REASON_SUPPLICANT_TIMEOUT => Self::SupplicantTimeout,
            ffi::NM_DEVICE_STATE_REASON_PPP_START_FAILED => Self::PppStartFailed,
            ffi::NM_DEVICE_STATE_REASON_PPP_DISCONNECT => Self::PppDisconnect,
            ffi::NM_DEVICE_STATE_REASON_PPP_FAILED => Self::PppFailed,
            ffi::NM_DEVICE_STATE_REASON_DHCP_START_FAILED => Self::DhcpStartFailed,
            ffi::NM_DEVICE_STATE_REASON_DHCP_ERROR => Self::DhcpError,
            ffi::NM_DEVICE_STATE_REASON_DHCP_FAILED => Self::DhcpFailed,
            ffi::NM_DEVICE_STATE_REASON_SHARED_START_FAILED => Self::SharedStartFailed,
            ffi::NM_DEVICE_STATE_REASON_SHARED_FAILED => Self::SharedFailed,
            ffi::NM_DEVICE_STATE_REASON_AUTOIP_START_FAILED => Self::AutoipStartFailed,
            ffi::NM_DEVICE_STATE_REASON_AUTOIP_ERROR => Self::AutoipError,
            ffi::NM_DEVICE_STATE_REASON_AUTOIP_FAILED => Self::AutoipFailed,
            ffi::NM_DEVICE_STATE_REASON_MODEM_BUSY => Self::ModemBusy,
            ffi::NM_DEVICE_STATE_REASON_MODEM_NO_DIAL_TONE => Self::ModemNoDialTone,
            ffi::NM_DEVICE_STATE_REASON_MODEM_NO_CARRIER => Self::ModemNoCarrier,
            ffi::NM_DEVICE_STATE_REASON_MODEM_DIAL_TIMEOUT => Self::ModemDialTimeout,
            ffi::NM_DEVICE_STATE_REASON_MODEM_DIAL_FAILED => Self::ModemDialFailed,
            ffi::NM_DEVICE_STATE_REASON_MODEM_INIT_FAILED => Self::ModemInitFailed,
            ffi::NM_DEVICE_STATE_REASON_GSM_APN_FAILED => Self::GsmApnFailed,
            ffi::NM_DEVICE_STATE_REASON_GSM_REGISTRATION_NOT_SEARCHING => {
                Self::GsmRegistrationNotSearching
            }
            ffi::NM_DEVICE_STATE_REASON_GSM_REGISTRATION_DENIED => Self::GsmRegistrationDenied,
            ffi::NM_DEVICE_STATE_REASON_GSM_REGISTRATION_TIMEOUT => Self::GsmRegistrationTimeout,
            ffi::NM_DEVICE_STATE_REASON_GSM_REGISTRATION_FAILED => Self::GsmRegistrationFailed,
            ffi::NM_DEVICE_STATE_REASON_GSM_PIN_CHECK_FAILED => Self::GsmPinCheckFailed,
            ffi::NM_DEVICE_STATE_REASON_FIRMWARE_MISSING => Self::FirmwareMissing,
            ffi::NM_DEVICE_STATE_REASON_REMOVED => Self::Removed,
            ffi::NM_DEVICE_STATE_REASON_SLEEPING => Self::Sleeping,
            ffi::NM_DEVICE_STATE_REASON_CONNECTION_REMOVED => Self::ConnectionRemoved,
            ffi::NM_DEVICE_STATE_REASON_USER_REQUESTED => Self::UserRequested,
            ffi::NM_DEVICE_STATE_REASON_CARRIER => Self::Carrier,
            ffi::NM_DEVICE_STATE_REASON_CONNECTION_ASSUMED => Self::ConnectionAssumed,
            ffi::NM_DEVICE_STATE_REASON_SUPPLICANT_AVAILABLE => Self::SupplicantAvailable,
            ffi::NM_DEVICE_STATE_REASON_MODEM_NOT_FOUND => Self::ModemNotFound,
            ffi::NM_DEVICE_STATE_REASON_BT_FAILED => Self::BtFailed,
            ffi::NM_DEVICE_STATE_REASON_GSM_SIM_NOT_INSERTED => Self::GsmSimNotInserted,
            ffi::NM_DEVICE_STATE_REASON_GSM_SIM_PIN_REQUIRED => Self::GsmSimPinRequired,
            ffi::NM_DEVICE_STATE_REASON_GSM_SIM_PUK_REQUIRED => Self::GsmSimPukRequired,
            ffi::NM_DEVICE_STATE_REASON_GSM_SIM_WRONG => Self::GsmSimWrong,
            ffi::NM_DEVICE_STATE_REASON_INFINIBAND_MODE => Self::InfinibandMode,
            ffi::NM_DEVICE_STATE_REASON_DEPENDENCY_FAILED => Self::DependencyFailed,
            ffi::NM_DEVICE_STATE_REASON_BR2684_FAILED => Self::Br2684Failed,
            ffi::NM_DEVICE_STATE_REASON_MODEM_MANAGER_UNAVAILABLE => Self::ModemManagerUnavailable,
            ffi::NM_DEVICE_STATE_REASON_SSID_NOT_FOUND => Self::SsidNotFound,
            ffi::NM_DEVICE_STATE_REASON_SECONDARY_CONNECTION_FAILED => {
                Self::SecondaryConnectionFailed
            }
            ffi::NM_DEVICE_STATE_REASON_DCB_FCOE_FAILED => Self::DcbFcoeFailed,
            ffi::NM_DEVICE_STATE_REASON_TEAMD_CONTROL_FAILED => Self::TeamdControlFailed,
            ffi::NM_DEVICE_STATE_REASON_MODEM_FAILED => Self::ModemFailed,
            ffi::NM_DEVICE_STATE_REASON_MODEM_AVAILABLE => Self::ModemAvailable,
            ffi::NM_DEVICE_STATE_REASON_SIM_PIN_INCORRECT => Self::SimPinIncorrect,
            ffi::NM_DEVICE_STATE_REASON_NEW_ACTIVATION => Self::NewActivation,
            ffi::NM_DEVICE_STATE_REASON_PARENT_CHANGED => Self::ParentChanged,
            ffi::NM_DEVICE_STATE_REASON_PARENT_MANAGED_CHANGED => Self::ParentManagedChanged,
            ffi::NM_DEVICE_STATE_REASON_OVSDB_FAILED => Self::OvsdbFailed,
            ffi::NM_DEVICE_STATE_REASON_IP_ADDRESS_DUPLICATE => Self::IpAddressDuplicate,
            ffi::NM_DEVICE_STATE_REASON_IP_METHOD_UNSUPPORTED => Self::IpMethodUnsupported,
            ffi::NM_DEVICE_STATE_REASON_SRIOV_CONFIGURATION_FAILED => {
                Self::SriovConfigurationFailed
            }
            ffi::NM_DEVICE_STATE_REASON_PEER_NOT_FOUND => Self::PeerNotFound,
            ffi::NM_DEVICE_STATE_REASON_DEVICE_HANDLER_FAILED => Self::DeviceHandlerFailed,
            ffi::NM_DEVICE_STATE_REASON_UNMANAGED_BY_DEFAULT => Self::UnmanagedByDefault,
            ffi::NM_DEVICE_STATE_REASON_UNMANAGED_EXTERNAL_DOWN => Self::UnmanagedExternalDown,
            ffi::NM_DEVICE_STATE_REASON_UNMANAGED_LINK_NOT_INIT => Self::UnmanagedLinkNotInit,
            ffi::NM_DEVICE_STATE_REASON_UNMANAGED_QUITTING => Self::UnmanagedQuitting,
            ffi::NM_DEVICE_STATE_REASON_UNMANAGED_SLEEPING => Self::UnmanagedSleeping,
            ffi::NM_DEVICE_STATE_REASON_UNMANAGED_USER_CONF => Self::UnmanagedUserConf,
            ffi::NM_DEVICE_STATE_REASON_UNMANAGED_USER_EXPLICIT => Self::UnmanagedUserExplicit,
            ffi::NM_DEVICE_STATE_REASON_UNMANAGED_USER_SETTINGS => Self::UnmanagedUserSettings,
            ffi::NM_DEVICE_STATE_REASON_UNMANAGED_USER_UDEV => Self::UnmanagedUserUdev,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for DeviceStateReason {
    #[inline]
    #[doc(alias = "nm_device_state_reason_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_device_state_reason_get_type()) }
    }
}

impl glib::HasParamSpec for DeviceStateReason {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for DeviceStateReason {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for DeviceStateReason {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for DeviceStateReason {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<DeviceStateReason> for glib::Value {
    #[inline]
    fn from(v: DeviceStateReason) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// #NMDeviceType values indicate the type of hardware represented by a
/// device object.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMDeviceType")]
pub enum DeviceType {
    /// unknown device
    #[doc(alias = "NM_DEVICE_TYPE_UNKNOWN")]
    Unknown,
    /// a wired ethernet device
    #[doc(alias = "NM_DEVICE_TYPE_ETHERNET")]
    Ethernet,
    /// an 802.11 Wi-Fi device
    #[doc(alias = "NM_DEVICE_TYPE_WIFI")]
    Wifi,
    /// not used
    #[doc(alias = "NM_DEVICE_TYPE_UNUSED1")]
    Unused1,
    /// not used
    #[doc(alias = "NM_DEVICE_TYPE_UNUSED2")]
    Unused2,
    /// a Bluetooth device supporting PAN or DUN access protocols
    #[doc(alias = "NM_DEVICE_TYPE_BT")]
    Bt,
    /// an OLPC XO mesh networking device
    #[doc(alias = "NM_DEVICE_TYPE_OLPC_MESH")]
    OlpcMesh,
    /// an 802.16e Mobile WiMAX broadband device
    #[doc(alias = "NM_DEVICE_TYPE_WIMAX")]
    Wimax,
    /// a modem supporting analog telephone, CDMA/EVDO,
    /// GSM/UMTS, or LTE network access protocols
    #[doc(alias = "NM_DEVICE_TYPE_MODEM")]
    Modem,
    /// an IP-over-InfiniBand device
    #[doc(alias = "NM_DEVICE_TYPE_INFINIBAND")]
    Infiniband,
    /// a bond controller interface
    #[doc(alias = "NM_DEVICE_TYPE_BOND")]
    Bond,
    /// an 802.1Q VLAN interface
    #[doc(alias = "NM_DEVICE_TYPE_VLAN")]
    Vlan,
    /// ADSL modem
    #[doc(alias = "NM_DEVICE_TYPE_ADSL")]
    Adsl,
    /// a bridge controller interface
    #[doc(alias = "NM_DEVICE_TYPE_BRIDGE")]
    Bridge,
    /// generic support for unrecognized device types
    #[doc(alias = "NM_DEVICE_TYPE_GENERIC")]
    Generic,
    /// a team controller interface
    #[doc(alias = "NM_DEVICE_TYPE_TEAM")]
    Team,
    /// a TUN or TAP interface
    #[doc(alias = "NM_DEVICE_TYPE_TUN")]
    Tun,
    /// a IP tunnel interface
    #[doc(alias = "NM_DEVICE_TYPE_IP_TUNNEL")]
    IpTunnel,
    /// a MACVLAN interface
    #[doc(alias = "NM_DEVICE_TYPE_MACVLAN")]
    Macvlan,
    /// a VXLAN interface
    #[doc(alias = "NM_DEVICE_TYPE_VXLAN")]
    Vxlan,
    /// a VETH interface
    #[doc(alias = "NM_DEVICE_TYPE_VETH")]
    Veth,
    /// a MACsec interface
    #[doc(alias = "NM_DEVICE_TYPE_MACSEC")]
    Macsec,
    /// a dummy interface
    #[doc(alias = "NM_DEVICE_TYPE_DUMMY")]
    Dummy,
    /// a PPP interface
    #[doc(alias = "NM_DEVICE_TYPE_PPP")]
    Ppp,
    /// a Open vSwitch interface
    #[doc(alias = "NM_DEVICE_TYPE_OVS_INTERFACE")]
    OvsInterface,
    /// a Open vSwitch port
    #[doc(alias = "NM_DEVICE_TYPE_OVS_PORT")]
    OvsPort,
    /// a Open vSwitch bridge
    #[doc(alias = "NM_DEVICE_TYPE_OVS_BRIDGE")]
    OvsBridge,
    /// a IEEE 802.15.4 (WPAN) MAC Layer Device
    #[doc(alias = "NM_DEVICE_TYPE_WPAN")]
    Wpan,
    /// 6LoWPAN interface
    #[doc(alias = "NM_DEVICE_TYPE_6LOWPAN")]
    _6lowpan,
    /// a WireGuard interface
    #[doc(alias = "NM_DEVICE_TYPE_WIREGUARD")]
    Wireguard,
    /// an 802.11 Wi-Fi P2P device. Since: 1.16.
    #[doc(alias = "NM_DEVICE_TYPE_WIFI_P2P")]
    WifiP2p,
    /// A VRF (Virtual Routing and Forwarding) interface. Since: 1.24.
    #[doc(alias = "NM_DEVICE_TYPE_VRF")]
    Vrf,
    /// a loopback interface. Since: 1.42.
    #[doc(alias = "NM_DEVICE_TYPE_LOOPBACK")]
    Loopback,
    /// A HSR/PRP device. Since: 1.46.
    #[doc(alias = "NM_DEVICE_TYPE_HSR")]
    Hsr,
    /// A IPVLAN device. Since: 1.52.
    #[doc(alias = "NM_DEVICE_TYPE_IPVLAN")]
    Ipvlan,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for DeviceType {
    type GlibType = ffi::NMDeviceType;

    fn into_glib(self) -> ffi::NMDeviceType {
        match self {
            Self::Unknown => ffi::NM_DEVICE_TYPE_UNKNOWN,
            Self::Ethernet => ffi::NM_DEVICE_TYPE_ETHERNET,
            Self::Wifi => ffi::NM_DEVICE_TYPE_WIFI,
            Self::Unused1 => ffi::NM_DEVICE_TYPE_UNUSED1,
            Self::Unused2 => ffi::NM_DEVICE_TYPE_UNUSED2,
            Self::Bt => ffi::NM_DEVICE_TYPE_BT,
            Self::OlpcMesh => ffi::NM_DEVICE_TYPE_OLPC_MESH,
            Self::Wimax => ffi::NM_DEVICE_TYPE_WIMAX,
            Self::Modem => ffi::NM_DEVICE_TYPE_MODEM,
            Self::Infiniband => ffi::NM_DEVICE_TYPE_INFINIBAND,
            Self::Bond => ffi::NM_DEVICE_TYPE_BOND,
            Self::Vlan => ffi::NM_DEVICE_TYPE_VLAN,
            Self::Adsl => ffi::NM_DEVICE_TYPE_ADSL,
            Self::Bridge => ffi::NM_DEVICE_TYPE_BRIDGE,
            Self::Generic => ffi::NM_DEVICE_TYPE_GENERIC,
            Self::Team => ffi::NM_DEVICE_TYPE_TEAM,
            Self::Tun => ffi::NM_DEVICE_TYPE_TUN,
            Self::IpTunnel => ffi::NM_DEVICE_TYPE_IP_TUNNEL,
            Self::Macvlan => ffi::NM_DEVICE_TYPE_MACVLAN,
            Self::Vxlan => ffi::NM_DEVICE_TYPE_VXLAN,
            Self::Veth => ffi::NM_DEVICE_TYPE_VETH,
            Self::Macsec => ffi::NM_DEVICE_TYPE_MACSEC,
            Self::Dummy => ffi::NM_DEVICE_TYPE_DUMMY,
            Self::Ppp => ffi::NM_DEVICE_TYPE_PPP,
            Self::OvsInterface => ffi::NM_DEVICE_TYPE_OVS_INTERFACE,
            Self::OvsPort => ffi::NM_DEVICE_TYPE_OVS_PORT,
            Self::OvsBridge => ffi::NM_DEVICE_TYPE_OVS_BRIDGE,
            Self::Wpan => ffi::NM_DEVICE_TYPE_WPAN,
            Self::_6lowpan => ffi::NM_DEVICE_TYPE_6LOWPAN,
            Self::Wireguard => ffi::NM_DEVICE_TYPE_WIREGUARD,
            Self::WifiP2p => ffi::NM_DEVICE_TYPE_WIFI_P2P,
            Self::Vrf => ffi::NM_DEVICE_TYPE_VRF,
            Self::Loopback => ffi::NM_DEVICE_TYPE_LOOPBACK,
            Self::Hsr => ffi::NM_DEVICE_TYPE_HSR,
            Self::Ipvlan => ffi::NM_DEVICE_TYPE_IPVLAN,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMDeviceType> for DeviceType {
    unsafe fn from_glib(value: ffi::NMDeviceType) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_DEVICE_TYPE_UNKNOWN => Self::Unknown,
            ffi::NM_DEVICE_TYPE_ETHERNET => Self::Ethernet,
            ffi::NM_DEVICE_TYPE_WIFI => Self::Wifi,
            ffi::NM_DEVICE_TYPE_UNUSED1 => Self::Unused1,
            ffi::NM_DEVICE_TYPE_UNUSED2 => Self::Unused2,
            ffi::NM_DEVICE_TYPE_BT => Self::Bt,
            ffi::NM_DEVICE_TYPE_OLPC_MESH => Self::OlpcMesh,
            ffi::NM_DEVICE_TYPE_WIMAX => Self::Wimax,
            ffi::NM_DEVICE_TYPE_MODEM => Self::Modem,
            ffi::NM_DEVICE_TYPE_INFINIBAND => Self::Infiniband,
            ffi::NM_DEVICE_TYPE_BOND => Self::Bond,
            ffi::NM_DEVICE_TYPE_VLAN => Self::Vlan,
            ffi::NM_DEVICE_TYPE_ADSL => Self::Adsl,
            ffi::NM_DEVICE_TYPE_BRIDGE => Self::Bridge,
            ffi::NM_DEVICE_TYPE_GENERIC => Self::Generic,
            ffi::NM_DEVICE_TYPE_TEAM => Self::Team,
            ffi::NM_DEVICE_TYPE_TUN => Self::Tun,
            ffi::NM_DEVICE_TYPE_IP_TUNNEL => Self::IpTunnel,
            ffi::NM_DEVICE_TYPE_MACVLAN => Self::Macvlan,
            ffi::NM_DEVICE_TYPE_VXLAN => Self::Vxlan,
            ffi::NM_DEVICE_TYPE_VETH => Self::Veth,
            ffi::NM_DEVICE_TYPE_MACSEC => Self::Macsec,
            ffi::NM_DEVICE_TYPE_DUMMY => Self::Dummy,
            ffi::NM_DEVICE_TYPE_PPP => Self::Ppp,
            ffi::NM_DEVICE_TYPE_OVS_INTERFACE => Self::OvsInterface,
            ffi::NM_DEVICE_TYPE_OVS_PORT => Self::OvsPort,
            ffi::NM_DEVICE_TYPE_OVS_BRIDGE => Self::OvsBridge,
            ffi::NM_DEVICE_TYPE_WPAN => Self::Wpan,
            ffi::NM_DEVICE_TYPE_6LOWPAN => Self::_6lowpan,
            ffi::NM_DEVICE_TYPE_WIREGUARD => Self::Wireguard,
            ffi::NM_DEVICE_TYPE_WIFI_P2P => Self::WifiP2p,
            ffi::NM_DEVICE_TYPE_VRF => Self::Vrf,
            ffi::NM_DEVICE_TYPE_LOOPBACK => Self::Loopback,
            ffi::NM_DEVICE_TYPE_HSR => Self::Hsr,
            ffi::NM_DEVICE_TYPE_IPVLAN => Self::Ipvlan,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for DeviceType {
    #[inline]
    #[doc(alias = "nm_device_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_device_type_get_type()) }
    }
}

impl glib::HasParamSpec for DeviceType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for DeviceType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for DeviceType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for DeviceType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<DeviceType> for glib::Value {
    #[inline]
    fn from(v: DeviceType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// The tunneling mode.
#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMIPTunnelMode")]
pub enum IPTunnelMode {
    /// Unknown/unset tunnel mode
    #[doc(alias = "NM_IP_TUNNEL_MODE_UNKNOWN")]
    Unknown,
    /// IP in IP tunnel
    #[doc(alias = "NM_IP_TUNNEL_MODE_IPIP")]
    Ipip,
    /// GRE tunnel
    #[doc(alias = "NM_IP_TUNNEL_MODE_GRE")]
    Gre,
    /// SIT tunnel
    #[doc(alias = "NM_IP_TUNNEL_MODE_SIT")]
    Sit,
    /// ISATAP tunnel
    #[doc(alias = "NM_IP_TUNNEL_MODE_ISATAP")]
    Isatap,
    /// VTI tunnel
    #[doc(alias = "NM_IP_TUNNEL_MODE_VTI")]
    Vti,
    /// IPv6 in IPv6 tunnel
    #[doc(alias = "NM_IP_TUNNEL_MODE_IP6IP6")]
    Ip6ip6,
    /// IPv4 in IPv6 tunnel
    #[doc(alias = "NM_IP_TUNNEL_MODE_IPIP6")]
    Ipip6,
    /// IPv6 GRE tunnel
    #[doc(alias = "NM_IP_TUNNEL_MODE_IP6GRE")]
    Ip6gre,
    /// IPv6 VTI tunnel
    #[doc(alias = "NM_IP_TUNNEL_MODE_VTI6")]
    Vti6,
    /// GRETAP tunnel
    #[doc(alias = "NM_IP_TUNNEL_MODE_GRETAP")]
    Gretap,
    /// IPv6 GRETAP tunnel
    #[doc(alias = "NM_IP_TUNNEL_MODE_IP6GRETAP")]
    Ip6gretap,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
#[doc(hidden)]
impl IntoGlib for IPTunnelMode {
    type GlibType = ffi::NMIPTunnelMode;

    #[inline]
    fn into_glib(self) -> ffi::NMIPTunnelMode {
        match self {
            Self::Unknown => ffi::NM_IP_TUNNEL_MODE_UNKNOWN,
            Self::Ipip => ffi::NM_IP_TUNNEL_MODE_IPIP,
            Self::Gre => ffi::NM_IP_TUNNEL_MODE_GRE,
            Self::Sit => ffi::NM_IP_TUNNEL_MODE_SIT,
            Self::Isatap => ffi::NM_IP_TUNNEL_MODE_ISATAP,
            Self::Vti => ffi::NM_IP_TUNNEL_MODE_VTI,
            Self::Ip6ip6 => ffi::NM_IP_TUNNEL_MODE_IP6IP6,
            Self::Ipip6 => ffi::NM_IP_TUNNEL_MODE_IPIP6,
            Self::Ip6gre => ffi::NM_IP_TUNNEL_MODE_IP6GRE,
            Self::Vti6 => ffi::NM_IP_TUNNEL_MODE_VTI6,
            Self::Gretap => ffi::NM_IP_TUNNEL_MODE_GRETAP,
            Self::Ip6gretap => ffi::NM_IP_TUNNEL_MODE_IP6GRETAP,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
#[doc(hidden)]
impl FromGlib<ffi::NMIPTunnelMode> for IPTunnelMode {
    #[inline]
    unsafe fn from_glib(value: ffi::NMIPTunnelMode) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_IP_TUNNEL_MODE_UNKNOWN => Self::Unknown,
            ffi::NM_IP_TUNNEL_MODE_IPIP => Self::Ipip,
            ffi::NM_IP_TUNNEL_MODE_GRE => Self::Gre,
            ffi::NM_IP_TUNNEL_MODE_SIT => Self::Sit,
            ffi::NM_IP_TUNNEL_MODE_ISATAP => Self::Isatap,
            ffi::NM_IP_TUNNEL_MODE_VTI => Self::Vti,
            ffi::NM_IP_TUNNEL_MODE_IP6IP6 => Self::Ip6ip6,
            ffi::NM_IP_TUNNEL_MODE_IPIP6 => Self::Ipip6,
            ffi::NM_IP_TUNNEL_MODE_IP6GRE => Self::Ip6gre,
            ffi::NM_IP_TUNNEL_MODE_VTI6 => Self::Vti6,
            ffi::NM_IP_TUNNEL_MODE_GRETAP => Self::Gretap,
            ffi::NM_IP_TUNNEL_MODE_IP6GRETAP => Self::Ip6gretap,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
impl StaticType for IPTunnelMode {
    #[inline]
    #[doc(alias = "nm_ip_tunnel_mode_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_ip_tunnel_mode_get_type()) }
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
impl glib::HasParamSpec for IPTunnelMode {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
impl glib::value::ValueType for IPTunnelMode {
    type Type = Self;
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
unsafe impl<'a> glib::value::FromValue<'a> for IPTunnelMode {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
impl ToValue for IPTunnelMode {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
impl From<IPTunnelMode> for glib::Value {
    #[inline]
    fn from(v: IPTunnelMode) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// The type of the callback for `NMKeyfileReadHandler` and `NMKeyfileWriteHandler`.
/// Depending on the type, you can interpret `NMKeyfileHandlerData`.
#[cfg(feature = "v1_30")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMKeyfileHandlerType")]
pub enum KeyfileHandlerType {
    /// a warning.
    #[doc(alias = "NM_KEYFILE_HANDLER_TYPE_WARN")]
    Warn,
    /// for handling certificates while writing
    ///   a connection to keyfile.
    #[doc(alias = "NM_KEYFILE_HANDLER_TYPE_WRITE_CERT")]
    WriteCert,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v1_30")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
#[doc(hidden)]
impl IntoGlib for KeyfileHandlerType {
    type GlibType = ffi::NMKeyfileHandlerType;

    #[inline]
    fn into_glib(self) -> ffi::NMKeyfileHandlerType {
        match self {
            Self::Warn => ffi::NM_KEYFILE_HANDLER_TYPE_WARN,
            Self::WriteCert => ffi::NM_KEYFILE_HANDLER_TYPE_WRITE_CERT,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v1_30")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
#[doc(hidden)]
impl FromGlib<ffi::NMKeyfileHandlerType> for KeyfileHandlerType {
    #[inline]
    unsafe fn from_glib(value: ffi::NMKeyfileHandlerType) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_KEYFILE_HANDLER_TYPE_WARN => Self::Warn,
            ffi::NM_KEYFILE_HANDLER_TYPE_WRITE_CERT => Self::WriteCert,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v1_30")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
impl StaticType for KeyfileHandlerType {
    #[inline]
    #[doc(alias = "nm_keyfile_handler_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_keyfile_handler_type_get_type()) }
    }
}

#[cfg(feature = "v1_30")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
impl glib::HasParamSpec for KeyfileHandlerType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v1_30")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
impl glib::value::ValueType for KeyfileHandlerType {
    type Type = Self;
}

#[cfg(feature = "v1_30")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
unsafe impl<'a> glib::value::FromValue<'a> for KeyfileHandlerType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_30")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
impl ToValue for KeyfileHandlerType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_30")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
impl From<KeyfileHandlerType> for glib::Value {
    #[inline]
    fn from(v: KeyfileHandlerType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// The severity level of [`KeyfileHandlerType::Warn`][crate::KeyfileHandlerType::Warn] events.
#[cfg(feature = "v1_30")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMKeyfileWarnSeverity")]
pub enum KeyfileWarnSeverity {
    /// debug message
    #[doc(alias = "NM_KEYFILE_WARN_SEVERITY_DEBUG")]
    Debug,
    /// info message
    #[doc(alias = "NM_KEYFILE_WARN_SEVERITY_INFO")]
    Info,
    /// info message about a missing file
    #[doc(alias = "NM_KEYFILE_WARN_SEVERITY_INFO_MISSING_FILE")]
    InfoMissingFile,
    /// a warning message
    #[doc(alias = "NM_KEYFILE_WARN_SEVERITY_WARN")]
    Warn,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v1_30")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
#[doc(hidden)]
impl IntoGlib for KeyfileWarnSeverity {
    type GlibType = ffi::NMKeyfileWarnSeverity;

    #[inline]
    fn into_glib(self) -> ffi::NMKeyfileWarnSeverity {
        match self {
            Self::Debug => ffi::NM_KEYFILE_WARN_SEVERITY_DEBUG,
            Self::Info => ffi::NM_KEYFILE_WARN_SEVERITY_INFO,
            Self::InfoMissingFile => ffi::NM_KEYFILE_WARN_SEVERITY_INFO_MISSING_FILE,
            Self::Warn => ffi::NM_KEYFILE_WARN_SEVERITY_WARN,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v1_30")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
#[doc(hidden)]
impl FromGlib<ffi::NMKeyfileWarnSeverity> for KeyfileWarnSeverity {
    #[inline]
    unsafe fn from_glib(value: ffi::NMKeyfileWarnSeverity) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_KEYFILE_WARN_SEVERITY_DEBUG => Self::Debug,
            ffi::NM_KEYFILE_WARN_SEVERITY_INFO => Self::Info,
            ffi::NM_KEYFILE_WARN_SEVERITY_INFO_MISSING_FILE => Self::InfoMissingFile,
            ffi::NM_KEYFILE_WARN_SEVERITY_WARN => Self::Warn,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v1_30")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
impl StaticType for KeyfileWarnSeverity {
    #[inline]
    #[doc(alias = "nm_keyfile_warn_severity_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_keyfile_warn_severity_get_type()) }
    }
}

#[cfg(feature = "v1_30")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
impl glib::HasParamSpec for KeyfileWarnSeverity {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v1_30")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
impl glib::value::ValueType for KeyfileWarnSeverity {
    type Type = Self;
}

#[cfg(feature = "v1_30")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
unsafe impl<'a> glib::value::FromValue<'a> for KeyfileWarnSeverity {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_30")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
impl ToValue for KeyfileWarnSeverity {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_30")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
impl From<KeyfileWarnSeverity> for glib::Value {
    #[inline]
    fn from(v: KeyfileWarnSeverity) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// Errors related to the main "network management" interface of NetworkManager.
/// These may be returned from #NMClient methods that invoke D-Bus operations on
/// the "org.freedesktop.NetworkManager" interface, and correspond to D-Bus
/// errors in that namespace.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMManagerError")]
pub enum ManagerError {
    /// unknown or unclassified error
    #[doc(alias = "NM_MANAGER_ERROR_FAILED")]
    Failed,
    /// Permission denied.
    #[doc(alias = "NM_MANAGER_ERROR_PERMISSION_DENIED")]
    PermissionDenied,
    /// The requested connection is not known.
    #[doc(alias = "NM_MANAGER_ERROR_UNKNOWN_CONNECTION")]
    UnknownConnection,
    /// The requested device is not known.
    #[doc(alias = "NM_MANAGER_ERROR_UNKNOWN_DEVICE")]
    UnknownDevice,
    /// The requested connection cannot be
    ///   activated at this time.
    #[doc(alias = "NM_MANAGER_ERROR_CONNECTION_NOT_AVAILABLE")]
    ConnectionNotAvailable,
    /// The request could not be completed
    ///   because a required connection is not active.
    #[doc(alias = "NM_MANAGER_ERROR_CONNECTION_NOT_ACTIVE")]
    ConnectionNotActive,
    /// The connection to be activated was
    ///   already active on another device.
    #[doc(alias = "NM_MANAGER_ERROR_CONNECTION_ALREADY_ACTIVE")]
    ConnectionAlreadyActive,
    /// An activation request failed due to a
    ///   dependency being unavailable.
    #[doc(alias = "NM_MANAGER_ERROR_DEPENDENCY_FAILED")]
    DependencyFailed,
    /// The manager is already in the requested
    ///   sleep/wake state.
    #[doc(alias = "NM_MANAGER_ERROR_ALREADY_ASLEEP_OR_AWAKE")]
    AlreadyAsleepOrAwake,
    /// The network is already
    ///   enabled/disabled.
    #[doc(alias = "NM_MANAGER_ERROR_ALREADY_ENABLED_OR_DISABLED")]
    AlreadyEnabledOrDisabled,
    /// Unknown log level in SetLogging
    #[doc(alias = "NM_MANAGER_ERROR_UNKNOWN_LOG_LEVEL")]
    UnknownLogLevel,
    /// Unknown log domain in SetLogging
    #[doc(alias = "NM_MANAGER_ERROR_UNKNOWN_LOG_DOMAIN")]
    UnknownLogDomain,
    /// Invalid arguments for D-Bus request
    #[doc(alias = "NM_MANAGER_ERROR_INVALID_ARGUMENTS")]
    InvalidArguments,
    /// A plug-in was needed to complete the
    ///   activation but is not available.
    #[doc(alias = "NM_MANAGER_ERROR_MISSING_PLUGIN")]
    MissingPlugin,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for ManagerError {
    type GlibType = ffi::NMManagerError;

    fn into_glib(self) -> ffi::NMManagerError {
        match self {
            Self::Failed => ffi::NM_MANAGER_ERROR_FAILED,
            Self::PermissionDenied => ffi::NM_MANAGER_ERROR_PERMISSION_DENIED,
            Self::UnknownConnection => ffi::NM_MANAGER_ERROR_UNKNOWN_CONNECTION,
            Self::UnknownDevice => ffi::NM_MANAGER_ERROR_UNKNOWN_DEVICE,
            Self::ConnectionNotAvailable => ffi::NM_MANAGER_ERROR_CONNECTION_NOT_AVAILABLE,
            Self::ConnectionNotActive => ffi::NM_MANAGER_ERROR_CONNECTION_NOT_ACTIVE,
            Self::ConnectionAlreadyActive => ffi::NM_MANAGER_ERROR_CONNECTION_ALREADY_ACTIVE,
            Self::DependencyFailed => ffi::NM_MANAGER_ERROR_DEPENDENCY_FAILED,
            Self::AlreadyAsleepOrAwake => ffi::NM_MANAGER_ERROR_ALREADY_ASLEEP_OR_AWAKE,
            Self::AlreadyEnabledOrDisabled => ffi::NM_MANAGER_ERROR_ALREADY_ENABLED_OR_DISABLED,
            Self::UnknownLogLevel => ffi::NM_MANAGER_ERROR_UNKNOWN_LOG_LEVEL,
            Self::UnknownLogDomain => ffi::NM_MANAGER_ERROR_UNKNOWN_LOG_DOMAIN,
            Self::InvalidArguments => ffi::NM_MANAGER_ERROR_INVALID_ARGUMENTS,
            Self::MissingPlugin => ffi::NM_MANAGER_ERROR_MISSING_PLUGIN,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMManagerError> for ManagerError {
    unsafe fn from_glib(value: ffi::NMManagerError) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_MANAGER_ERROR_FAILED => Self::Failed,
            ffi::NM_MANAGER_ERROR_PERMISSION_DENIED => Self::PermissionDenied,
            ffi::NM_MANAGER_ERROR_UNKNOWN_CONNECTION => Self::UnknownConnection,
            ffi::NM_MANAGER_ERROR_UNKNOWN_DEVICE => Self::UnknownDevice,
            ffi::NM_MANAGER_ERROR_CONNECTION_NOT_AVAILABLE => Self::ConnectionNotAvailable,
            ffi::NM_MANAGER_ERROR_CONNECTION_NOT_ACTIVE => Self::ConnectionNotActive,
            ffi::NM_MANAGER_ERROR_CONNECTION_ALREADY_ACTIVE => Self::ConnectionAlreadyActive,
            ffi::NM_MANAGER_ERROR_DEPENDENCY_FAILED => Self::DependencyFailed,
            ffi::NM_MANAGER_ERROR_ALREADY_ASLEEP_OR_AWAKE => Self::AlreadyAsleepOrAwake,
            ffi::NM_MANAGER_ERROR_ALREADY_ENABLED_OR_DISABLED => Self::AlreadyEnabledOrDisabled,
            ffi::NM_MANAGER_ERROR_UNKNOWN_LOG_LEVEL => Self::UnknownLogLevel,
            ffi::NM_MANAGER_ERROR_UNKNOWN_LOG_DOMAIN => Self::UnknownLogDomain,
            ffi::NM_MANAGER_ERROR_INVALID_ARGUMENTS => Self::InvalidArguments,
            ffi::NM_MANAGER_ERROR_MISSING_PLUGIN => Self::MissingPlugin,
            value => Self::__Unknown(value),
        }
    }
}

impl glib::error::ErrorDomain for ManagerError {
    #[inline]
    fn domain() -> glib::Quark {
        skip_assert_initialized!();

        unsafe { from_glib(ffi::nm_manager_error_quark()) }
    }

    #[inline]
    fn code(self) -> i32 {
        self.into_glib()
    }

    #[inline]
    #[allow(clippy::match_single_binding)]
    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match unsafe { from_glib(code) } {
            Self::__Unknown(_) => Some(Self::Failed),
            value => Some(value),
        }
    }
}

impl StaticType for ManagerError {
    #[inline]
    #[doc(alias = "nm_manager_error_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_manager_error_get_type()) }
    }
}

impl glib::HasParamSpec for ManagerError {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for ManagerError {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for ManagerError {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ManagerError {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<ManagerError> for glib::Value {
    #[inline]
    fn from(v: ManagerError) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// The NMMetered enum has two different purposes: one is to configure
/// "connection.metered" setting of a connection profile in #NMSettingConnection, and
/// the other is to express the actual metered state of the #NMDevice at a given moment.
///
/// For the connection profile only #NM_METERED_UNKNOWN, #NM_METERED_NO
/// and #NM_METERED_YES are allowed.
///
/// The device's metered state at runtime is determined by the profile
/// which is currently active. If the profile explicitly specifies #NM_METERED_NO
/// or #NM_METERED_YES, then the device's metered state is as such.
/// If the connection profile leaves it undecided at #NM_METERED_UNKNOWN (the default),
/// then NetworkManager tries to guess the metered state, for example based on the
/// device type or on DHCP options (like Android devices exposing a "ANDROID_METERED"
/// DHCP vendor option). This then leads to either #NM_METERED_GUESS_NO or #NM_METERED_GUESS_YES.
///
/// Most applications probably should treat the runtime state #NM_METERED_GUESS_YES
/// like #NM_METERED_YES, and all other states as not metered.
///
/// Note that the per-device metered states are then combined to a global metered
/// state. This is basically the metered state of the device with the best default
/// route. However, that generalization of a global metered state may not be correct
/// if the default routes for IPv4 and IPv6 are on different devices, or if policy
/// routing is configured. In general, the global metered state tries to express whether
/// the traffic is likely metered, but since that depends on the traffic itself,
/// there is not one answer in all cases. Hence, an application may want to consider
/// the per-device's metered states.
#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMMetered")]
pub enum Metered {
    /// The metered status is unknown
    #[doc(alias = "NM_METERED_UNKNOWN")]
    Unknown,
    /// Metered, the value was explicitly configured
    #[doc(alias = "NM_METERED_YES")]
    Yes,
    /// Not metered, the value was explicitly configured
    #[doc(alias = "NM_METERED_NO")]
    No,
    /// Metered, the value was guessed
    #[doc(alias = "NM_METERED_GUESS_YES")]
    GuessYes,
    /// Not metered, the value was guessed
    #[doc(alias = "NM_METERED_GUESS_NO")]
    GuessNo,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
#[doc(hidden)]
impl IntoGlib for Metered {
    type GlibType = ffi::NMMetered;

    #[inline]
    fn into_glib(self) -> ffi::NMMetered {
        match self {
            Self::Unknown => ffi::NM_METERED_UNKNOWN,
            Self::Yes => ffi::NM_METERED_YES,
            Self::No => ffi::NM_METERED_NO,
            Self::GuessYes => ffi::NM_METERED_GUESS_YES,
            Self::GuessNo => ffi::NM_METERED_GUESS_NO,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
#[doc(hidden)]
impl FromGlib<ffi::NMMetered> for Metered {
    #[inline]
    unsafe fn from_glib(value: ffi::NMMetered) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_METERED_UNKNOWN => Self::Unknown,
            ffi::NM_METERED_YES => Self::Yes,
            ffi::NM_METERED_NO => Self::No,
            ffi::NM_METERED_GUESS_YES => Self::GuessYes,
            ffi::NM_METERED_GUESS_NO => Self::GuessNo,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
impl StaticType for Metered {
    #[inline]
    #[doc(alias = "nm_metered_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_metered_get_type()) }
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
impl glib::HasParamSpec for Metered {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
impl glib::value::ValueType for Metered {
    type Type = Self;
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
unsafe impl<'a> glib::value::FromValue<'a> for Metered {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
impl ToValue for Metered {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
impl From<Metered> for glib::Value {
    #[inline]
    fn from(v: Metered) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// The result of a checkpoint Rollback() operation for a specific device.
#[cfg(feature = "v1_4")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_4")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMRollbackResult")]
pub enum RollbackResult {
    /// the rollback succeeded.
    #[doc(alias = "NM_ROLLBACK_RESULT_OK")]
    Ok,
    /// the device no longer exists.
    #[doc(alias = "NM_ROLLBACK_RESULT_ERR_NO_DEVICE")]
    ErrNoDevice,
    /// the device is now unmanaged.
    #[doc(alias = "NM_ROLLBACK_RESULT_ERR_DEVICE_UNMANAGED")]
    ErrDeviceUnmanaged,
    /// other errors during rollback.
    #[doc(alias = "NM_ROLLBACK_RESULT_ERR_FAILED")]
    ErrFailed,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v1_4")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_4")))]
#[doc(hidden)]
impl IntoGlib for RollbackResult {
    type GlibType = ffi::NMRollbackResult;

    #[inline]
    fn into_glib(self) -> ffi::NMRollbackResult {
        match self {
            Self::Ok => ffi::NM_ROLLBACK_RESULT_OK,
            Self::ErrNoDevice => ffi::NM_ROLLBACK_RESULT_ERR_NO_DEVICE,
            Self::ErrDeviceUnmanaged => ffi::NM_ROLLBACK_RESULT_ERR_DEVICE_UNMANAGED,
            Self::ErrFailed => ffi::NM_ROLLBACK_RESULT_ERR_FAILED,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v1_4")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_4")))]
#[doc(hidden)]
impl FromGlib<ffi::NMRollbackResult> for RollbackResult {
    #[inline]
    unsafe fn from_glib(value: ffi::NMRollbackResult) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_ROLLBACK_RESULT_OK => Self::Ok,
            ffi::NM_ROLLBACK_RESULT_ERR_NO_DEVICE => Self::ErrNoDevice,
            ffi::NM_ROLLBACK_RESULT_ERR_DEVICE_UNMANAGED => Self::ErrDeviceUnmanaged,
            ffi::NM_ROLLBACK_RESULT_ERR_FAILED => Self::ErrFailed,
            value => Self::__Unknown(value),
        }
    }
}

/// #NMSecretAgentError values are passed by secret agents back to NetworkManager
/// when they encounter problems retrieving secrets on behalf of NM. They
/// correspond to errors in the "org.freedesktop.NetworkManager.SecretManager"
/// namespace.
///
/// Client APIs such as nm_client_activate_connection() will not see these error
/// codes; instead, the secret agent manager will translate them to the
/// corresponding #NMAgentManagerError codes.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSecretAgentError")]
pub enum SecretAgentError {
    /// unknown or unclassified error
    #[doc(alias = "NM_SECRET_AGENT_ERROR_FAILED")]
    Failed,
    /// the caller (ie, NetworkManager) is
    ///   not authorized to make this request
    #[doc(alias = "NM_SECRET_AGENT_ERROR_PERMISSION_DENIED")]
    PermissionDenied,
    /// the connection for which secrets
    ///   were requested is invalid
    #[doc(alias = "NM_SECRET_AGENT_ERROR_INVALID_CONNECTION")]
    InvalidConnection,
    /// the request was canceled by the user
    #[doc(alias = "NM_SECRET_AGENT_ERROR_USER_CANCELED")]
    UserCanceled,
    /// the agent canceled the request
    ///   because it was requested to do so by NetworkManager
    #[doc(alias = "NM_SECRET_AGENT_ERROR_AGENT_CANCELED")]
    AgentCanceled,
    /// the agent cannot find any secrets for this
    ///   connection
    #[doc(alias = "NM_SECRET_AGENT_ERROR_NO_SECRETS")]
    NoSecrets,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for SecretAgentError {
    type GlibType = ffi::NMSecretAgentError;

    #[inline]
    fn into_glib(self) -> ffi::NMSecretAgentError {
        match self {
            Self::Failed => ffi::NM_SECRET_AGENT_ERROR_FAILED,
            Self::PermissionDenied => ffi::NM_SECRET_AGENT_ERROR_PERMISSION_DENIED,
            Self::InvalidConnection => ffi::NM_SECRET_AGENT_ERROR_INVALID_CONNECTION,
            Self::UserCanceled => ffi::NM_SECRET_AGENT_ERROR_USER_CANCELED,
            Self::AgentCanceled => ffi::NM_SECRET_AGENT_ERROR_AGENT_CANCELED,
            Self::NoSecrets => ffi::NM_SECRET_AGENT_ERROR_NO_SECRETS,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMSecretAgentError> for SecretAgentError {
    #[inline]
    unsafe fn from_glib(value: ffi::NMSecretAgentError) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_SECRET_AGENT_ERROR_FAILED => Self::Failed,
            ffi::NM_SECRET_AGENT_ERROR_PERMISSION_DENIED => Self::PermissionDenied,
            ffi::NM_SECRET_AGENT_ERROR_INVALID_CONNECTION => Self::InvalidConnection,
            ffi::NM_SECRET_AGENT_ERROR_USER_CANCELED => Self::UserCanceled,
            ffi::NM_SECRET_AGENT_ERROR_AGENT_CANCELED => Self::AgentCanceled,
            ffi::NM_SECRET_AGENT_ERROR_NO_SECRETS => Self::NoSecrets,
            value => Self::__Unknown(value),
        }
    }
}

impl glib::error::ErrorDomain for SecretAgentError {
    #[inline]
    fn domain() -> glib::Quark {
        skip_assert_initialized!();

        unsafe { from_glib(ffi::nm_secret_agent_error_quark()) }
    }

    #[inline]
    fn code(self) -> i32 {
        self.into_glib()
    }

    #[inline]
    #[allow(clippy::match_single_binding)]
    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match unsafe { from_glib(code) } {
            Self::__Unknown(_) => Some(Self::Failed),
            value => Some(value),
        }
    }
}

impl StaticType for SecretAgentError {
    #[inline]
    #[doc(alias = "nm_secret_agent_error_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_secret_agent_error_get_type()) }
    }
}

impl glib::HasParamSpec for SecretAgentError {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for SecretAgentError {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for SecretAgentError {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for SecretAgentError {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<SecretAgentError> for glib::Value {
    #[inline]
    fn from(v: SecretAgentError) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// #NMSetting8021xCKFormat values indicate the general type of a certificate
/// or private key
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSetting8021xCKFormat")]
pub enum Setting8021xCKFormat {
    /// unknown file format
    #[doc(alias = "NM_SETTING_802_1X_CK_FORMAT_UNKNOWN")]
    Unknown,
    /// file contains an X.509 format certificate
    #[doc(alias = "NM_SETTING_802_1X_CK_FORMAT_X509")]
    X509,
    /// file contains an old-style OpenSSL PEM
    /// or DER private key
    #[doc(alias = "NM_SETTING_802_1X_CK_FORMAT_RAW_KEY")]
    RawKey,
    /// file contains a PKCS#<!-- -->12 certificate
    /// and private key
    #[doc(alias = "NM_SETTING_802_1X_CK_FORMAT_PKCS12")]
    Pkcs12,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for Setting8021xCKFormat {
    type GlibType = ffi::NMSetting8021xCKFormat;

    #[inline]
    fn into_glib(self) -> ffi::NMSetting8021xCKFormat {
        match self {
            Self::Unknown => ffi::NM_SETTING_802_1X_CK_FORMAT_UNKNOWN,
            Self::X509 => ffi::NM_SETTING_802_1X_CK_FORMAT_X509,
            Self::RawKey => ffi::NM_SETTING_802_1X_CK_FORMAT_RAW_KEY,
            Self::Pkcs12 => ffi::NM_SETTING_802_1X_CK_FORMAT_PKCS12,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMSetting8021xCKFormat> for Setting8021xCKFormat {
    #[inline]
    unsafe fn from_glib(value: ffi::NMSetting8021xCKFormat) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_SETTING_802_1X_CK_FORMAT_UNKNOWN => Self::Unknown,
            ffi::NM_SETTING_802_1X_CK_FORMAT_X509 => Self::X509,
            ffi::NM_SETTING_802_1X_CK_FORMAT_RAW_KEY => Self::RawKey,
            ffi::NM_SETTING_802_1X_CK_FORMAT_PKCS12 => Self::Pkcs12,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for Setting8021xCKFormat {
    #[inline]
    #[doc(alias = "nm_setting_802_1x_ck_format_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_setting_802_1x_ck_format_get_type()) }
    }
}

impl glib::HasParamSpec for Setting8021xCKFormat {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for Setting8021xCKFormat {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for Setting8021xCKFormat {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for Setting8021xCKFormat {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<Setting8021xCKFormat> for glib::Value {
    #[inline]
    fn from(v: Setting8021xCKFormat) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// #NMSetting8021xCKScheme values indicate how a certificate or private key is
/// stored in the setting properties, either as a blob of the item's data, or as
/// a path to a certificate or private key file on the filesystem
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSetting8021xCKScheme")]
pub enum Setting8021xCKScheme {
    /// unknown certificate or private key
    /// scheme
    #[doc(alias = "NM_SETTING_802_1X_CK_SCHEME_UNKNOWN")]
    Unknown,
    /// certificate or key is stored as the raw
    /// item data
    #[doc(alias = "NM_SETTING_802_1X_CK_SCHEME_BLOB")]
    Blob,
    /// certificate or key is stored as a path
    /// to a file containing the certificate or key data
    #[doc(alias = "NM_SETTING_802_1X_CK_SCHEME_PATH")]
    Path,
    /// certificate or key is stored as a
    /// URI of an object on a PKCS#11 token
    #[doc(alias = "NM_SETTING_802_1X_CK_SCHEME_PKCS11")]
    Pkcs11,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for Setting8021xCKScheme {
    type GlibType = ffi::NMSetting8021xCKScheme;

    #[inline]
    fn into_glib(self) -> ffi::NMSetting8021xCKScheme {
        match self {
            Self::Unknown => ffi::NM_SETTING_802_1X_CK_SCHEME_UNKNOWN,
            Self::Blob => ffi::NM_SETTING_802_1X_CK_SCHEME_BLOB,
            Self::Path => ffi::NM_SETTING_802_1X_CK_SCHEME_PATH,
            Self::Pkcs11 => ffi::NM_SETTING_802_1X_CK_SCHEME_PKCS11,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMSetting8021xCKScheme> for Setting8021xCKScheme {
    #[inline]
    unsafe fn from_glib(value: ffi::NMSetting8021xCKScheme) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_SETTING_802_1X_CK_SCHEME_UNKNOWN => Self::Unknown,
            ffi::NM_SETTING_802_1X_CK_SCHEME_BLOB => Self::Blob,
            ffi::NM_SETTING_802_1X_CK_SCHEME_PATH => Self::Path,
            ffi::NM_SETTING_802_1X_CK_SCHEME_PKCS11 => Self::Pkcs11,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for Setting8021xCKScheme {
    #[inline]
    #[doc(alias = "nm_setting_802_1x_ck_scheme_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_setting_802_1x_ck_scheme_get_type()) }
    }
}

impl glib::HasParamSpec for Setting8021xCKScheme {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for Setting8021xCKScheme {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for Setting8021xCKScheme {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for Setting8021xCKScheme {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<Setting8021xCKScheme> for glib::Value {
    #[inline]
    fn from(v: Setting8021xCKScheme) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// These flags modify the comparison behavior when comparing two settings or
/// two connections.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSettingCompareFlags")]
pub enum SettingCompareFlags {
    /// match all properties exactly
    #[doc(alias = "NM_SETTING_COMPARE_FLAG_EXACT")]
    Exact,
    /// match only important attributes, like SSID,
    ///   type, security settings, etc.  Does not match, for example, connection ID
    ///   or UUID.
    #[doc(alias = "NM_SETTING_COMPARE_FLAG_FUZZY")]
    Fuzzy,
    /// ignore the connection's ID
    #[doc(alias = "NM_SETTING_COMPARE_FLAG_IGNORE_ID")]
    IgnoreId,
    /// ignore all secrets
    #[doc(alias = "NM_SETTING_COMPARE_FLAG_IGNORE_SECRETS")]
    IgnoreSecrets,
    /// ignore secrets for which
    ///   the secret's flags indicate the secret is owned by a user secret agent
    ///   (ie, the secret's flag includes @NM_SETTING_SECRET_FLAG_AGENT_OWNED)
    #[doc(alias = "NM_SETTING_COMPARE_FLAG_IGNORE_AGENT_OWNED_SECRETS")]
    IgnoreAgentOwnedSecrets,
    /// ignore secrets for which
    ///   the secret's flags indicate the secret should not be saved to persistent
    ///   storage (ie, the secret's flag includes @NM_SETTING_SECRET_FLAG_NOT_SAVED)
    #[doc(alias = "NM_SETTING_COMPARE_FLAG_IGNORE_NOT_SAVED_SECRETS")]
    IgnoreNotSavedSecrets,
    /// if this flag is set,
    ///   nm_setting_diff() and nm_connection_diff() will also include properties that
    ///   are set to their default value. See also @NM_SETTING_COMPARE_FLAG_DIFF_RESULT_NO_DEFAULT.
    #[doc(alias = "NM_SETTING_COMPARE_FLAG_DIFF_RESULT_WITH_DEFAULT")]
    DiffResultWithDefault,
    /// if this flag is set,
    ///   nm_setting_diff() and nm_connection_diff() will not include properties that
    ///   are set to their default value. This is the opposite of
    ///   @NM_SETTING_COMPARE_FLAG_DIFF_RESULT_WITH_DEFAULT. If both flags are set together,
    ///   @NM_SETTING_COMPARE_FLAG_DIFF_RESULT_WITH_DEFAULT wins. If both flags are unset,
    ///   this means to exclude default properties if there is a setting to compare,
    ///   but include all properties, if the setting 'b' is missing. This is the legacy
    ///   behaviour of libnm-util, where nm_setting_diff() behaved differently depending
    ///   on whether the setting 'b' was available. If @NM_SETTING_COMPARE_FLAG_DIFF_RESULT_WITH_DEFAULT
    ///   is set, nm_setting_diff() will also set the flags @NM_SETTING_DIFF_RESULT_IN_A_DEFAULT
    ///   and @NM_SETTING_DIFF_RESULT_IN_B_DEFAULT, if the values are default values.
    #[doc(alias = "NM_SETTING_COMPARE_FLAG_DIFF_RESULT_NO_DEFAULT")]
    DiffResultNoDefault,
    /// ignore the connection's timestamp
    #[doc(alias = "NM_SETTING_COMPARE_FLAG_IGNORE_TIMESTAMP")]
    IgnoreTimestamp,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for SettingCompareFlags {
    type GlibType = ffi::NMSettingCompareFlags;

    #[inline]
    fn into_glib(self) -> ffi::NMSettingCompareFlags {
        match self {
            Self::Exact => ffi::NM_SETTING_COMPARE_FLAG_EXACT,
            Self::Fuzzy => ffi::NM_SETTING_COMPARE_FLAG_FUZZY,
            Self::IgnoreId => ffi::NM_SETTING_COMPARE_FLAG_IGNORE_ID,
            Self::IgnoreSecrets => ffi::NM_SETTING_COMPARE_FLAG_IGNORE_SECRETS,
            Self::IgnoreAgentOwnedSecrets => {
                ffi::NM_SETTING_COMPARE_FLAG_IGNORE_AGENT_OWNED_SECRETS
            }
            Self::IgnoreNotSavedSecrets => ffi::NM_SETTING_COMPARE_FLAG_IGNORE_NOT_SAVED_SECRETS,
            Self::DiffResultWithDefault => ffi::NM_SETTING_COMPARE_FLAG_DIFF_RESULT_WITH_DEFAULT,
            Self::DiffResultNoDefault => ffi::NM_SETTING_COMPARE_FLAG_DIFF_RESULT_NO_DEFAULT,
            Self::IgnoreTimestamp => ffi::NM_SETTING_COMPARE_FLAG_IGNORE_TIMESTAMP,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMSettingCompareFlags> for SettingCompareFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::NMSettingCompareFlags) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_SETTING_COMPARE_FLAG_EXACT => Self::Exact,
            ffi::NM_SETTING_COMPARE_FLAG_FUZZY => Self::Fuzzy,
            ffi::NM_SETTING_COMPARE_FLAG_IGNORE_ID => Self::IgnoreId,
            ffi::NM_SETTING_COMPARE_FLAG_IGNORE_SECRETS => Self::IgnoreSecrets,
            ffi::NM_SETTING_COMPARE_FLAG_IGNORE_AGENT_OWNED_SECRETS => {
                Self::IgnoreAgentOwnedSecrets
            }
            ffi::NM_SETTING_COMPARE_FLAG_IGNORE_NOT_SAVED_SECRETS => Self::IgnoreNotSavedSecrets,
            ffi::NM_SETTING_COMPARE_FLAG_DIFF_RESULT_WITH_DEFAULT => Self::DiffResultWithDefault,
            ffi::NM_SETTING_COMPARE_FLAG_DIFF_RESULT_NO_DEFAULT => Self::DiffResultNoDefault,
            ffi::NM_SETTING_COMPARE_FLAG_IGNORE_TIMESTAMP => Self::IgnoreTimestamp,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for SettingCompareFlags {
    #[inline]
    #[doc(alias = "nm_setting_compare_flags_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_setting_compare_flags_get_type()) }
    }
}

impl glib::HasParamSpec for SettingCompareFlags {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for SettingCompareFlags {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for SettingCompareFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for SettingCompareFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<SettingCompareFlags> for glib::Value {
    #[inline]
    fn from(v: SettingCompareFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// #NMSettingConnectionAutoconnectSlaves values indicate whether slave connections
/// should be activated when controller is activated.
///
/// # Deprecated since 1.46
///
#[cfg_attr(feature = "v1_46", deprecated = "Since 1.46")]
#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSettingConnectionAutoconnectSlaves")]
pub enum SettingConnectionAutoconnectSlaves {
    /// default value
    #[doc(alias = "NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_DEFAULT")]
    Default,
    /// slaves are not brought up when
    ///   controller is activated
    #[doc(alias = "NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_NO")]
    No,
    /// slaves are brought up when
    ///   controller is activated
    #[doc(alias = "NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_YES")]
    Yes,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
#[allow(deprecated)]
#[doc(hidden)]
impl IntoGlib for SettingConnectionAutoconnectSlaves {
    type GlibType = ffi::NMSettingConnectionAutoconnectSlaves;

    #[inline]
    fn into_glib(self) -> ffi::NMSettingConnectionAutoconnectSlaves {
        match self {
            Self::Default => ffi::NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_DEFAULT,
            Self::No => ffi::NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_NO,
            Self::Yes => ffi::NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_YES,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
#[allow(deprecated)]
#[doc(hidden)]
impl FromGlib<ffi::NMSettingConnectionAutoconnectSlaves> for SettingConnectionAutoconnectSlaves {
    #[inline]
    unsafe fn from_glib(value: ffi::NMSettingConnectionAutoconnectSlaves) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_DEFAULT => Self::Default,
            ffi::NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_NO => Self::No,
            ffi::NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_YES => Self::Yes,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
#[allow(deprecated)]
impl StaticType for SettingConnectionAutoconnectSlaves {
    #[inline]
    #[doc(alias = "nm_setting_connection_autoconnect_slaves_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_setting_connection_autoconnect_slaves_get_type()) }
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
#[allow(deprecated)]
impl glib::HasParamSpec for SettingConnectionAutoconnectSlaves {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
#[allow(deprecated)]
impl glib::value::ValueType for SettingConnectionAutoconnectSlaves {
    type Type = Self;
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
#[allow(deprecated)]
unsafe impl<'a> glib::value::FromValue<'a> for SettingConnectionAutoconnectSlaves {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
#[allow(deprecated)]
impl ToValue for SettingConnectionAutoconnectSlaves {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
#[allow(deprecated)]
impl From<SettingConnectionAutoconnectSlaves> for glib::Value {
    #[inline]
    fn from(v: SettingConnectionAutoconnectSlaves) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// #NMSettingConnectionDnsOverTls values indicate whether DNSOverTls should be enabled.
#[cfg(feature = "v1_34")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_34")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSettingConnectionDnsOverTls")]
pub enum SettingConnectionDnsOverTls {
    /// default value
    #[doc(alias = "NM_SETTING_CONNECTION_DNS_OVER_TLS_DEFAULT")]
    Default,
    /// disable DNSOverTls
    #[doc(alias = "NM_SETTING_CONNECTION_DNS_OVER_TLS_NO")]
    No,
    /// enable opportunistic mode
    #[doc(alias = "NM_SETTING_CONNECTION_DNS_OVER_TLS_OPPORTUNISTIC")]
    Opportunistic,
    /// enable strict mode
    #[doc(alias = "NM_SETTING_CONNECTION_DNS_OVER_TLS_YES")]
    Yes,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v1_34")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_34")))]
#[doc(hidden)]
impl IntoGlib for SettingConnectionDnsOverTls {
    type GlibType = ffi::NMSettingConnectionDnsOverTls;

    #[inline]
    fn into_glib(self) -> ffi::NMSettingConnectionDnsOverTls {
        match self {
            Self::Default => ffi::NM_SETTING_CONNECTION_DNS_OVER_TLS_DEFAULT,
            Self::No => ffi::NM_SETTING_CONNECTION_DNS_OVER_TLS_NO,
            Self::Opportunistic => ffi::NM_SETTING_CONNECTION_DNS_OVER_TLS_OPPORTUNISTIC,
            Self::Yes => ffi::NM_SETTING_CONNECTION_DNS_OVER_TLS_YES,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v1_34")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_34")))]
#[doc(hidden)]
impl FromGlib<ffi::NMSettingConnectionDnsOverTls> for SettingConnectionDnsOverTls {
    #[inline]
    unsafe fn from_glib(value: ffi::NMSettingConnectionDnsOverTls) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_SETTING_CONNECTION_DNS_OVER_TLS_DEFAULT => Self::Default,
            ffi::NM_SETTING_CONNECTION_DNS_OVER_TLS_NO => Self::No,
            ffi::NM_SETTING_CONNECTION_DNS_OVER_TLS_OPPORTUNISTIC => Self::Opportunistic,
            ffi::NM_SETTING_CONNECTION_DNS_OVER_TLS_YES => Self::Yes,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v1_34")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_34")))]
impl StaticType for SettingConnectionDnsOverTls {
    #[inline]
    #[doc(alias = "nm_setting_connection_dns_over_tls_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_setting_connection_dns_over_tls_get_type()) }
    }
}

#[cfg(feature = "v1_34")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_34")))]
impl glib::HasParamSpec for SettingConnectionDnsOverTls {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v1_34")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_34")))]
impl glib::value::ValueType for SettingConnectionDnsOverTls {
    type Type = Self;
}

#[cfg(feature = "v1_34")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_34")))]
unsafe impl<'a> glib::value::FromValue<'a> for SettingConnectionDnsOverTls {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_34")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_34")))]
impl ToValue for SettingConnectionDnsOverTls {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_34")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_34")))]
impl From<SettingConnectionDnsOverTls> for glib::Value {
    #[inline]
    fn from(v: SettingConnectionDnsOverTls) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// #NMSettingConnectionDownOnPoweroff indicates whether the connection will be
/// brought down before the system is powered off.
#[cfg(feature = "v1_48")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_48")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSettingConnectionDownOnPoweroff")]
pub enum SettingConnectionDownOnPoweroff {
    /// default value
    #[doc(alias = "NM_SETTING_CONNECTION_DOWN_ON_POWEROFF_DEFAULT")]
    Default,
    /// disable down-on-poweroff
    #[doc(alias = "NM_SETTING_CONNECTION_DOWN_ON_POWEROFF_NO")]
    No,
    /// enable down-on-poweroff
    #[doc(alias = "NM_SETTING_CONNECTION_DOWN_ON_POWEROFF_YES")]
    Yes,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v1_48")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_48")))]
#[doc(hidden)]
impl IntoGlib for SettingConnectionDownOnPoweroff {
    type GlibType = ffi::NMSettingConnectionDownOnPoweroff;

    #[inline]
    fn into_glib(self) -> ffi::NMSettingConnectionDownOnPoweroff {
        match self {
            Self::Default => ffi::NM_SETTING_CONNECTION_DOWN_ON_POWEROFF_DEFAULT,
            Self::No => ffi::NM_SETTING_CONNECTION_DOWN_ON_POWEROFF_NO,
            Self::Yes => ffi::NM_SETTING_CONNECTION_DOWN_ON_POWEROFF_YES,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v1_48")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_48")))]
#[doc(hidden)]
impl FromGlib<ffi::NMSettingConnectionDownOnPoweroff> for SettingConnectionDownOnPoweroff {
    #[inline]
    unsafe fn from_glib(value: ffi::NMSettingConnectionDownOnPoweroff) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_SETTING_CONNECTION_DOWN_ON_POWEROFF_DEFAULT => Self::Default,
            ffi::NM_SETTING_CONNECTION_DOWN_ON_POWEROFF_NO => Self::No,
            ffi::NM_SETTING_CONNECTION_DOWN_ON_POWEROFF_YES => Self::Yes,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v1_48")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_48")))]
impl StaticType for SettingConnectionDownOnPoweroff {
    #[inline]
    #[doc(alias = "nm_setting_connection_down_on_poweroff_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_setting_connection_down_on_poweroff_get_type()) }
    }
}

#[cfg(feature = "v1_48")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_48")))]
impl glib::HasParamSpec for SettingConnectionDownOnPoweroff {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v1_48")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_48")))]
impl glib::value::ValueType for SettingConnectionDownOnPoweroff {
    type Type = Self;
}

#[cfg(feature = "v1_48")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_48")))]
unsafe impl<'a> glib::value::FromValue<'a> for SettingConnectionDownOnPoweroff {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_48")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_48")))]
impl ToValue for SettingConnectionDownOnPoweroff {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_48")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_48")))]
impl From<SettingConnectionDownOnPoweroff> for glib::Value {
    #[inline]
    fn from(v: SettingConnectionDownOnPoweroff) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// #NMSettingConnectionLldp values indicate whether LLDP should be enabled.
#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSettingConnectionLldp")]
pub enum SettingConnectionLldp {
    /// default value
    #[doc(alias = "NM_SETTING_CONNECTION_LLDP_DEFAULT")]
    Default,
    /// disable LLDP
    #[doc(alias = "NM_SETTING_CONNECTION_LLDP_DISABLE")]
    Disable,
    /// enable reception of LLDP frames
    #[doc(alias = "NM_SETTING_CONNECTION_LLDP_ENABLE_RX")]
    EnableRx,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
#[doc(hidden)]
impl IntoGlib for SettingConnectionLldp {
    type GlibType = ffi::NMSettingConnectionLldp;

    #[inline]
    fn into_glib(self) -> ffi::NMSettingConnectionLldp {
        match self {
            Self::Default => ffi::NM_SETTING_CONNECTION_LLDP_DEFAULT,
            Self::Disable => ffi::NM_SETTING_CONNECTION_LLDP_DISABLE,
            Self::EnableRx => ffi::NM_SETTING_CONNECTION_LLDP_ENABLE_RX,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
#[doc(hidden)]
impl FromGlib<ffi::NMSettingConnectionLldp> for SettingConnectionLldp {
    #[inline]
    unsafe fn from_glib(value: ffi::NMSettingConnectionLldp) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_SETTING_CONNECTION_LLDP_DEFAULT => Self::Default,
            ffi::NM_SETTING_CONNECTION_LLDP_DISABLE => Self::Disable,
            ffi::NM_SETTING_CONNECTION_LLDP_ENABLE_RX => Self::EnableRx,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
impl StaticType for SettingConnectionLldp {
    #[inline]
    #[doc(alias = "nm_setting_connection_lldp_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_setting_connection_lldp_get_type()) }
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
impl glib::HasParamSpec for SettingConnectionLldp {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
impl glib::value::ValueType for SettingConnectionLldp {
    type Type = Self;
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
unsafe impl<'a> glib::value::FromValue<'a> for SettingConnectionLldp {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
impl ToValue for SettingConnectionLldp {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
impl From<SettingConnectionLldp> for glib::Value {
    #[inline]
    fn from(v: SettingConnectionLldp) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// #NMSettingConnectionLlmnr values indicate whether LLMNR should be enabled.
#[cfg(feature = "v1_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSettingConnectionLlmnr")]
pub enum SettingConnectionLlmnr {
    /// default value
    #[doc(alias = "NM_SETTING_CONNECTION_LLMNR_DEFAULT")]
    Default,
    /// disable LLMNR
    #[doc(alias = "NM_SETTING_CONNECTION_LLMNR_NO")]
    No,
    /// support only resolving, do not register hostname
    #[doc(alias = "NM_SETTING_CONNECTION_LLMNR_RESOLVE")]
    Resolve,
    /// enable LLMNR
    #[doc(alias = "NM_SETTING_CONNECTION_LLMNR_YES")]
    Yes,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v1_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
#[doc(hidden)]
impl IntoGlib for SettingConnectionLlmnr {
    type GlibType = ffi::NMSettingConnectionLlmnr;

    #[inline]
    fn into_glib(self) -> ffi::NMSettingConnectionLlmnr {
        match self {
            Self::Default => ffi::NM_SETTING_CONNECTION_LLMNR_DEFAULT,
            Self::No => ffi::NM_SETTING_CONNECTION_LLMNR_NO,
            Self::Resolve => ffi::NM_SETTING_CONNECTION_LLMNR_RESOLVE,
            Self::Yes => ffi::NM_SETTING_CONNECTION_LLMNR_YES,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v1_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
#[doc(hidden)]
impl FromGlib<ffi::NMSettingConnectionLlmnr> for SettingConnectionLlmnr {
    #[inline]
    unsafe fn from_glib(value: ffi::NMSettingConnectionLlmnr) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_SETTING_CONNECTION_LLMNR_DEFAULT => Self::Default,
            ffi::NM_SETTING_CONNECTION_LLMNR_NO => Self::No,
            ffi::NM_SETTING_CONNECTION_LLMNR_RESOLVE => Self::Resolve,
            ffi::NM_SETTING_CONNECTION_LLMNR_YES => Self::Yes,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v1_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
impl StaticType for SettingConnectionLlmnr {
    #[inline]
    #[doc(alias = "nm_setting_connection_llmnr_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_setting_connection_llmnr_get_type()) }
    }
}

#[cfg(feature = "v1_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
impl glib::HasParamSpec for SettingConnectionLlmnr {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v1_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
impl glib::value::ValueType for SettingConnectionLlmnr {
    type Type = Self;
}

#[cfg(feature = "v1_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
unsafe impl<'a> glib::value::FromValue<'a> for SettingConnectionLlmnr {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
impl ToValue for SettingConnectionLlmnr {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
impl From<SettingConnectionLlmnr> for glib::Value {
    #[inline]
    fn from(v: SettingConnectionLlmnr) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// #NMSettingConnectionMdns values indicate whether mDNS should be enabled.
#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSettingConnectionMdns")]
pub enum SettingConnectionMdns {
    /// default value
    #[doc(alias = "NM_SETTING_CONNECTION_MDNS_DEFAULT")]
    Default,
    /// disable mDNS
    #[doc(alias = "NM_SETTING_CONNECTION_MDNS_NO")]
    No,
    /// support only resolving, do not register hostname
    #[doc(alias = "NM_SETTING_CONNECTION_MDNS_RESOLVE")]
    Resolve,
    /// enable mDNS
    #[doc(alias = "NM_SETTING_CONNECTION_MDNS_YES")]
    Yes,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
#[doc(hidden)]
impl IntoGlib for SettingConnectionMdns {
    type GlibType = ffi::NMSettingConnectionMdns;

    #[inline]
    fn into_glib(self) -> ffi::NMSettingConnectionMdns {
        match self {
            Self::Default => ffi::NM_SETTING_CONNECTION_MDNS_DEFAULT,
            Self::No => ffi::NM_SETTING_CONNECTION_MDNS_NO,
            Self::Resolve => ffi::NM_SETTING_CONNECTION_MDNS_RESOLVE,
            Self::Yes => ffi::NM_SETTING_CONNECTION_MDNS_YES,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
#[doc(hidden)]
impl FromGlib<ffi::NMSettingConnectionMdns> for SettingConnectionMdns {
    #[inline]
    unsafe fn from_glib(value: ffi::NMSettingConnectionMdns) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_SETTING_CONNECTION_MDNS_DEFAULT => Self::Default,
            ffi::NM_SETTING_CONNECTION_MDNS_NO => Self::No,
            ffi::NM_SETTING_CONNECTION_MDNS_RESOLVE => Self::Resolve,
            ffi::NM_SETTING_CONNECTION_MDNS_YES => Self::Yes,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
impl StaticType for SettingConnectionMdns {
    #[inline]
    #[doc(alias = "nm_setting_connection_mdns_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_setting_connection_mdns_get_type()) }
    }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
impl glib::HasParamSpec for SettingConnectionMdns {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
impl glib::value::ValueType for SettingConnectionMdns {
    type Type = Self;
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
unsafe impl<'a> glib::value::FromValue<'a> for SettingConnectionMdns {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
impl ToValue for SettingConnectionMdns {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
impl From<SettingConnectionMdns> for glib::Value {
    #[inline]
    fn from(v: SettingConnectionMdns) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// These values indicate the result of a setting difference operation.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSettingDiffResult")]
pub enum SettingDiffResult {
    /// unknown result
    #[doc(alias = "NM_SETTING_DIFF_RESULT_UNKNOWN")]
    Unknown,
    /// the property is present in setting A
    #[doc(alias = "NM_SETTING_DIFF_RESULT_IN_A")]
    InA,
    /// the property is present in setting B
    #[doc(alias = "NM_SETTING_DIFF_RESULT_IN_B")]
    InB,
    /// the property is present in
    /// setting A but is set to the default value. This flag is only set,
    /// if you specify @NM_SETTING_COMPARE_FLAG_DIFF_RESULT_WITH_DEFAULT.
    #[doc(alias = "NM_SETTING_DIFF_RESULT_IN_A_DEFAULT")]
    InADefault,
    /// analog to @NM_SETTING_DIFF_RESULT_IN_A_DEFAULT.
    #[doc(alias = "NM_SETTING_DIFF_RESULT_IN_B_DEFAULT")]
    InBDefault,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for SettingDiffResult {
    type GlibType = ffi::NMSettingDiffResult;

    #[inline]
    fn into_glib(self) -> ffi::NMSettingDiffResult {
        match self {
            Self::Unknown => ffi::NM_SETTING_DIFF_RESULT_UNKNOWN,
            Self::InA => ffi::NM_SETTING_DIFF_RESULT_IN_A,
            Self::InB => ffi::NM_SETTING_DIFF_RESULT_IN_B,
            Self::InADefault => ffi::NM_SETTING_DIFF_RESULT_IN_A_DEFAULT,
            Self::InBDefault => ffi::NM_SETTING_DIFF_RESULT_IN_B_DEFAULT,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMSettingDiffResult> for SettingDiffResult {
    #[inline]
    unsafe fn from_glib(value: ffi::NMSettingDiffResult) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_SETTING_DIFF_RESULT_UNKNOWN => Self::Unknown,
            ffi::NM_SETTING_DIFF_RESULT_IN_A => Self::InA,
            ffi::NM_SETTING_DIFF_RESULT_IN_B => Self::InB,
            ffi::NM_SETTING_DIFF_RESULT_IN_A_DEFAULT => Self::InADefault,
            ffi::NM_SETTING_DIFF_RESULT_IN_B_DEFAULT => Self::InBDefault,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for SettingDiffResult {
    #[inline]
    #[doc(alias = "nm_setting_diff_result_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_setting_diff_result_get_type()) }
    }
}

impl glib::HasParamSpec for SettingDiffResult {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for SettingDiffResult {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for SettingDiffResult {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for SettingDiffResult {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<SettingDiffResult> for glib::Value {
    #[inline]
    fn from(v: SettingDiffResult) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// #NMSettingIP4DhcpIpv6OnlyPreferred values specify if the "IPv6-Only Preferred"
/// option (RFC 8925) for DHCPv4 is enabled.
#[cfg(feature = "v1_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSettingIP4DhcpIpv6OnlyPreferred")]
pub enum SettingIP4DhcpIpv6OnlyPreferred {
    /// use the global default value
    #[doc(alias = "NM_SETTING_IP4_DHCP_IPV6_ONLY_PREFERRED_DEFAULT")]
    Default,
    /// the option is disabled
    #[doc(alias = "NM_SETTING_IP4_DHCP_IPV6_ONLY_PREFERRED_NO")]
    No,
    /// the option is enabled
    #[doc(alias = "NM_SETTING_IP4_DHCP_IPV6_ONLY_PREFERRED_YES")]
    Yes,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v1_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
#[doc(hidden)]
impl IntoGlib for SettingIP4DhcpIpv6OnlyPreferred {
    type GlibType = ffi::NMSettingIP4DhcpIpv6OnlyPreferred;

    #[inline]
    fn into_glib(self) -> ffi::NMSettingIP4DhcpIpv6OnlyPreferred {
        match self {
            Self::Default => ffi::NM_SETTING_IP4_DHCP_IPV6_ONLY_PREFERRED_DEFAULT,
            Self::No => ffi::NM_SETTING_IP4_DHCP_IPV6_ONLY_PREFERRED_NO,
            Self::Yes => ffi::NM_SETTING_IP4_DHCP_IPV6_ONLY_PREFERRED_YES,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v1_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
#[doc(hidden)]
impl FromGlib<ffi::NMSettingIP4DhcpIpv6OnlyPreferred> for SettingIP4DhcpIpv6OnlyPreferred {
    #[inline]
    unsafe fn from_glib(value: ffi::NMSettingIP4DhcpIpv6OnlyPreferred) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_SETTING_IP4_DHCP_IPV6_ONLY_PREFERRED_DEFAULT => Self::Default,
            ffi::NM_SETTING_IP4_DHCP_IPV6_ONLY_PREFERRED_NO => Self::No,
            ffi::NM_SETTING_IP4_DHCP_IPV6_ONLY_PREFERRED_YES => Self::Yes,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v1_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
impl StaticType for SettingIP4DhcpIpv6OnlyPreferred {
    #[inline]
    #[doc(alias = "nm_setting_ip4_dhcp_ipv6_only_preferred_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_setting_ip4_dhcp_ipv6_only_preferred_get_type()) }
    }
}

#[cfg(feature = "v1_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
impl glib::HasParamSpec for SettingIP4DhcpIpv6OnlyPreferred {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v1_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
impl glib::value::ValueType for SettingIP4DhcpIpv6OnlyPreferred {
    type Type = Self;
}

#[cfg(feature = "v1_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
unsafe impl<'a> glib::value::FromValue<'a> for SettingIP4DhcpIpv6OnlyPreferred {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
impl ToValue for SettingIP4DhcpIpv6OnlyPreferred {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
impl From<SettingIP4DhcpIpv6OnlyPreferred> for glib::Value {
    #[inline]
    fn from(v: SettingIP4DhcpIpv6OnlyPreferred) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// #NMSettingIP4LinkLocal values indicate whether IPv4 link-local address protocol should be enabled.
#[cfg(feature = "v1_40")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_40")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSettingIP4LinkLocal")]
pub enum SettingIP4LinkLocal {
    /// Allow fallback to a globally configured default. If unspecified,
    ///   fallback to "auto". Note that if "ipv4.method" is "disabled", this always implies link-local
    ///   addresses disabled too.
    #[doc(alias = "NM_SETTING_IP4_LL_DEFAULT")]
    Default,
    /// Special value which enables LL if "ipv4.method" is set to
    ///   "link-local".
    #[doc(alias = "NM_SETTING_IP4_LL_AUTO")]
    Auto,
    /// Disable IPv4 link-local protocol.
    #[doc(alias = "NM_SETTING_IP4_LL_DISABLED")]
    Disabled,
    /// Enable the IPv4 link-local protocol regardless what other protocols
    ///   such as DHCP or manually assigned IP addresses might be active.
    #[doc(alias = "NM_SETTING_IP4_LL_ENABLED")]
    Enabled,
    /// Since 1.52. This sets an IPv4 link-local address if no other IPv4
    ///   address is set, dynamically removing/re-adding it depending on DHCP leases.
    #[doc(alias = "NM_SETTING_IP4_LL_FALLBACK")]
    Fallback,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v1_40")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_40")))]
#[doc(hidden)]
impl IntoGlib for SettingIP4LinkLocal {
    type GlibType = ffi::NMSettingIP4LinkLocal;

    #[inline]
    fn into_glib(self) -> ffi::NMSettingIP4LinkLocal {
        match self {
            Self::Default => ffi::NM_SETTING_IP4_LL_DEFAULT,
            Self::Auto => ffi::NM_SETTING_IP4_LL_AUTO,
            Self::Disabled => ffi::NM_SETTING_IP4_LL_DISABLED,
            Self::Enabled => ffi::NM_SETTING_IP4_LL_ENABLED,
            Self::Fallback => ffi::NM_SETTING_IP4_LL_FALLBACK,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v1_40")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_40")))]
#[doc(hidden)]
impl FromGlib<ffi::NMSettingIP4LinkLocal> for SettingIP4LinkLocal {
    #[inline]
    unsafe fn from_glib(value: ffi::NMSettingIP4LinkLocal) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_SETTING_IP4_LL_DEFAULT => Self::Default,
            ffi::NM_SETTING_IP4_LL_AUTO => Self::Auto,
            ffi::NM_SETTING_IP4_LL_DISABLED => Self::Disabled,
            ffi::NM_SETTING_IP4_LL_ENABLED => Self::Enabled,
            ffi::NM_SETTING_IP4_LL_FALLBACK => Self::Fallback,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v1_40")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_40")))]
impl StaticType for SettingIP4LinkLocal {
    #[inline]
    #[doc(alias = "nm_setting_ip4_link_local_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_setting_ip4_link_local_get_type()) }
    }
}

#[cfg(feature = "v1_40")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_40")))]
impl glib::HasParamSpec for SettingIP4LinkLocal {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v1_40")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_40")))]
impl glib::value::ValueType for SettingIP4LinkLocal {
    type Type = Self;
}

#[cfg(feature = "v1_40")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_40")))]
unsafe impl<'a> glib::value::FromValue<'a> for SettingIP4LinkLocal {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_40")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_40")))]
impl ToValue for SettingIP4LinkLocal {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_40")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_40")))]
impl From<SettingIP4LinkLocal> for glib::Value {
    #[inline]
    fn from(v: SettingIP4LinkLocal) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// #NMSettingIP6ConfigAddrGenMode controls how the Interface Identifier for
/// RFC4862 Stateless Address Autoconfiguration is created.
#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSettingIP6ConfigAddrGenMode")]
pub enum SettingIP6ConfigAddrGenMode {
    /// The Interface Identifier is derived
    /// from the interface hardware address.
    #[doc(alias = "NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_EUI64")]
    Eui64,
    /// The Interface Identifier
    /// is created by using a cryptographically secure hash of a secret host-specific
    /// key along with the connection identification and the network address as
    /// specified by RFC7217.
    #[doc(alias = "NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_STABLE_PRIVACY")]
    StablePrivacy,
    /// Fallback to the global
    ///   default, and if unspecified use "eui64". Since: 1.40.
    #[doc(alias = "NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_DEFAULT_OR_EUI64")]
    DefaultOrEui64,
    /// Fallback to the global
    ///   default, and if unspecified use "stable-privacy". Since: 1.40.
    #[doc(alias = "NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_DEFAULT")]
    Default,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
#[doc(hidden)]
impl IntoGlib for SettingIP6ConfigAddrGenMode {
    type GlibType = ffi::NMSettingIP6ConfigAddrGenMode;

    #[inline]
    fn into_glib(self) -> ffi::NMSettingIP6ConfigAddrGenMode {
        match self {
            Self::Eui64 => ffi::NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_EUI64,
            Self::StablePrivacy => ffi::NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_STABLE_PRIVACY,
            Self::DefaultOrEui64 => ffi::NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_DEFAULT_OR_EUI64,
            Self::Default => ffi::NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_DEFAULT,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
#[doc(hidden)]
impl FromGlib<ffi::NMSettingIP6ConfigAddrGenMode> for SettingIP6ConfigAddrGenMode {
    #[inline]
    unsafe fn from_glib(value: ffi::NMSettingIP6ConfigAddrGenMode) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_EUI64 => Self::Eui64,
            ffi::NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_STABLE_PRIVACY => Self::StablePrivacy,
            ffi::NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_DEFAULT_OR_EUI64 => Self::DefaultOrEui64,
            ffi::NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_DEFAULT => Self::Default,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
impl StaticType for SettingIP6ConfigAddrGenMode {
    #[inline]
    #[doc(alias = "nm_setting_ip6_config_addr_gen_mode_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_setting_ip6_config_addr_gen_mode_get_type()) }
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
impl glib::HasParamSpec for SettingIP6ConfigAddrGenMode {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
impl glib::value::ValueType for SettingIP6ConfigAddrGenMode {
    type Type = Self;
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
unsafe impl<'a> glib::value::FromValue<'a> for SettingIP6ConfigAddrGenMode {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
impl ToValue for SettingIP6ConfigAddrGenMode {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
impl From<SettingIP6ConfigAddrGenMode> for glib::Value {
    #[inline]
    fn from(v: SettingIP6ConfigAddrGenMode) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// #NMSettingIP6ConfigPrivacy values indicate if and how IPv6 Privacy
/// Extensions are used (RFC4941).
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSettingIP6ConfigPrivacy")]
pub enum SettingIP6ConfigPrivacy {
    /// unknown or no value specified
    #[doc(alias = "NM_SETTING_IP6_CONFIG_PRIVACY_UNKNOWN")]
    Unknown,
    /// IPv6 Privacy Extensions are disabled
    #[doc(alias = "NM_SETTING_IP6_CONFIG_PRIVACY_DISABLED")]
    Disabled,
    /// IPv6 Privacy Extensions
    /// are enabled, but public addresses are preferred over temporary addresses
    #[doc(alias = "NM_SETTING_IP6_CONFIG_PRIVACY_PREFER_PUBLIC_ADDR")]
    PreferPublicAddr,
    /// IPv6 Privacy Extensions
    /// are enabled and temporary addresses are preferred over public addresses
    #[doc(alias = "NM_SETTING_IP6_CONFIG_PRIVACY_PREFER_TEMP_ADDR")]
    PreferTempAddr,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for SettingIP6ConfigPrivacy {
    type GlibType = ffi::NMSettingIP6ConfigPrivacy;

    #[inline]
    fn into_glib(self) -> ffi::NMSettingIP6ConfigPrivacy {
        match self {
            Self::Unknown => ffi::NM_SETTING_IP6_CONFIG_PRIVACY_UNKNOWN,
            Self::Disabled => ffi::NM_SETTING_IP6_CONFIG_PRIVACY_DISABLED,
            Self::PreferPublicAddr => ffi::NM_SETTING_IP6_CONFIG_PRIVACY_PREFER_PUBLIC_ADDR,
            Self::PreferTempAddr => ffi::NM_SETTING_IP6_CONFIG_PRIVACY_PREFER_TEMP_ADDR,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMSettingIP6ConfigPrivacy> for SettingIP6ConfigPrivacy {
    #[inline]
    unsafe fn from_glib(value: ffi::NMSettingIP6ConfigPrivacy) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_SETTING_IP6_CONFIG_PRIVACY_UNKNOWN => Self::Unknown,
            ffi::NM_SETTING_IP6_CONFIG_PRIVACY_DISABLED => Self::Disabled,
            ffi::NM_SETTING_IP6_CONFIG_PRIVACY_PREFER_PUBLIC_ADDR => Self::PreferPublicAddr,
            ffi::NM_SETTING_IP6_CONFIG_PRIVACY_PREFER_TEMP_ADDR => Self::PreferTempAddr,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for SettingIP6ConfigPrivacy {
    #[inline]
    #[doc(alias = "nm_setting_ip6_config_privacy_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_setting_ip6_config_privacy_get_type()) }
    }
}

impl glib::HasParamSpec for SettingIP6ConfigPrivacy {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for SettingIP6ConfigPrivacy {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for SettingIP6ConfigPrivacy {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for SettingIP6ConfigPrivacy {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<SettingIP6ConfigPrivacy> for glib::Value {
    #[inline]
    fn from(v: SettingIP6ConfigPrivacy) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// #NMSettingIPConfigForwarding indicates whether to configure sysctl
/// interface-specific forwarding. When enabled, the interface will act
/// as a router to forward the packet from one interface to another.
#[cfg(feature = "v1_54")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_54")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSettingIPConfigForwarding")]
pub enum SettingIPConfigForwarding {
    /// use the global default value
    #[doc(alias = "NM_SETTING_IP_CONFIG_FORWARDING_DEFAULT")]
    Default,
    /// disable forwarding
    #[doc(alias = "NM_SETTING_IP_CONFIG_FORWARDING_NO")]
    No,
    /// enable forwarding
    #[doc(alias = "NM_SETTING_IP_CONFIG_FORWARDING_YES")]
    Yes,
    /// enable forwarding if any shared
    ///  connection is active, use kernel default otherwise
    #[doc(alias = "NM_SETTING_IP_CONFIG_FORWARDING_AUTO")]
    Auto,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v1_54")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_54")))]
#[doc(hidden)]
impl IntoGlib for SettingIPConfigForwarding {
    type GlibType = ffi::NMSettingIPConfigForwarding;

    #[inline]
    fn into_glib(self) -> ffi::NMSettingIPConfigForwarding {
        match self {
            Self::Default => ffi::NM_SETTING_IP_CONFIG_FORWARDING_DEFAULT,
            Self::No => ffi::NM_SETTING_IP_CONFIG_FORWARDING_NO,
            Self::Yes => ffi::NM_SETTING_IP_CONFIG_FORWARDING_YES,
            Self::Auto => ffi::NM_SETTING_IP_CONFIG_FORWARDING_AUTO,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v1_54")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_54")))]
#[doc(hidden)]
impl FromGlib<ffi::NMSettingIPConfigForwarding> for SettingIPConfigForwarding {
    #[inline]
    unsafe fn from_glib(value: ffi::NMSettingIPConfigForwarding) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_SETTING_IP_CONFIG_FORWARDING_DEFAULT => Self::Default,
            ffi::NM_SETTING_IP_CONFIG_FORWARDING_NO => Self::No,
            ffi::NM_SETTING_IP_CONFIG_FORWARDING_YES => Self::Yes,
            ffi::NM_SETTING_IP_CONFIG_FORWARDING_AUTO => Self::Auto,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v1_54")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_54")))]
impl StaticType for SettingIPConfigForwarding {
    #[inline]
    #[doc(alias = "nm_setting_ip_config_forwarding_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_setting_ip_config_forwarding_get_type()) }
    }
}

#[cfg(feature = "v1_54")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_54")))]
impl glib::HasParamSpec for SettingIPConfigForwarding {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v1_54")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_54")))]
impl glib::value::ValueType for SettingIPConfigForwarding {
    type Type = Self;
}

#[cfg(feature = "v1_54")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_54")))]
unsafe impl<'a> glib::value::FromValue<'a> for SettingIPConfigForwarding {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_54")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_54")))]
impl ToValue for SettingIPConfigForwarding {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_54")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_54")))]
impl From<SettingIPConfigForwarding> for glib::Value {
    #[inline]
    fn from(v: SettingIPConfigForwarding) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// #NMSettingIPConfigRoutedDns indicates whether routes are added
/// automatically for each DNS that is associated with this connection.
#[cfg(feature = "v1_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSettingIPConfigRoutedDns")]
pub enum SettingIPConfigRoutedDns {
    /// use the global default value
    #[doc(alias = "NM_SETTING_IP_CONFIG_ROUTED_DNS_DEFAULT")]
    Default,
    /// do not add DNS routes
    #[doc(alias = "NM_SETTING_IP_CONFIG_ROUTED_DNS_NO")]
    No,
    /// do add DNS routes
    #[doc(alias = "NM_SETTING_IP_CONFIG_ROUTED_DNS_YES")]
    Yes,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v1_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
#[doc(hidden)]
impl IntoGlib for SettingIPConfigRoutedDns {
    type GlibType = ffi::NMSettingIPConfigRoutedDns;

    #[inline]
    fn into_glib(self) -> ffi::NMSettingIPConfigRoutedDns {
        match self {
            Self::Default => ffi::NM_SETTING_IP_CONFIG_ROUTED_DNS_DEFAULT,
            Self::No => ffi::NM_SETTING_IP_CONFIG_ROUTED_DNS_NO,
            Self::Yes => ffi::NM_SETTING_IP_CONFIG_ROUTED_DNS_YES,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v1_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
#[doc(hidden)]
impl FromGlib<ffi::NMSettingIPConfigRoutedDns> for SettingIPConfigRoutedDns {
    #[inline]
    unsafe fn from_glib(value: ffi::NMSettingIPConfigRoutedDns) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_SETTING_IP_CONFIG_ROUTED_DNS_DEFAULT => Self::Default,
            ffi::NM_SETTING_IP_CONFIG_ROUTED_DNS_NO => Self::No,
            ffi::NM_SETTING_IP_CONFIG_ROUTED_DNS_YES => Self::Yes,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v1_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
impl StaticType for SettingIPConfigRoutedDns {
    #[inline]
    #[doc(alias = "nm_setting_ip_config_routed_dns_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_setting_ip_config_routed_dns_get_type()) }
    }
}

#[cfg(feature = "v1_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
impl glib::HasParamSpec for SettingIPConfigRoutedDns {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v1_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
impl glib::value::ValueType for SettingIPConfigRoutedDns {
    type Type = Self;
}

#[cfg(feature = "v1_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
unsafe impl<'a> glib::value::FromValue<'a> for SettingIPConfigRoutedDns {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
impl ToValue for SettingIPConfigRoutedDns {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
impl From<SettingIPConfigRoutedDns> for glib::Value {
    #[inline]
    fn from(v: SettingIPConfigRoutedDns) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v1_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSettingIpvlanMode")]
pub enum SettingIpvlanMode {
    /// unknown/unset mode
    #[doc(alias = "NM_SETTING_IPVLAN_MODE_UNKNOWN")]
    Unknown,
    /// L2 mode, device receives and responds to ARP.
    #[doc(alias = "NM_SETTING_IPVLAN_MODE_L2")]
    L2,
    /// L3 mode, device process only L3 traffic and above.
    #[doc(alias = "NM_SETTING_IPVLAN_MODE_L3")]
    L3,
    /// L3S mode, same way as L3 mode but egress and ingress
    /// lands on netfilter chain.
    #[doc(alias = "NM_SETTING_IPVLAN_MODE_L3S")]
    L3s,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v1_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
#[doc(hidden)]
impl IntoGlib for SettingIpvlanMode {
    type GlibType = ffi::NMSettingIpvlanMode;

    #[inline]
    fn into_glib(self) -> ffi::NMSettingIpvlanMode {
        match self {
            Self::Unknown => ffi::NM_SETTING_IPVLAN_MODE_UNKNOWN,
            Self::L2 => ffi::NM_SETTING_IPVLAN_MODE_L2,
            Self::L3 => ffi::NM_SETTING_IPVLAN_MODE_L3,
            Self::L3s => ffi::NM_SETTING_IPVLAN_MODE_L3S,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v1_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
#[doc(hidden)]
impl FromGlib<ffi::NMSettingIpvlanMode> for SettingIpvlanMode {
    #[inline]
    unsafe fn from_glib(value: ffi::NMSettingIpvlanMode) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_SETTING_IPVLAN_MODE_UNKNOWN => Self::Unknown,
            ffi::NM_SETTING_IPVLAN_MODE_L2 => Self::L2,
            ffi::NM_SETTING_IPVLAN_MODE_L3 => Self::L3,
            ffi::NM_SETTING_IPVLAN_MODE_L3S => Self::L3s,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v1_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
impl StaticType for SettingIpvlanMode {
    #[inline]
    #[doc(alias = "nm_setting_ipvlan_mode_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_setting_ipvlan_mode_get_type()) }
    }
}

#[cfg(feature = "v1_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
impl glib::HasParamSpec for SettingIpvlanMode {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v1_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
impl glib::value::ValueType for SettingIpvlanMode {
    type Type = Self;
}

#[cfg(feature = "v1_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
unsafe impl<'a> glib::value::FromValue<'a> for SettingIpvlanMode {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
impl ToValue for SettingIpvlanMode {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
impl From<SettingIpvlanMode> for glib::Value {
    #[inline]
    fn from(v: SettingIpvlanMode) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// Controls if and how the MAC address of a device is randomzied.
#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSettingMacRandomization")]
pub enum SettingMacRandomization {
    /// the default value, which unless
    /// overridden by user-controlled defaults configuration, is "never".
    #[doc(alias = "NM_SETTING_MAC_RANDOMIZATION_DEFAULT")]
    Default,
    /// the device's MAC address is always used.
    #[doc(alias = "NM_SETTING_MAC_RANDOMIZATION_NEVER")]
    Never,
    /// a random MAC address is used.
    #[doc(alias = "NM_SETTING_MAC_RANDOMIZATION_ALWAYS")]
    Always,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
#[doc(hidden)]
impl IntoGlib for SettingMacRandomization {
    type GlibType = ffi::NMSettingMacRandomization;

    #[inline]
    fn into_glib(self) -> ffi::NMSettingMacRandomization {
        match self {
            Self::Default => ffi::NM_SETTING_MAC_RANDOMIZATION_DEFAULT,
            Self::Never => ffi::NM_SETTING_MAC_RANDOMIZATION_NEVER,
            Self::Always => ffi::NM_SETTING_MAC_RANDOMIZATION_ALWAYS,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
#[doc(hidden)]
impl FromGlib<ffi::NMSettingMacRandomization> for SettingMacRandomization {
    #[inline]
    unsafe fn from_glib(value: ffi::NMSettingMacRandomization) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_SETTING_MAC_RANDOMIZATION_DEFAULT => Self::Default,
            ffi::NM_SETTING_MAC_RANDOMIZATION_NEVER => Self::Never,
            ffi::NM_SETTING_MAC_RANDOMIZATION_ALWAYS => Self::Always,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
impl StaticType for SettingMacRandomization {
    #[inline]
    #[doc(alias = "nm_setting_mac_randomization_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_setting_mac_randomization_get_type()) }
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
impl glib::HasParamSpec for SettingMacRandomization {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
impl glib::value::ValueType for SettingMacRandomization {
    type Type = Self;
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
unsafe impl<'a> glib::value::FromValue<'a> for SettingMacRandomization {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
impl ToValue for SettingMacRandomization {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
impl From<SettingMacRandomization> for glib::Value {
    #[inline]
    fn from(v: SettingMacRandomization) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// #NMSettingMacsecMode controls how the CAK (Connectivity Association Key) used
/// in MKA (MACsec Key Agreement) is obtained.
#[cfg(feature = "v1_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSettingMacsecMode")]
pub enum SettingMacsecMode {
    /// The CAK is pre-shared
    #[doc(alias = "NM_SETTING_MACSEC_MODE_PSK")]
    Psk,
    /// The CAK is the result of participation in EAP
    #[doc(alias = "NM_SETTING_MACSEC_MODE_EAP")]
    Eap,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v1_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
#[doc(hidden)]
impl IntoGlib for SettingMacsecMode {
    type GlibType = ffi::NMSettingMacsecMode;

    #[inline]
    fn into_glib(self) -> ffi::NMSettingMacsecMode {
        match self {
            Self::Psk => ffi::NM_SETTING_MACSEC_MODE_PSK,
            Self::Eap => ffi::NM_SETTING_MACSEC_MODE_EAP,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v1_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
#[doc(hidden)]
impl FromGlib<ffi::NMSettingMacsecMode> for SettingMacsecMode {
    #[inline]
    unsafe fn from_glib(value: ffi::NMSettingMacsecMode) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_SETTING_MACSEC_MODE_PSK => Self::Psk,
            ffi::NM_SETTING_MACSEC_MODE_EAP => Self::Eap,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v1_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
impl StaticType for SettingMacsecMode {
    #[inline]
    #[doc(alias = "nm_setting_macsec_mode_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_setting_macsec_mode_get_type()) }
    }
}

#[cfg(feature = "v1_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
impl glib::HasParamSpec for SettingMacsecMode {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v1_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
impl glib::value::ValueType for SettingMacsecMode {
    type Type = Self;
}

#[cfg(feature = "v1_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
unsafe impl<'a> glib::value::FromValue<'a> for SettingMacsecMode {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
impl ToValue for SettingMacsecMode {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
impl From<SettingMacsecMode> for glib::Value {
    #[inline]
    fn from(v: SettingMacsecMode) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// These flags control the MACsec offload mode.
#[cfg(feature = "v1_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSettingMacsecOffload")]
pub enum SettingMacsecOffload {
    /// use the global default; disable if not defined
    #[doc(alias = "NM_SETTING_MACSEC_OFFLOAD_DEFAULT")]
    Default,
    /// disable offload
    #[doc(alias = "NM_SETTING_MACSEC_OFFLOAD_OFF")]
    Off,
    /// request offload to the PHY
    #[doc(alias = "NM_SETTING_MACSEC_OFFLOAD_PHY")]
    Phy,
    /// request offload to the MAC
    #[doc(alias = "NM_SETTING_MACSEC_OFFLOAD_MAC")]
    Mac,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v1_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
#[doc(hidden)]
impl IntoGlib for SettingMacsecOffload {
    type GlibType = ffi::NMSettingMacsecOffload;

    #[inline]
    fn into_glib(self) -> ffi::NMSettingMacsecOffload {
        match self {
            Self::Default => ffi::NM_SETTING_MACSEC_OFFLOAD_DEFAULT,
            Self::Off => ffi::NM_SETTING_MACSEC_OFFLOAD_OFF,
            Self::Phy => ffi::NM_SETTING_MACSEC_OFFLOAD_PHY,
            Self::Mac => ffi::NM_SETTING_MACSEC_OFFLOAD_MAC,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v1_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
#[doc(hidden)]
impl FromGlib<ffi::NMSettingMacsecOffload> for SettingMacsecOffload {
    #[inline]
    unsafe fn from_glib(value: ffi::NMSettingMacsecOffload) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_SETTING_MACSEC_OFFLOAD_DEFAULT => Self::Default,
            ffi::NM_SETTING_MACSEC_OFFLOAD_OFF => Self::Off,
            ffi::NM_SETTING_MACSEC_OFFLOAD_PHY => Self::Phy,
            ffi::NM_SETTING_MACSEC_OFFLOAD_MAC => Self::Mac,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v1_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
impl StaticType for SettingMacsecOffload {
    #[inline]
    #[doc(alias = "nm_setting_macsec_offload_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_setting_macsec_offload_get_type()) }
    }
}

#[cfg(feature = "v1_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
impl glib::HasParamSpec for SettingMacsecOffload {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v1_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
impl glib::value::ValueType for SettingMacsecOffload {
    type Type = Self;
}

#[cfg(feature = "v1_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
unsafe impl<'a> glib::value::FromValue<'a> for SettingMacsecOffload {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
impl ToValue for SettingMacsecOffload {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
impl From<SettingMacsecOffload> for glib::Value {
    #[inline]
    fn from(v: SettingMacsecOffload) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// #NMSettingMacsecValidation specifies a validation mode for incoming frames.
#[cfg(feature = "v1_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSettingMacsecValidation")]
pub enum SettingMacsecValidation {
    /// All incoming frames are accepted if
    ///   possible
    #[doc(alias = "NM_SETTING_MACSEC_VALIDATION_DISABLE")]
    Disable,
    /// Non protected, invalid, or impossible to
    ///   verify frames are accepted and counted as "invalid"
    #[doc(alias = "NM_SETTING_MACSEC_VALIDATION_CHECK")]
    Check,
    /// Non protected, invalid, or impossible to
    ///   verify frames are dropped
    #[doc(alias = "NM_SETTING_MACSEC_VALIDATION_STRICT")]
    Strict,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v1_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
#[doc(hidden)]
impl IntoGlib for SettingMacsecValidation {
    type GlibType = ffi::NMSettingMacsecValidation;

    #[inline]
    fn into_glib(self) -> ffi::NMSettingMacsecValidation {
        match self {
            Self::Disable => ffi::NM_SETTING_MACSEC_VALIDATION_DISABLE,
            Self::Check => ffi::NM_SETTING_MACSEC_VALIDATION_CHECK,
            Self::Strict => ffi::NM_SETTING_MACSEC_VALIDATION_STRICT,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v1_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
#[doc(hidden)]
impl FromGlib<ffi::NMSettingMacsecValidation> for SettingMacsecValidation {
    #[inline]
    unsafe fn from_glib(value: ffi::NMSettingMacsecValidation) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_SETTING_MACSEC_VALIDATION_DISABLE => Self::Disable,
            ffi::NM_SETTING_MACSEC_VALIDATION_CHECK => Self::Check,
            ffi::NM_SETTING_MACSEC_VALIDATION_STRICT => Self::Strict,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v1_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
impl StaticType for SettingMacsecValidation {
    #[inline]
    #[doc(alias = "nm_setting_macsec_validation_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_setting_macsec_validation_get_type()) }
    }
}

#[cfg(feature = "v1_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
impl glib::HasParamSpec for SettingMacsecValidation {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v1_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
impl glib::value::ValueType for SettingMacsecValidation {
    type Type = Self;
}

#[cfg(feature = "v1_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
unsafe impl<'a> glib::value::FromValue<'a> for SettingMacsecValidation {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
impl ToValue for SettingMacsecValidation {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
impl From<SettingMacsecValidation> for glib::Value {
    #[inline]
    fn from(v: SettingMacsecValidation) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSettingMacvlanMode")]
pub enum SettingMacvlanMode {
    /// unknown/unset mode
    #[doc(alias = "NM_SETTING_MACVLAN_MODE_UNKNOWN")]
    Unknown,
    /// Virtual Ethernet Port Aggregator mode
    #[doc(alias = "NM_SETTING_MACVLAN_MODE_VEPA")]
    Vepa,
    /// bridge mode
    #[doc(alias = "NM_SETTING_MACVLAN_MODE_BRIDGE")]
    Bridge,
    /// private mode
    #[doc(alias = "NM_SETTING_MACVLAN_MODE_PRIVATE")]
    Private,
    /// passthru mode
    #[doc(alias = "NM_SETTING_MACVLAN_MODE_PASSTHRU")]
    Passthru,
    /// source mode
    #[doc(alias = "NM_SETTING_MACVLAN_MODE_SOURCE")]
    Source,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
#[doc(hidden)]
impl IntoGlib for SettingMacvlanMode {
    type GlibType = ffi::NMSettingMacvlanMode;

    #[inline]
    fn into_glib(self) -> ffi::NMSettingMacvlanMode {
        match self {
            Self::Unknown => ffi::NM_SETTING_MACVLAN_MODE_UNKNOWN,
            Self::Vepa => ffi::NM_SETTING_MACVLAN_MODE_VEPA,
            Self::Bridge => ffi::NM_SETTING_MACVLAN_MODE_BRIDGE,
            Self::Private => ffi::NM_SETTING_MACVLAN_MODE_PRIVATE,
            Self::Passthru => ffi::NM_SETTING_MACVLAN_MODE_PASSTHRU,
            Self::Source => ffi::NM_SETTING_MACVLAN_MODE_SOURCE,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
#[doc(hidden)]
impl FromGlib<ffi::NMSettingMacvlanMode> for SettingMacvlanMode {
    #[inline]
    unsafe fn from_glib(value: ffi::NMSettingMacvlanMode) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_SETTING_MACVLAN_MODE_UNKNOWN => Self::Unknown,
            ffi::NM_SETTING_MACVLAN_MODE_VEPA => Self::Vepa,
            ffi::NM_SETTING_MACVLAN_MODE_BRIDGE => Self::Bridge,
            ffi::NM_SETTING_MACVLAN_MODE_PRIVATE => Self::Private,
            ffi::NM_SETTING_MACVLAN_MODE_PASSTHRU => Self::Passthru,
            ffi::NM_SETTING_MACVLAN_MODE_SOURCE => Self::Source,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
impl StaticType for SettingMacvlanMode {
    #[inline]
    #[doc(alias = "nm_setting_macvlan_mode_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_setting_macvlan_mode_get_type()) }
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
impl glib::HasParamSpec for SettingMacvlanMode {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
impl glib::value::ValueType for SettingMacvlanMode {
    type Type = Self;
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
unsafe impl<'a> glib::value::FromValue<'a> for SettingMacvlanMode {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
impl ToValue for SettingMacvlanMode {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
impl From<SettingMacvlanMode> for glib::Value {
    #[inline]
    fn from(v: SettingMacvlanMode) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// #NMSettingOvsDpdkLscInterrupt indicates whether the interface uses interrupts
/// or poll mode for Link State Change (LSC) detection on the OVS DPDK interface.
#[cfg(feature = "v1_54")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_54")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSettingOvsDpdkLscInterrupt")]
pub enum SettingOvsDpdkLscInterrupt {
    /// leave the value set to Open vSwitch default
    #[doc(alias = "NM_SETTING_OVS_DPDK_LSC_INTERRUPT_IGNORE")]
    Ignore,
    /// interrupt disabled (poll mode)
    #[doc(alias = "NM_SETTING_OVS_DPDK_LSC_INTERRUPT_DISABLED")]
    Disabled,
    /// interrupt enabled
    #[doc(alias = "NM_SETTING_OVS_DPDK_LSC_INTERRUPT_ENABLED")]
    Enabled,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v1_54")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_54")))]
#[doc(hidden)]
impl IntoGlib for SettingOvsDpdkLscInterrupt {
    type GlibType = ffi::NMSettingOvsDpdkLscInterrupt;

    #[inline]
    fn into_glib(self) -> ffi::NMSettingOvsDpdkLscInterrupt {
        match self {
            Self::Ignore => ffi::NM_SETTING_OVS_DPDK_LSC_INTERRUPT_IGNORE,
            Self::Disabled => ffi::NM_SETTING_OVS_DPDK_LSC_INTERRUPT_DISABLED,
            Self::Enabled => ffi::NM_SETTING_OVS_DPDK_LSC_INTERRUPT_ENABLED,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v1_54")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_54")))]
#[doc(hidden)]
impl FromGlib<ffi::NMSettingOvsDpdkLscInterrupt> for SettingOvsDpdkLscInterrupt {
    #[inline]
    unsafe fn from_glib(value: ffi::NMSettingOvsDpdkLscInterrupt) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_SETTING_OVS_DPDK_LSC_INTERRUPT_IGNORE => Self::Ignore,
            ffi::NM_SETTING_OVS_DPDK_LSC_INTERRUPT_DISABLED => Self::Disabled,
            ffi::NM_SETTING_OVS_DPDK_LSC_INTERRUPT_ENABLED => Self::Enabled,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v1_54")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_54")))]
impl StaticType for SettingOvsDpdkLscInterrupt {
    #[inline]
    #[doc(alias = "nm_setting_ovs_dpdk_lsc_interrupt_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_setting_ovs_dpdk_lsc_interrupt_get_type()) }
    }
}

#[cfg(feature = "v1_54")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_54")))]
impl glib::HasParamSpec for SettingOvsDpdkLscInterrupt {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v1_54")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_54")))]
impl glib::value::ValueType for SettingOvsDpdkLscInterrupt {
    type Type = Self;
}

#[cfg(feature = "v1_54")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_54")))]
unsafe impl<'a> glib::value::FromValue<'a> for SettingOvsDpdkLscInterrupt {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_54")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_54")))]
impl ToValue for SettingOvsDpdkLscInterrupt {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_54")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_54")))]
impl From<SettingOvsDpdkLscInterrupt> for glib::Value {
    #[inline]
    fn from(v: SettingOvsDpdkLscInterrupt) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// The Proxy method.
#[cfg(feature = "v1_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSettingProxyMethod")]
pub enum SettingProxyMethod {
    /// No Proxy for the Connection
    #[doc(alias = "NM_SETTING_PROXY_METHOD_NONE")]
    None,
    /// DHCP obtained Proxy/ Manual override
    #[doc(alias = "NM_SETTING_PROXY_METHOD_AUTO")]
    Auto,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v1_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
#[doc(hidden)]
impl IntoGlib for SettingProxyMethod {
    type GlibType = ffi::NMSettingProxyMethod;

    #[inline]
    fn into_glib(self) -> ffi::NMSettingProxyMethod {
        match self {
            Self::None => ffi::NM_SETTING_PROXY_METHOD_NONE,
            Self::Auto => ffi::NM_SETTING_PROXY_METHOD_AUTO,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v1_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
#[doc(hidden)]
impl FromGlib<ffi::NMSettingProxyMethod> for SettingProxyMethod {
    #[inline]
    unsafe fn from_glib(value: ffi::NMSettingProxyMethod) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_SETTING_PROXY_METHOD_NONE => Self::None,
            ffi::NM_SETTING_PROXY_METHOD_AUTO => Self::Auto,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v1_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
impl StaticType for SettingProxyMethod {
    #[inline]
    #[doc(alias = "nm_setting_proxy_method_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_setting_proxy_method_get_type()) }
    }
}

#[cfg(feature = "v1_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
impl glib::HasParamSpec for SettingProxyMethod {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v1_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
impl glib::value::ValueType for SettingProxyMethod {
    type Type = Self;
}

#[cfg(feature = "v1_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
unsafe impl<'a> glib::value::FromValue<'a> for SettingProxyMethod {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
impl ToValue for SettingProxyMethod {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
impl From<SettingProxyMethod> for glib::Value {
    #[inline]
    fn from(v: SettingProxyMethod) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// The parity setting of a serial port.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSettingSerialParity")]
pub enum SettingSerialParity {
    /// No parity bits (default)
    #[doc(alias = "NM_SETTING_SERIAL_PARITY_NONE")]
    None,
    /// Even parity
    #[doc(alias = "NM_SETTING_SERIAL_PARITY_EVEN")]
    Even,
    /// Odd parity
    #[doc(alias = "NM_SETTING_SERIAL_PARITY_ODD")]
    Odd,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for SettingSerialParity {
    type GlibType = ffi::NMSettingSerialParity;

    #[inline]
    fn into_glib(self) -> ffi::NMSettingSerialParity {
        match self {
            Self::None => ffi::NM_SETTING_SERIAL_PARITY_NONE,
            Self::Even => ffi::NM_SETTING_SERIAL_PARITY_EVEN,
            Self::Odd => ffi::NM_SETTING_SERIAL_PARITY_ODD,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMSettingSerialParity> for SettingSerialParity {
    #[inline]
    unsafe fn from_glib(value: ffi::NMSettingSerialParity) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_SETTING_SERIAL_PARITY_NONE => Self::None,
            ffi::NM_SETTING_SERIAL_PARITY_EVEN => Self::Even,
            ffi::NM_SETTING_SERIAL_PARITY_ODD => Self::Odd,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for SettingSerialParity {
    #[inline]
    #[doc(alias = "nm_setting_serial_parity_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_setting_serial_parity_get_type()) }
    }
}

impl glib::HasParamSpec for SettingSerialParity {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for SettingSerialParity {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for SettingSerialParity {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for SettingSerialParity {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<SettingSerialParity> for glib::Value {
    #[inline]
    fn from(v: SettingSerialParity) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// #NMSettingTunMode values indicate the device type (TUN/TAP)
#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSettingTunMode")]
pub enum SettingTunMode {
    /// an unknown device type
    #[doc(alias = "NM_SETTING_TUN_MODE_UNKNOWN")]
    Unknown,
    /// a TUN device
    #[doc(alias = "NM_SETTING_TUN_MODE_TUN")]
    Tun,
    /// a TAP device
    #[doc(alias = "NM_SETTING_TUN_MODE_TAP")]
    Tap,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
#[doc(hidden)]
impl IntoGlib for SettingTunMode {
    type GlibType = ffi::NMSettingTunMode;

    #[inline]
    fn into_glib(self) -> ffi::NMSettingTunMode {
        match self {
            Self::Unknown => ffi::NM_SETTING_TUN_MODE_UNKNOWN,
            Self::Tun => ffi::NM_SETTING_TUN_MODE_TUN,
            Self::Tap => ffi::NM_SETTING_TUN_MODE_TAP,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
#[doc(hidden)]
impl FromGlib<ffi::NMSettingTunMode> for SettingTunMode {
    #[inline]
    unsafe fn from_glib(value: ffi::NMSettingTunMode) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_SETTING_TUN_MODE_UNKNOWN => Self::Unknown,
            ffi::NM_SETTING_TUN_MODE_TUN => Self::Tun,
            ffi::NM_SETTING_TUN_MODE_TAP => Self::Tap,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
impl StaticType for SettingTunMode {
    #[inline]
    #[doc(alias = "nm_setting_tun_mode_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_setting_tun_mode_get_type()) }
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
impl glib::HasParamSpec for SettingTunMode {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
impl glib::value::ValueType for SettingTunMode {
    type Type = Self;
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
unsafe impl<'a> glib::value::FromValue<'a> for SettingTunMode {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
impl ToValue for SettingTunMode {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
impl From<SettingTunMode> for glib::Value {
    #[inline]
    fn from(v: SettingTunMode) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// Indicates the wireless channel width.
#[cfg(feature = "v1_50")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_50")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSettingWirelessChannelWidth")]
pub enum SettingWirelessChannelWidth {
    /// automatically determine the width
    #[doc(alias = "NM_SETTING_WIRELESS_CHANNEL_WIDTH_AUTO")]
    Auto,
    /// use a 20MHz channel width
    #[doc(alias = "NM_SETTING_WIRELESS_CHANNEL_WIDTH_20MHZ")]
    _20mhz,
    /// use a 40MHz channel width
    #[doc(alias = "NM_SETTING_WIRELESS_CHANNEL_WIDTH_40MHZ")]
    _40mhz,
    /// use a 80MHz channel width
    #[doc(alias = "NM_SETTING_WIRELESS_CHANNEL_WIDTH_80MHZ")]
    _80mhz,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v1_50")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_50")))]
#[doc(hidden)]
impl IntoGlib for SettingWirelessChannelWidth {
    type GlibType = ffi::NMSettingWirelessChannelWidth;

    #[inline]
    fn into_glib(self) -> ffi::NMSettingWirelessChannelWidth {
        match self {
            Self::Auto => ffi::NM_SETTING_WIRELESS_CHANNEL_WIDTH_AUTO,
            Self::_20mhz => ffi::NM_SETTING_WIRELESS_CHANNEL_WIDTH_20MHZ,
            Self::_40mhz => ffi::NM_SETTING_WIRELESS_CHANNEL_WIDTH_40MHZ,
            Self::_80mhz => ffi::NM_SETTING_WIRELESS_CHANNEL_WIDTH_80MHZ,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v1_50")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_50")))]
#[doc(hidden)]
impl FromGlib<ffi::NMSettingWirelessChannelWidth> for SettingWirelessChannelWidth {
    #[inline]
    unsafe fn from_glib(value: ffi::NMSettingWirelessChannelWidth) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_SETTING_WIRELESS_CHANNEL_WIDTH_AUTO => Self::Auto,
            ffi::NM_SETTING_WIRELESS_CHANNEL_WIDTH_20MHZ => Self::_20mhz,
            ffi::NM_SETTING_WIRELESS_CHANNEL_WIDTH_40MHZ => Self::_40mhz,
            ffi::NM_SETTING_WIRELESS_CHANNEL_WIDTH_80MHZ => Self::_80mhz,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v1_50")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_50")))]
impl StaticType for SettingWirelessChannelWidth {
    #[inline]
    #[doc(alias = "nm_setting_wireless_channel_width_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_setting_wireless_channel_width_get_type()) }
    }
}

#[cfg(feature = "v1_50")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_50")))]
impl glib::HasParamSpec for SettingWirelessChannelWidth {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v1_50")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_50")))]
impl glib::value::ValueType for SettingWirelessChannelWidth {
    type Type = Self;
}

#[cfg(feature = "v1_50")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_50")))]
unsafe impl<'a> glib::value::FromValue<'a> for SettingWirelessChannelWidth {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_50")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_50")))]
impl ToValue for SettingWirelessChannelWidth {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_50")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_50")))]
impl From<SettingWirelessChannelWidth> for glib::Value {
    #[inline]
    fn from(v: SettingWirelessChannelWidth) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// These flags indicate whether wireless powersave must be enabled.
#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSettingWirelessPowersave")]
pub enum SettingWirelessPowersave {
    /// use the default value
    #[doc(alias = "NM_SETTING_WIRELESS_POWERSAVE_DEFAULT")]
    Default,
    /// don't touch existing setting
    #[doc(alias = "NM_SETTING_WIRELESS_POWERSAVE_IGNORE")]
    Ignore,
    /// disable powersave
    #[doc(alias = "NM_SETTING_WIRELESS_POWERSAVE_DISABLE")]
    Disable,
    /// enable powersave
    #[doc(alias = "NM_SETTING_WIRELESS_POWERSAVE_ENABLE")]
    Enable,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
#[doc(hidden)]
impl IntoGlib for SettingWirelessPowersave {
    type GlibType = ffi::NMSettingWirelessPowersave;

    #[inline]
    fn into_glib(self) -> ffi::NMSettingWirelessPowersave {
        match self {
            Self::Default => ffi::NM_SETTING_WIRELESS_POWERSAVE_DEFAULT,
            Self::Ignore => ffi::NM_SETTING_WIRELESS_POWERSAVE_IGNORE,
            Self::Disable => ffi::NM_SETTING_WIRELESS_POWERSAVE_DISABLE,
            Self::Enable => ffi::NM_SETTING_WIRELESS_POWERSAVE_ENABLE,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
#[doc(hidden)]
impl FromGlib<ffi::NMSettingWirelessPowersave> for SettingWirelessPowersave {
    #[inline]
    unsafe fn from_glib(value: ffi::NMSettingWirelessPowersave) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_SETTING_WIRELESS_POWERSAVE_DEFAULT => Self::Default,
            ffi::NM_SETTING_WIRELESS_POWERSAVE_IGNORE => Self::Ignore,
            ffi::NM_SETTING_WIRELESS_POWERSAVE_DISABLE => Self::Disable,
            ffi::NM_SETTING_WIRELESS_POWERSAVE_ENABLE => Self::Enable,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
impl StaticType for SettingWirelessPowersave {
    #[inline]
    #[doc(alias = "nm_setting_wireless_powersave_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_setting_wireless_powersave_get_type()) }
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
impl glib::HasParamSpec for SettingWirelessPowersave {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
impl glib::value::ValueType for SettingWirelessPowersave {
    type Type = Self;
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
unsafe impl<'a> glib::value::FromValue<'a> for SettingWirelessPowersave {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
impl ToValue for SettingWirelessPowersave {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
impl From<SettingWirelessPowersave> for glib::Value {
    #[inline]
    fn from(v: SettingWirelessPowersave) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// These flags indicate whether FILS must be enabled.
#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSettingWirelessSecurityFils")]
pub enum SettingWirelessSecurityFils {
    /// use the default value
    #[doc(alias = "NM_SETTING_WIRELESS_SECURITY_FILS_DEFAULT")]
    Default,
    /// disable FILS
    #[doc(alias = "NM_SETTING_WIRELESS_SECURITY_FILS_DISABLE")]
    Disable,
    /// enable FILS if the supplicant and the AP support it
    #[doc(alias = "NM_SETTING_WIRELESS_SECURITY_FILS_OPTIONAL")]
    Optional,
    /// require FILS and fail if not available
    #[doc(alias = "NM_SETTING_WIRELESS_SECURITY_FILS_REQUIRED")]
    Required,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
#[doc(hidden)]
impl IntoGlib for SettingWirelessSecurityFils {
    type GlibType = ffi::NMSettingWirelessSecurityFils;

    #[inline]
    fn into_glib(self) -> ffi::NMSettingWirelessSecurityFils {
        match self {
            Self::Default => ffi::NM_SETTING_WIRELESS_SECURITY_FILS_DEFAULT,
            Self::Disable => ffi::NM_SETTING_WIRELESS_SECURITY_FILS_DISABLE,
            Self::Optional => ffi::NM_SETTING_WIRELESS_SECURITY_FILS_OPTIONAL,
            Self::Required => ffi::NM_SETTING_WIRELESS_SECURITY_FILS_REQUIRED,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
#[doc(hidden)]
impl FromGlib<ffi::NMSettingWirelessSecurityFils> for SettingWirelessSecurityFils {
    #[inline]
    unsafe fn from_glib(value: ffi::NMSettingWirelessSecurityFils) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_SETTING_WIRELESS_SECURITY_FILS_DEFAULT => Self::Default,
            ffi::NM_SETTING_WIRELESS_SECURITY_FILS_DISABLE => Self::Disable,
            ffi::NM_SETTING_WIRELESS_SECURITY_FILS_OPTIONAL => Self::Optional,
            ffi::NM_SETTING_WIRELESS_SECURITY_FILS_REQUIRED => Self::Required,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
impl StaticType for SettingWirelessSecurityFils {
    #[inline]
    #[doc(alias = "nm_setting_wireless_security_fils_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_setting_wireless_security_fils_get_type()) }
    }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
impl glib::HasParamSpec for SettingWirelessSecurityFils {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
impl glib::value::ValueType for SettingWirelessSecurityFils {
    type Type = Self;
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
unsafe impl<'a> glib::value::FromValue<'a> for SettingWirelessSecurityFils {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
impl ToValue for SettingWirelessSecurityFils {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
impl From<SettingWirelessSecurityFils> for glib::Value {
    #[inline]
    fn from(v: SettingWirelessSecurityFils) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// These flags indicate whether PMF must be enabled.
#[cfg(feature = "v1_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSettingWirelessSecurityPmf")]
pub enum SettingWirelessSecurityPmf {
    /// use the default value
    #[doc(alias = "NM_SETTING_WIRELESS_SECURITY_PMF_DEFAULT")]
    Default,
    /// disable PMF
    #[doc(alias = "NM_SETTING_WIRELESS_SECURITY_PMF_DISABLE")]
    Disable,
    /// enable PMF if the supplicant and the AP support it
    #[doc(alias = "NM_SETTING_WIRELESS_SECURITY_PMF_OPTIONAL")]
    Optional,
    /// require PMF and fail if not available
    #[doc(alias = "NM_SETTING_WIRELESS_SECURITY_PMF_REQUIRED")]
    Required,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v1_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
#[doc(hidden)]
impl IntoGlib for SettingWirelessSecurityPmf {
    type GlibType = ffi::NMSettingWirelessSecurityPmf;

    #[inline]
    fn into_glib(self) -> ffi::NMSettingWirelessSecurityPmf {
        match self {
            Self::Default => ffi::NM_SETTING_WIRELESS_SECURITY_PMF_DEFAULT,
            Self::Disable => ffi::NM_SETTING_WIRELESS_SECURITY_PMF_DISABLE,
            Self::Optional => ffi::NM_SETTING_WIRELESS_SECURITY_PMF_OPTIONAL,
            Self::Required => ffi::NM_SETTING_WIRELESS_SECURITY_PMF_REQUIRED,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v1_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
#[doc(hidden)]
impl FromGlib<ffi::NMSettingWirelessSecurityPmf> for SettingWirelessSecurityPmf {
    #[inline]
    unsafe fn from_glib(value: ffi::NMSettingWirelessSecurityPmf) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_SETTING_WIRELESS_SECURITY_PMF_DEFAULT => Self::Default,
            ffi::NM_SETTING_WIRELESS_SECURITY_PMF_DISABLE => Self::Disable,
            ffi::NM_SETTING_WIRELESS_SECURITY_PMF_OPTIONAL => Self::Optional,
            ffi::NM_SETTING_WIRELESS_SECURITY_PMF_REQUIRED => Self::Required,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v1_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
impl StaticType for SettingWirelessSecurityPmf {
    #[inline]
    #[doc(alias = "nm_setting_wireless_security_pmf_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_setting_wireless_security_pmf_get_type()) }
    }
}

#[cfg(feature = "v1_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
impl glib::HasParamSpec for SettingWirelessSecurityPmf {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v1_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
impl glib::value::ValueType for SettingWirelessSecurityPmf {
    type Type = Self;
}

#[cfg(feature = "v1_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
unsafe impl<'a> glib::value::FromValue<'a> for SettingWirelessSecurityPmf {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
impl ToValue for SettingWirelessSecurityPmf {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
impl From<SettingWirelessSecurityPmf> for glib::Value {
    #[inline]
    fn from(v: SettingWirelessSecurityPmf) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// Errors related to the settings/persistent configuration interface of
/// NetworkManager.
///
/// These may be returned from #NMClient methods that invoke D-Bus operations on
/// the "org.freedesktop.NetworkManager.Settings" interface, and correspond to
/// D-Bus errors in that namespace.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSettingsError")]
pub enum SettingsError {
    /// unknown or unclassified error
    #[doc(alias = "NM_SETTINGS_ERROR_FAILED")]
    Failed,
    /// permission denied
    #[doc(alias = "NM_SETTINGS_ERROR_PERMISSION_DENIED")]
    PermissionDenied,
    /// the requested operation is not supported by any
    ///   active settings backend
    #[doc(alias = "NM_SETTINGS_ERROR_NOT_SUPPORTED")]
    NotSupported,
    /// the connection was invalid
    #[doc(alias = "NM_SETTINGS_ERROR_INVALID_CONNECTION")]
    InvalidConnection,
    /// attempted to modify a read-only connection
    #[doc(alias = "NM_SETTINGS_ERROR_READ_ONLY_CONNECTION")]
    ReadOnlyConnection,
    /// a connection with that UUID already exists
    #[doc(alias = "NM_SETTINGS_ERROR_UUID_EXISTS")]
    UuidExists,
    /// attempted to set an invalid hostname
    #[doc(alias = "NM_SETTINGS_ERROR_INVALID_HOSTNAME")]
    InvalidHostname,
    /// invalid arguments
    #[doc(alias = "NM_SETTINGS_ERROR_INVALID_ARGUMENTS")]
    InvalidArguments,
    /// The profile's VersionId mismatched
    ///   and the update is rejected. See the "version-id" argument to Update2()
    ///   method. Since 1.44.
    #[doc(alias = "NM_SETTINGS_ERROR_VERSION_ID_MISMATCH")]
    VersionIdMismatch,
    /// the requested operation is not
    ///   supported by the settings plugin currently in use for the specified object.
    ///   Since: 1.44.
    #[doc(alias = "NM_SETTINGS_ERROR_NOT_SUPPORTED_BY_PLUGIN")]
    NotSupportedByPlugin,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for SettingsError {
    type GlibType = ffi::NMSettingsError;

    #[inline]
    fn into_glib(self) -> ffi::NMSettingsError {
        match self {
            Self::Failed => ffi::NM_SETTINGS_ERROR_FAILED,
            Self::PermissionDenied => ffi::NM_SETTINGS_ERROR_PERMISSION_DENIED,
            Self::NotSupported => ffi::NM_SETTINGS_ERROR_NOT_SUPPORTED,
            Self::InvalidConnection => ffi::NM_SETTINGS_ERROR_INVALID_CONNECTION,
            Self::ReadOnlyConnection => ffi::NM_SETTINGS_ERROR_READ_ONLY_CONNECTION,
            Self::UuidExists => ffi::NM_SETTINGS_ERROR_UUID_EXISTS,
            Self::InvalidHostname => ffi::NM_SETTINGS_ERROR_INVALID_HOSTNAME,
            Self::InvalidArguments => ffi::NM_SETTINGS_ERROR_INVALID_ARGUMENTS,
            Self::VersionIdMismatch => ffi::NM_SETTINGS_ERROR_VERSION_ID_MISMATCH,
            Self::NotSupportedByPlugin => ffi::NM_SETTINGS_ERROR_NOT_SUPPORTED_BY_PLUGIN,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMSettingsError> for SettingsError {
    #[inline]
    unsafe fn from_glib(value: ffi::NMSettingsError) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_SETTINGS_ERROR_FAILED => Self::Failed,
            ffi::NM_SETTINGS_ERROR_PERMISSION_DENIED => Self::PermissionDenied,
            ffi::NM_SETTINGS_ERROR_NOT_SUPPORTED => Self::NotSupported,
            ffi::NM_SETTINGS_ERROR_INVALID_CONNECTION => Self::InvalidConnection,
            ffi::NM_SETTINGS_ERROR_READ_ONLY_CONNECTION => Self::ReadOnlyConnection,
            ffi::NM_SETTINGS_ERROR_UUID_EXISTS => Self::UuidExists,
            ffi::NM_SETTINGS_ERROR_INVALID_HOSTNAME => Self::InvalidHostname,
            ffi::NM_SETTINGS_ERROR_INVALID_ARGUMENTS => Self::InvalidArguments,
            ffi::NM_SETTINGS_ERROR_VERSION_ID_MISMATCH => Self::VersionIdMismatch,
            ffi::NM_SETTINGS_ERROR_NOT_SUPPORTED_BY_PLUGIN => Self::NotSupportedByPlugin,
            value => Self::__Unknown(value),
        }
    }
}

impl glib::error::ErrorDomain for SettingsError {
    #[inline]
    fn domain() -> glib::Quark {
        skip_assert_initialized!();

        unsafe { from_glib(ffi::nm_settings_error_quark()) }
    }

    #[inline]
    fn code(self) -> i32 {
        self.into_glib()
    }

    #[inline]
    #[allow(clippy::match_single_binding)]
    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match unsafe { from_glib(code) } {
            Self::__Unknown(_) => Some(Self::Failed),
            value => Some(value),
        }
    }
}

impl StaticType for SettingsError {
    #[inline]
    #[doc(alias = "nm_settings_error_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_settings_error_get_type()) }
    }
}

impl glib::HasParamSpec for SettingsError {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for SettingsError {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for SettingsError {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for SettingsError {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<SettingsError> for glib::Value {
    #[inline]
    fn from(v: SettingsError) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v1_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSriovEswitchEncapMode")]
pub enum SriovEswitchEncapMode {
    /// don't modify current encap-mode
    #[doc(alias = "NM_SRIOV_ESWITCH_ENCAP_MODE_PRESERVE")]
    Preserve,
    /// disable encapsulation mode
    #[doc(alias = "NM_SRIOV_ESWITCH_ENCAP_MODE_NONE")]
    None,
    /// enable encapsulation mode
    #[doc(alias = "NM_SRIOV_ESWITCH_ENCAP_MODE_BASIC")]
    Basic,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v1_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
#[doc(hidden)]
impl IntoGlib for SriovEswitchEncapMode {
    type GlibType = ffi::NMSriovEswitchEncapMode;

    #[inline]
    fn into_glib(self) -> ffi::NMSriovEswitchEncapMode {
        match self {
            Self::Preserve => ffi::NM_SRIOV_ESWITCH_ENCAP_MODE_PRESERVE,
            Self::None => ffi::NM_SRIOV_ESWITCH_ENCAP_MODE_NONE,
            Self::Basic => ffi::NM_SRIOV_ESWITCH_ENCAP_MODE_BASIC,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v1_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
#[doc(hidden)]
impl FromGlib<ffi::NMSriovEswitchEncapMode> for SriovEswitchEncapMode {
    #[inline]
    unsafe fn from_glib(value: ffi::NMSriovEswitchEncapMode) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_SRIOV_ESWITCH_ENCAP_MODE_PRESERVE => Self::Preserve,
            ffi::NM_SRIOV_ESWITCH_ENCAP_MODE_NONE => Self::None,
            ffi::NM_SRIOV_ESWITCH_ENCAP_MODE_BASIC => Self::Basic,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v1_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
impl StaticType for SriovEswitchEncapMode {
    #[inline]
    #[doc(alias = "nm_sriov_eswitch_encap_mode_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_sriov_eswitch_encap_mode_get_type()) }
    }
}

#[cfg(feature = "v1_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
impl glib::HasParamSpec for SriovEswitchEncapMode {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v1_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
impl glib::value::ValueType for SriovEswitchEncapMode {
    type Type = Self;
}

#[cfg(feature = "v1_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
unsafe impl<'a> glib::value::FromValue<'a> for SriovEswitchEncapMode {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
impl ToValue for SriovEswitchEncapMode {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
impl From<SriovEswitchEncapMode> for glib::Value {
    #[inline]
    fn from(v: SriovEswitchEncapMode) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v1_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSriovEswitchInlineMode")]
pub enum SriovEswitchInlineMode {
    /// don't modify current inline-mode
    #[doc(alias = "NM_SRIOV_ESWITCH_INLINE_MODE_PRESERVE")]
    Preserve,
    /// don't use inline mode
    #[doc(alias = "NM_SRIOV_ESWITCH_INLINE_MODE_NONE")]
    None,
    /// L2 mode
    #[doc(alias = "NM_SRIOV_ESWITCH_INLINE_MODE_LINK")]
    Link,
    /// L3 mode
    #[doc(alias = "NM_SRIOV_ESWITCH_INLINE_MODE_NETWORK")]
    Network,
    /// L4 mode
    #[doc(alias = "NM_SRIOV_ESWITCH_INLINE_MODE_TRANSPORT")]
    Transport,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v1_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
#[doc(hidden)]
impl IntoGlib for SriovEswitchInlineMode {
    type GlibType = ffi::NMSriovEswitchInlineMode;

    #[inline]
    fn into_glib(self) -> ffi::NMSriovEswitchInlineMode {
        match self {
            Self::Preserve => ffi::NM_SRIOV_ESWITCH_INLINE_MODE_PRESERVE,
            Self::None => ffi::NM_SRIOV_ESWITCH_INLINE_MODE_NONE,
            Self::Link => ffi::NM_SRIOV_ESWITCH_INLINE_MODE_LINK,
            Self::Network => ffi::NM_SRIOV_ESWITCH_INLINE_MODE_NETWORK,
            Self::Transport => ffi::NM_SRIOV_ESWITCH_INLINE_MODE_TRANSPORT,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v1_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
#[doc(hidden)]
impl FromGlib<ffi::NMSriovEswitchInlineMode> for SriovEswitchInlineMode {
    #[inline]
    unsafe fn from_glib(value: ffi::NMSriovEswitchInlineMode) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_SRIOV_ESWITCH_INLINE_MODE_PRESERVE => Self::Preserve,
            ffi::NM_SRIOV_ESWITCH_INLINE_MODE_NONE => Self::None,
            ffi::NM_SRIOV_ESWITCH_INLINE_MODE_LINK => Self::Link,
            ffi::NM_SRIOV_ESWITCH_INLINE_MODE_NETWORK => Self::Network,
            ffi::NM_SRIOV_ESWITCH_INLINE_MODE_TRANSPORT => Self::Transport,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v1_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
impl StaticType for SriovEswitchInlineMode {
    #[inline]
    #[doc(alias = "nm_sriov_eswitch_inline_mode_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_sriov_eswitch_inline_mode_get_type()) }
    }
}

#[cfg(feature = "v1_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
impl glib::HasParamSpec for SriovEswitchInlineMode {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v1_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
impl glib::value::ValueType for SriovEswitchInlineMode {
    type Type = Self;
}

#[cfg(feature = "v1_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
unsafe impl<'a> glib::value::FromValue<'a> for SriovEswitchInlineMode {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
impl ToValue for SriovEswitchInlineMode {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
impl From<SriovEswitchInlineMode> for glib::Value {
    #[inline]
    fn from(v: SriovEswitchInlineMode) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v1_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSriovEswitchMode")]
pub enum SriovEswitchMode {
    /// don't modify current eswitch mode
    #[doc(alias = "NM_SRIOV_ESWITCH_MODE_PRESERVE")]
    Preserve,
    /// use legacy SRIOV
    #[doc(alias = "NM_SRIOV_ESWITCH_MODE_LEGACY")]
    Legacy,
    /// use switchdev mode
    #[doc(alias = "NM_SRIOV_ESWITCH_MODE_SWITCHDEV")]
    Switchdev,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v1_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
#[doc(hidden)]
impl IntoGlib for SriovEswitchMode {
    type GlibType = ffi::NMSriovEswitchMode;

    #[inline]
    fn into_glib(self) -> ffi::NMSriovEswitchMode {
        match self {
            Self::Preserve => ffi::NM_SRIOV_ESWITCH_MODE_PRESERVE,
            Self::Legacy => ffi::NM_SRIOV_ESWITCH_MODE_LEGACY,
            Self::Switchdev => ffi::NM_SRIOV_ESWITCH_MODE_SWITCHDEV,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v1_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
#[doc(hidden)]
impl FromGlib<ffi::NMSriovEswitchMode> for SriovEswitchMode {
    #[inline]
    unsafe fn from_glib(value: ffi::NMSriovEswitchMode) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_SRIOV_ESWITCH_MODE_PRESERVE => Self::Preserve,
            ffi::NM_SRIOV_ESWITCH_MODE_LEGACY => Self::Legacy,
            ffi::NM_SRIOV_ESWITCH_MODE_SWITCHDEV => Self::Switchdev,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v1_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
impl StaticType for SriovEswitchMode {
    #[inline]
    #[doc(alias = "nm_sriov_eswitch_mode_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_sriov_eswitch_mode_get_type()) }
    }
}

#[cfg(feature = "v1_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
impl glib::HasParamSpec for SriovEswitchMode {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v1_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
impl glib::value::ValueType for SriovEswitchMode {
    type Type = Self;
}

#[cfg(feature = "v1_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
unsafe impl<'a> glib::value::FromValue<'a> for SriovEswitchMode {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
impl ToValue for SriovEswitchMode {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
impl From<SriovEswitchMode> for glib::Value {
    #[inline]
    fn from(v: SriovEswitchMode) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v1_54")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_54")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSriovPreserveOnDown")]
pub enum SriovPreserveOnDown {
    /// use the default value
    #[doc(alias = "NM_SRIOV_PRESERVE_ON_DOWN_DEFAULT")]
    Default,
    /// reset the SR-IOV parameters when the
    ///     connection is deactivated
    #[doc(alias = "NM_SRIOV_PRESERVE_ON_DOWN_NO")]
    No,
    /// preserve the SR-IOV parameters set on
    /// the device when the connection is deactivated
    #[doc(alias = "NM_SRIOV_PRESERVE_ON_DOWN_YES")]
    Yes,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v1_54")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_54")))]
#[doc(hidden)]
impl IntoGlib for SriovPreserveOnDown {
    type GlibType = ffi::NMSriovPreserveOnDown;

    #[inline]
    fn into_glib(self) -> ffi::NMSriovPreserveOnDown {
        match self {
            Self::Default => ffi::NM_SRIOV_PRESERVE_ON_DOWN_DEFAULT,
            Self::No => ffi::NM_SRIOV_PRESERVE_ON_DOWN_NO,
            Self::Yes => ffi::NM_SRIOV_PRESERVE_ON_DOWN_YES,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v1_54")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_54")))]
#[doc(hidden)]
impl FromGlib<ffi::NMSriovPreserveOnDown> for SriovPreserveOnDown {
    #[inline]
    unsafe fn from_glib(value: ffi::NMSriovPreserveOnDown) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_SRIOV_PRESERVE_ON_DOWN_DEFAULT => Self::Default,
            ffi::NM_SRIOV_PRESERVE_ON_DOWN_NO => Self::No,
            ffi::NM_SRIOV_PRESERVE_ON_DOWN_YES => Self::Yes,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v1_54")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_54")))]
impl StaticType for SriovPreserveOnDown {
    #[inline]
    #[doc(alias = "nm_sriov_preserve_on_down_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_sriov_preserve_on_down_get_type()) }
    }
}

#[cfg(feature = "v1_54")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_54")))]
impl glib::HasParamSpec for SriovPreserveOnDown {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v1_54")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_54")))]
impl glib::value::ValueType for SriovPreserveOnDown {
    type Type = Self;
}

#[cfg(feature = "v1_54")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_54")))]
unsafe impl<'a> glib::value::FromValue<'a> for SriovPreserveOnDown {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_54")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_54")))]
impl ToValue for SriovPreserveOnDown {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_54")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_54")))]
impl From<SriovPreserveOnDown> for glib::Value {
    #[inline]
    fn from(v: SriovPreserveOnDown) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// #NMSriovVFVlanProtocol indicates the VLAN protocol to use.
#[cfg(feature = "v1_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMSriovVFVlanProtocol")]
pub enum SriovVFVlanProtocol {
    /// use 802.1Q
    #[doc(alias = "NM_SRIOV_VF_VLAN_PROTOCOL_802_1Q")]
    _1q,
    /// use 802.1ad
    #[doc(alias = "NM_SRIOV_VF_VLAN_PROTOCOL_802_1AD")]
    _1ad,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v1_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
#[doc(hidden)]
impl IntoGlib for SriovVFVlanProtocol {
    type GlibType = ffi::NMSriovVFVlanProtocol;

    #[inline]
    fn into_glib(self) -> ffi::NMSriovVFVlanProtocol {
        match self {
            Self::_1q => ffi::NM_SRIOV_VF_VLAN_PROTOCOL_802_1Q,
            Self::_1ad => ffi::NM_SRIOV_VF_VLAN_PROTOCOL_802_1AD,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v1_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
#[doc(hidden)]
impl FromGlib<ffi::NMSriovVFVlanProtocol> for SriovVFVlanProtocol {
    #[inline]
    unsafe fn from_glib(value: ffi::NMSriovVFVlanProtocol) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_SRIOV_VF_VLAN_PROTOCOL_802_1Q => Self::_1q,
            ffi::NM_SRIOV_VF_VLAN_PROTOCOL_802_1AD => Self::_1ad,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v1_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
impl StaticType for SriovVFVlanProtocol {
    #[inline]
    #[doc(alias = "nm_sriov_vf_vlan_protocol_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_sriov_vf_vlan_protocol_get_type()) }
    }
}

#[cfg(feature = "v1_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
impl glib::HasParamSpec for SriovVFVlanProtocol {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v1_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
impl glib::value::ValueType for SriovVFVlanProtocol {
    type Type = Self;
}

#[cfg(feature = "v1_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
unsafe impl<'a> glib::value::FromValue<'a> for SriovVFVlanProtocol {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
impl ToValue for SriovVFVlanProtocol {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
impl From<SriovVFVlanProtocol> for glib::Value {
    #[inline]
    fn from(v: SriovVFVlanProtocol) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// #NMState values indicate the current overall networking state.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMState")]
pub enum State {
    /// Networking state is unknown. This indicates a daemon error
    ///    that makes it unable to reasonably assess the state. In such event the
    ///    applications are expected to assume Internet connectivity might be present
    ///    and not disable controls that require network access.
    ///    The graphical shells may hide the network accessibility indicator altogether
    ///    since no meaningful status indication can be provided.
    #[doc(alias = "NM_STATE_UNKNOWN")]
    Unknown,
    /// Networking is not enabled, the system is being suspended or
    ///    resumed from suspend.
    #[doc(alias = "NM_STATE_ASLEEP")]
    Asleep,
    /// There is no active network connection.
    ///    The graphical shell should indicate  no network connectivity and the
    ///    applications should not attempt to access the network.
    #[doc(alias = "NM_STATE_DISCONNECTED")]
    Disconnected,
    /// Network connections are being cleaned up.
    ///    The applications should tear down their network sessions.
    #[doc(alias = "NM_STATE_DISCONNECTING")]
    Disconnecting,
    /// A network connection is being started
    ///    The graphical shell should indicate the network is being connected while
    ///    the applications should still make no attempts to connect the network.
    #[doc(alias = "NM_STATE_CONNECTING")]
    Connecting,
    /// There is only local IPv4 and/or IPv6 connectivity,
    ///    but no default route to access the Internet. The graphical shell should
    ///    indicate no network connectivity.
    #[doc(alias = "NM_STATE_CONNECTED_LOCAL")]
    ConnectedLocal,
    /// There is only site-wide IPv4 and/or IPv6 connectivity.
    ///    This means a default route is available, but the Internet connectivity check
    ///    (see "Connectivity" property) did not succeed. The graphical shell should
    ///    indicate limited network connectivity.
    #[doc(alias = "NM_STATE_CONNECTED_SITE")]
    ConnectedSite,
    /// There is global IPv4 and/or IPv6 Internet connectivity
    ///    This means the Internet connectivity check succeeded, the graphical shell should
    ///    indicate full network connectivity.
    #[doc(alias = "NM_STATE_CONNECTED_GLOBAL")]
    ConnectedGlobal,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for State {
    type GlibType = ffi::NMState;

    #[inline]
    fn into_glib(self) -> ffi::NMState {
        match self {
            Self::Unknown => ffi::NM_STATE_UNKNOWN,
            Self::Asleep => ffi::NM_STATE_ASLEEP,
            Self::Disconnected => ffi::NM_STATE_DISCONNECTED,
            Self::Disconnecting => ffi::NM_STATE_DISCONNECTING,
            Self::Connecting => ffi::NM_STATE_CONNECTING,
            Self::ConnectedLocal => ffi::NM_STATE_CONNECTED_LOCAL,
            Self::ConnectedSite => ffi::NM_STATE_CONNECTED_SITE,
            Self::ConnectedGlobal => ffi::NM_STATE_CONNECTED_GLOBAL,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMState> for State {
    #[inline]
    unsafe fn from_glib(value: ffi::NMState) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_STATE_UNKNOWN => Self::Unknown,
            ffi::NM_STATE_ASLEEP => Self::Asleep,
            ffi::NM_STATE_DISCONNECTED => Self::Disconnected,
            ffi::NM_STATE_DISCONNECTING => Self::Disconnecting,
            ffi::NM_STATE_CONNECTING => Self::Connecting,
            ffi::NM_STATE_CONNECTED_LOCAL => Self::ConnectedLocal,
            ffi::NM_STATE_CONNECTED_SITE => Self::ConnectedSite,
            ffi::NM_STATE_CONNECTED_GLOBAL => Self::ConnectedGlobal,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for State {
    #[inline]
    #[doc(alias = "nm_state_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_state_get_type()) }
    }
}

impl glib::HasParamSpec for State {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for State {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for State {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for State {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<State> for glib::Value {
    #[inline]
    fn from(v: State) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// An boolean value that can be overridden by a default.
#[cfg(feature = "v1_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMTernary")]
pub enum Ternary {
    /// use the globally-configured default value.
    #[doc(alias = "NM_TERNARY_DEFAULT")]
    Default,
    /// the option is disabled.
    #[doc(alias = "NM_TERNARY_FALSE")]
    False,
    /// the option is enabled.
    #[doc(alias = "NM_TERNARY_TRUE")]
    True,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v1_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
#[doc(hidden)]
impl IntoGlib for Ternary {
    type GlibType = ffi::NMTernary;

    #[inline]
    fn into_glib(self) -> ffi::NMTernary {
        match self {
            Self::Default => ffi::NM_TERNARY_DEFAULT,
            Self::False => ffi::NM_TERNARY_FALSE,
            Self::True => ffi::NM_TERNARY_TRUE,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v1_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
#[doc(hidden)]
impl FromGlib<ffi::NMTernary> for Ternary {
    #[inline]
    unsafe fn from_glib(value: ffi::NMTernary) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_TERNARY_DEFAULT => Self::Default,
            ffi::NM_TERNARY_FALSE => Self::False,
            ffi::NM_TERNARY_TRUE => Self::True,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v1_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
impl StaticType for Ternary {
    #[inline]
    #[doc(alias = "nm_ternary_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_ternary_get_type()) }
    }
}

#[cfg(feature = "v1_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
impl glib::HasParamSpec for Ternary {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v1_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
impl glib::value::ValueType for Ternary {
    type Type = Self;
}

#[cfg(feature = "v1_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
unsafe impl<'a> glib::value::FromValue<'a> for Ternary {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
impl ToValue for Ternary {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
impl From<Ternary> for glib::Value {
    #[inline]
    fn from(v: Ternary) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// Describes generic security mechanisms that 802.11 access points may offer.
/// Used with nm_utils_security_valid() for checking whether a given access
/// point is compatible with a network device.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMUtilsSecurityType")]
pub enum UtilsSecurityType {
    /// unknown or invalid security, placeholder and not used
    #[doc(alias = "NMU_SEC_INVALID")]
    Invalid,
    /// unencrypted and open
    #[doc(alias = "NMU_SEC_NONE")]
    None,
    /// static WEP keys are used for encryption
    #[doc(alias = "NMU_SEC_STATIC_WEP")]
    StaticWep,
    /// Cisco LEAP is used for authentication and for generating the
    /// dynamic WEP keys automatically
    #[doc(alias = "NMU_SEC_LEAP")]
    Leap,
    /// standard 802.1x is used for authentication and
    /// generating the dynamic WEP keys automatically
    #[doc(alias = "NMU_SEC_DYNAMIC_WEP")]
    DynamicWep,
    /// WPA1 is used with Pre-Shared Keys (PSK)
    #[doc(alias = "NMU_SEC_WPA_PSK")]
    WpaPsk,
    /// WPA1 is used with 802.1x authentication
    #[doc(alias = "NMU_SEC_WPA_ENTERPRISE")]
    WpaEnterprise,
    /// WPA2/RSN is used with Pre-Shared Keys (PSK)
    #[doc(alias = "NMU_SEC_WPA2_PSK")]
    Wpa2Psk,
    /// WPA2 is used with 802.1x authentication
    #[doc(alias = "NMU_SEC_WPA2_ENTERPRISE")]
    Wpa2Enterprise,
    /// is used with WPA3 Enterprise
    #[doc(alias = "NMU_SEC_SAE")]
    Sae,
    /// is used with Enhanced Open
    #[doc(alias = "NMU_SEC_OWE")]
    Owe,
    /// is used with WPA3 Enterprise Suite-B 192 bit mode. Since: 1.30.
    #[doc(alias = "NMU_SEC_WPA3_SUITE_B_192")]
    Wpa3SuiteB192,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for UtilsSecurityType {
    type GlibType = ffi::NMUtilsSecurityType;

    #[inline]
    fn into_glib(self) -> ffi::NMUtilsSecurityType {
        match self {
            Self::Invalid => ffi::NMU_SEC_INVALID,
            Self::None => ffi::NMU_SEC_NONE,
            Self::StaticWep => ffi::NMU_SEC_STATIC_WEP,
            Self::Leap => ffi::NMU_SEC_LEAP,
            Self::DynamicWep => ffi::NMU_SEC_DYNAMIC_WEP,
            Self::WpaPsk => ffi::NMU_SEC_WPA_PSK,
            Self::WpaEnterprise => ffi::NMU_SEC_WPA_ENTERPRISE,
            Self::Wpa2Psk => ffi::NMU_SEC_WPA2_PSK,
            Self::Wpa2Enterprise => ffi::NMU_SEC_WPA2_ENTERPRISE,
            Self::Sae => ffi::NMU_SEC_SAE,
            Self::Owe => ffi::NMU_SEC_OWE,
            Self::Wpa3SuiteB192 => ffi::NMU_SEC_WPA3_SUITE_B_192,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMUtilsSecurityType> for UtilsSecurityType {
    #[inline]
    unsafe fn from_glib(value: ffi::NMUtilsSecurityType) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NMU_SEC_INVALID => Self::Invalid,
            ffi::NMU_SEC_NONE => Self::None,
            ffi::NMU_SEC_STATIC_WEP => Self::StaticWep,
            ffi::NMU_SEC_LEAP => Self::Leap,
            ffi::NMU_SEC_DYNAMIC_WEP => Self::DynamicWep,
            ffi::NMU_SEC_WPA_PSK => Self::WpaPsk,
            ffi::NMU_SEC_WPA_ENTERPRISE => Self::WpaEnterprise,
            ffi::NMU_SEC_WPA2_PSK => Self::Wpa2Psk,
            ffi::NMU_SEC_WPA2_ENTERPRISE => Self::Wpa2Enterprise,
            ffi::NMU_SEC_SAE => Self::Sae,
            ffi::NMU_SEC_OWE => Self::Owe,
            ffi::NMU_SEC_WPA3_SUITE_B_192 => Self::Wpa3SuiteB192,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for UtilsSecurityType {
    #[inline]
    #[doc(alias = "nm_utils_security_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_utils_security_type_get_type()) }
    }
}

impl glib::HasParamSpec for UtilsSecurityType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for UtilsSecurityType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for UtilsSecurityType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for UtilsSecurityType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<UtilsSecurityType> for glib::Value {
    #[inline]
    fn from(v: UtilsSecurityType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// The numeric values represent the bit index of the capability. These capabilities
/// can be queried in the "VersionInfo" D-Bus property.
#[cfg(feature = "v1_42")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMVersionInfoCapability")]
pub enum VersionInfoCapability {
    /// Contains the fix to a bug that
    ///   caused that routes in table other than main were not removed on reapply nor
    ///   on connection down.
    ///   https://issues.redhat.com/browse/RHEL-66262
    ///   https://issues.redhat.com/browse/RHEL-67324
    #[doc(alias = "NM_VERSION_INFO_CAPABILITY_SYNC_ROUTE_WITH_TABLE")]
    SyncRouteWithTable,
    /// Indicates that NetworkManager supports
    /// configuring per-device IPv4 sysctl forwarding setting. Since: 1.54.
    #[doc(alias = "NM_VERSION_INFO_CAPABILITY_IP4_FORWARDING")]
    Ip4Forwarding,
    /// NetworkManager supports the
    ///   "sriov.preserve-on-down" property. Since: 1.54
    #[doc(alias = "NM_VERSION_INFO_CAPABILITY_SRIOV_PRESERVE_ON_DOWN")]
    SriovPreserveOnDown,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v1_42")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
#[doc(hidden)]
impl IntoGlib for VersionInfoCapability {
    type GlibType = ffi::NMVersionInfoCapability;

    #[inline]
    fn into_glib(self) -> ffi::NMVersionInfoCapability {
        match self {
            Self::SyncRouteWithTable => ffi::NM_VERSION_INFO_CAPABILITY_SYNC_ROUTE_WITH_TABLE,
            Self::Ip4Forwarding => ffi::NM_VERSION_INFO_CAPABILITY_IP4_FORWARDING,
            Self::SriovPreserveOnDown => ffi::NM_VERSION_INFO_CAPABILITY_SRIOV_PRESERVE_ON_DOWN,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v1_42")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
#[doc(hidden)]
impl FromGlib<ffi::NMVersionInfoCapability> for VersionInfoCapability {
    #[inline]
    unsafe fn from_glib(value: ffi::NMVersionInfoCapability) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_VERSION_INFO_CAPABILITY_SYNC_ROUTE_WITH_TABLE => Self::SyncRouteWithTable,
            ffi::NM_VERSION_INFO_CAPABILITY_IP4_FORWARDING => Self::Ip4Forwarding,
            ffi::NM_VERSION_INFO_CAPABILITY_SRIOV_PRESERVE_ON_DOWN => Self::SriovPreserveOnDown,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v1_42")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
impl StaticType for VersionInfoCapability {
    #[inline]
    #[doc(alias = "nm_version_info_capability_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_version_info_capability_get_type()) }
    }
}

#[cfg(feature = "v1_42")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
impl glib::HasParamSpec for VersionInfoCapability {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v1_42")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
impl glib::value::ValueType for VersionInfoCapability {
    type Type = Self;
}

#[cfg(feature = "v1_42")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
unsafe impl<'a> glib::value::FromValue<'a> for VersionInfoCapability {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_42")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
impl ToValue for VersionInfoCapability {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_42")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
impl From<VersionInfoCapability> for glib::Value {
    #[inline]
    fn from(v: VersionInfoCapability) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// A selector for traffic priority maps; these map Linux SKB priorities
/// to 802.1p priorities used in VLANs.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMVlanPriorityMap")]
pub enum VlanPriorityMap {
    /// map for incoming data
    #[doc(alias = "NM_VLAN_INGRESS_MAP")]
    IngressMap,
    /// map for outgoing data
    #[doc(alias = "NM_VLAN_EGRESS_MAP")]
    EgressMap,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for VlanPriorityMap {
    type GlibType = ffi::NMVlanPriorityMap;

    #[inline]
    fn into_glib(self) -> ffi::NMVlanPriorityMap {
        match self {
            Self::IngressMap => ffi::NM_VLAN_INGRESS_MAP,
            Self::EgressMap => ffi::NM_VLAN_EGRESS_MAP,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMVlanPriorityMap> for VlanPriorityMap {
    #[inline]
    unsafe fn from_glib(value: ffi::NMVlanPriorityMap) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_VLAN_INGRESS_MAP => Self::IngressMap,
            ffi::NM_VLAN_EGRESS_MAP => Self::EgressMap,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for VlanPriorityMap {
    #[inline]
    #[doc(alias = "nm_vlan_priority_map_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_vlan_priority_map_get_type()) }
    }
}

impl glib::HasParamSpec for VlanPriorityMap {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for VlanPriorityMap {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for VlanPriorityMap {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for VlanPriorityMap {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<VlanPriorityMap> for glib::Value {
    #[inline]
    fn from(v: VlanPriorityMap) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// VPN connection states
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMVpnConnectionState")]
pub enum VpnConnectionState {
    /// The state of the VPN connection is
    ///   unknown.
    #[doc(alias = "NM_VPN_CONNECTION_STATE_UNKNOWN")]
    Unknown,
    /// The VPN connection is preparing to
    ///   connect.
    #[doc(alias = "NM_VPN_CONNECTION_STATE_PREPARE")]
    Prepare,
    /// The VPN connection needs authorization
    ///   credentials.
    #[doc(alias = "NM_VPN_CONNECTION_STATE_NEED_AUTH")]
    NeedAuth,
    /// The VPN connection is being established.
    #[doc(alias = "NM_VPN_CONNECTION_STATE_CONNECT")]
    Connect,
    /// The VPN connection is getting an IP
    ///   address.
    #[doc(alias = "NM_VPN_CONNECTION_STATE_IP_CONFIG_GET")]
    IpConfigGet,
    /// The VPN connection is active.
    #[doc(alias = "NM_VPN_CONNECTION_STATE_ACTIVATED")]
    Activated,
    /// The VPN connection failed.
    #[doc(alias = "NM_VPN_CONNECTION_STATE_FAILED")]
    Failed,
    /// The VPN connection is disconnected.
    #[doc(alias = "NM_VPN_CONNECTION_STATE_DISCONNECTED")]
    Disconnected,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for VpnConnectionState {
    type GlibType = ffi::NMVpnConnectionState;

    #[inline]
    fn into_glib(self) -> ffi::NMVpnConnectionState {
        match self {
            Self::Unknown => ffi::NM_VPN_CONNECTION_STATE_UNKNOWN,
            Self::Prepare => ffi::NM_VPN_CONNECTION_STATE_PREPARE,
            Self::NeedAuth => ffi::NM_VPN_CONNECTION_STATE_NEED_AUTH,
            Self::Connect => ffi::NM_VPN_CONNECTION_STATE_CONNECT,
            Self::IpConfigGet => ffi::NM_VPN_CONNECTION_STATE_IP_CONFIG_GET,
            Self::Activated => ffi::NM_VPN_CONNECTION_STATE_ACTIVATED,
            Self::Failed => ffi::NM_VPN_CONNECTION_STATE_FAILED,
            Self::Disconnected => ffi::NM_VPN_CONNECTION_STATE_DISCONNECTED,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMVpnConnectionState> for VpnConnectionState {
    #[inline]
    unsafe fn from_glib(value: ffi::NMVpnConnectionState) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_VPN_CONNECTION_STATE_UNKNOWN => Self::Unknown,
            ffi::NM_VPN_CONNECTION_STATE_PREPARE => Self::Prepare,
            ffi::NM_VPN_CONNECTION_STATE_NEED_AUTH => Self::NeedAuth,
            ffi::NM_VPN_CONNECTION_STATE_CONNECT => Self::Connect,
            ffi::NM_VPN_CONNECTION_STATE_IP_CONFIG_GET => Self::IpConfigGet,
            ffi::NM_VPN_CONNECTION_STATE_ACTIVATED => Self::Activated,
            ffi::NM_VPN_CONNECTION_STATE_FAILED => Self::Failed,
            ffi::NM_VPN_CONNECTION_STATE_DISCONNECTED => Self::Disconnected,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for VpnConnectionState {
    #[inline]
    #[doc(alias = "nm_vpn_connection_state_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_vpn_connection_state_get_type()) }
    }
}

impl glib::HasParamSpec for VpnConnectionState {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for VpnConnectionState {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for VpnConnectionState {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for VpnConnectionState {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<VpnConnectionState> for glib::Value {
    #[inline]
    fn from(v: VpnConnectionState) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// VPN connection state reasons
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMVpnConnectionStateReason")]
pub enum VpnConnectionStateReason {
    /// The reason for the VPN connection
    ///   state change is unknown.
    #[doc(alias = "NM_VPN_CONNECTION_STATE_REASON_UNKNOWN")]
    Unknown,
    /// No reason was given for the VPN
    ///   connection state change.
    #[doc(alias = "NM_VPN_CONNECTION_STATE_REASON_NONE")]
    None,
    /// The VPN connection changed
    ///   state because the user disconnected it.
    #[doc(alias = "NM_VPN_CONNECTION_STATE_REASON_USER_DISCONNECTED")]
    UserDisconnected,
    /// The VPN connection
    ///   changed state because the device it was using was disconnected.
    #[doc(alias = "NM_VPN_CONNECTION_STATE_REASON_DEVICE_DISCONNECTED")]
    DeviceDisconnected,
    /// The service providing the
    ///   VPN connection was stopped.
    #[doc(alias = "NM_VPN_CONNECTION_STATE_REASON_SERVICE_STOPPED")]
    ServiceStopped,
    /// The IP config of the VPN
    ///   connection was invalid.
    #[doc(alias = "NM_VPN_CONNECTION_STATE_REASON_IP_CONFIG_INVALID")]
    IpConfigInvalid,
    /// The connection attempt to
    ///   the VPN service timed out.
    #[doc(alias = "NM_VPN_CONNECTION_STATE_REASON_CONNECT_TIMEOUT")]
    ConnectTimeout,
    /// A timeout occurred
    ///   while starting the service providing the VPN connection.
    #[doc(alias = "NM_VPN_CONNECTION_STATE_REASON_SERVICE_START_TIMEOUT")]
    ServiceStartTimeout,
    /// Starting the service
    ///   starting the service providing the VPN connection failed.
    #[doc(alias = "NM_VPN_CONNECTION_STATE_REASON_SERVICE_START_FAILED")]
    ServiceStartFailed,
    /// Necessary secrets for the VPN
    ///   connection were not provided.
    #[doc(alias = "NM_VPN_CONNECTION_STATE_REASON_NO_SECRETS")]
    NoSecrets,
    /// Authentication to the VPN
    ///   server failed.
    #[doc(alias = "NM_VPN_CONNECTION_STATE_REASON_LOGIN_FAILED")]
    LoginFailed,
    /// The connection was
    ///   deleted from settings.
    #[doc(alias = "NM_VPN_CONNECTION_STATE_REASON_CONNECTION_REMOVED")]
    ConnectionRemoved,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for VpnConnectionStateReason {
    type GlibType = ffi::NMVpnConnectionStateReason;

    #[inline]
    fn into_glib(self) -> ffi::NMVpnConnectionStateReason {
        match self {
            Self::Unknown => ffi::NM_VPN_CONNECTION_STATE_REASON_UNKNOWN,
            Self::None => ffi::NM_VPN_CONNECTION_STATE_REASON_NONE,
            Self::UserDisconnected => ffi::NM_VPN_CONNECTION_STATE_REASON_USER_DISCONNECTED,
            Self::DeviceDisconnected => ffi::NM_VPN_CONNECTION_STATE_REASON_DEVICE_DISCONNECTED,
            Self::ServiceStopped => ffi::NM_VPN_CONNECTION_STATE_REASON_SERVICE_STOPPED,
            Self::IpConfigInvalid => ffi::NM_VPN_CONNECTION_STATE_REASON_IP_CONFIG_INVALID,
            Self::ConnectTimeout => ffi::NM_VPN_CONNECTION_STATE_REASON_CONNECT_TIMEOUT,
            Self::ServiceStartTimeout => ffi::NM_VPN_CONNECTION_STATE_REASON_SERVICE_START_TIMEOUT,
            Self::ServiceStartFailed => ffi::NM_VPN_CONNECTION_STATE_REASON_SERVICE_START_FAILED,
            Self::NoSecrets => ffi::NM_VPN_CONNECTION_STATE_REASON_NO_SECRETS,
            Self::LoginFailed => ffi::NM_VPN_CONNECTION_STATE_REASON_LOGIN_FAILED,
            Self::ConnectionRemoved => ffi::NM_VPN_CONNECTION_STATE_REASON_CONNECTION_REMOVED,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMVpnConnectionStateReason> for VpnConnectionStateReason {
    #[inline]
    unsafe fn from_glib(value: ffi::NMVpnConnectionStateReason) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_VPN_CONNECTION_STATE_REASON_UNKNOWN => Self::Unknown,
            ffi::NM_VPN_CONNECTION_STATE_REASON_NONE => Self::None,
            ffi::NM_VPN_CONNECTION_STATE_REASON_USER_DISCONNECTED => Self::UserDisconnected,
            ffi::NM_VPN_CONNECTION_STATE_REASON_DEVICE_DISCONNECTED => Self::DeviceDisconnected,
            ffi::NM_VPN_CONNECTION_STATE_REASON_SERVICE_STOPPED => Self::ServiceStopped,
            ffi::NM_VPN_CONNECTION_STATE_REASON_IP_CONFIG_INVALID => Self::IpConfigInvalid,
            ffi::NM_VPN_CONNECTION_STATE_REASON_CONNECT_TIMEOUT => Self::ConnectTimeout,
            ffi::NM_VPN_CONNECTION_STATE_REASON_SERVICE_START_TIMEOUT => Self::ServiceStartTimeout,
            ffi::NM_VPN_CONNECTION_STATE_REASON_SERVICE_START_FAILED => Self::ServiceStartFailed,
            ffi::NM_VPN_CONNECTION_STATE_REASON_NO_SECRETS => Self::NoSecrets,
            ffi::NM_VPN_CONNECTION_STATE_REASON_LOGIN_FAILED => Self::LoginFailed,
            ffi::NM_VPN_CONNECTION_STATE_REASON_CONNECTION_REMOVED => Self::ConnectionRemoved,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for VpnConnectionStateReason {
    #[inline]
    #[doc(alias = "nm_vpn_connection_state_reason_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_vpn_connection_state_reason_get_type()) }
    }
}

impl glib::HasParamSpec for VpnConnectionStateReason {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for VpnConnectionStateReason {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for VpnConnectionStateReason {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for VpnConnectionStateReason {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<VpnConnectionStateReason> for glib::Value {
    #[inline]
    fn from(v: VpnConnectionStateReason) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// Returned by the VPN service plugin to indicate errors. These codes correspond
/// to errors in the "org.freedesktop.NetworkManager.VPN.Error" namespace.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMVpnPluginError")]
pub enum VpnPluginError {
    /// unknown or unclassified error
    #[doc(alias = "NM_VPN_PLUGIN_ERROR_FAILED")]
    Failed,
    /// the plugin is already starting,
    ///   and another connect request was received
    #[doc(alias = "NM_VPN_PLUGIN_ERROR_STARTING_IN_PROGRESS")]
    StartingInProgress,
    /// the plugin is already connected, and
    ///   another connect request was received
    #[doc(alias = "NM_VPN_PLUGIN_ERROR_ALREADY_STARTED")]
    AlreadyStarted,
    /// the plugin is already stopping,
    ///   and another stop request was received
    #[doc(alias = "NM_VPN_PLUGIN_ERROR_STOPPING_IN_PROGRESS")]
    StoppingInProgress,
    /// the plugin is already stopped, and
    ///   another disconnect request was received
    #[doc(alias = "NM_VPN_PLUGIN_ERROR_ALREADY_STOPPED")]
    AlreadyStopped,
    /// the operation could not be performed in
    ///   this state
    #[doc(alias = "NM_VPN_PLUGIN_ERROR_WRONG_STATE")]
    WrongState,
    /// the operation could not be performed as
    ///   the request contained malformed arguments, or arguments of unexpected type.
    ///   Usually means that one of the VPN setting data items or secrets was not of
    ///   the expected type (ie int, string, bool, etc).
    #[doc(alias = "NM_VPN_PLUGIN_ERROR_BAD_ARGUMENTS")]
    BadArguments,
    /// a child process failed to launch
    #[doc(alias = "NM_VPN_PLUGIN_ERROR_LAUNCH_FAILED")]
    LaunchFailed,
    /// the operation could not be performed
    ///   because the connection was invalid.  Usually means that the connection's
    ///   VPN setting was missing some required data item or secret.
    #[doc(alias = "NM_VPN_PLUGIN_ERROR_INVALID_CONNECTION")]
    InvalidConnection,
    /// the operation could not be
    ///   performed as the plugin does not support interactive operations, such as
    ///   ConnectInteractive() or NewSecrets()
    #[doc(alias = "NM_VPN_PLUGIN_ERROR_INTERACTIVE_NOT_SUPPORTED")]
    InteractiveNotSupported,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for VpnPluginError {
    type GlibType = ffi::NMVpnPluginError;

    #[inline]
    fn into_glib(self) -> ffi::NMVpnPluginError {
        match self {
            Self::Failed => ffi::NM_VPN_PLUGIN_ERROR_FAILED,
            Self::StartingInProgress => ffi::NM_VPN_PLUGIN_ERROR_STARTING_IN_PROGRESS,
            Self::AlreadyStarted => ffi::NM_VPN_PLUGIN_ERROR_ALREADY_STARTED,
            Self::StoppingInProgress => ffi::NM_VPN_PLUGIN_ERROR_STOPPING_IN_PROGRESS,
            Self::AlreadyStopped => ffi::NM_VPN_PLUGIN_ERROR_ALREADY_STOPPED,
            Self::WrongState => ffi::NM_VPN_PLUGIN_ERROR_WRONG_STATE,
            Self::BadArguments => ffi::NM_VPN_PLUGIN_ERROR_BAD_ARGUMENTS,
            Self::LaunchFailed => ffi::NM_VPN_PLUGIN_ERROR_LAUNCH_FAILED,
            Self::InvalidConnection => ffi::NM_VPN_PLUGIN_ERROR_INVALID_CONNECTION,
            Self::InteractiveNotSupported => ffi::NM_VPN_PLUGIN_ERROR_INTERACTIVE_NOT_SUPPORTED,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMVpnPluginError> for VpnPluginError {
    #[inline]
    unsafe fn from_glib(value: ffi::NMVpnPluginError) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_VPN_PLUGIN_ERROR_FAILED => Self::Failed,
            ffi::NM_VPN_PLUGIN_ERROR_STARTING_IN_PROGRESS => Self::StartingInProgress,
            ffi::NM_VPN_PLUGIN_ERROR_ALREADY_STARTED => Self::AlreadyStarted,
            ffi::NM_VPN_PLUGIN_ERROR_STOPPING_IN_PROGRESS => Self::StoppingInProgress,
            ffi::NM_VPN_PLUGIN_ERROR_ALREADY_STOPPED => Self::AlreadyStopped,
            ffi::NM_VPN_PLUGIN_ERROR_WRONG_STATE => Self::WrongState,
            ffi::NM_VPN_PLUGIN_ERROR_BAD_ARGUMENTS => Self::BadArguments,
            ffi::NM_VPN_PLUGIN_ERROR_LAUNCH_FAILED => Self::LaunchFailed,
            ffi::NM_VPN_PLUGIN_ERROR_INVALID_CONNECTION => Self::InvalidConnection,
            ffi::NM_VPN_PLUGIN_ERROR_INTERACTIVE_NOT_SUPPORTED => Self::InteractiveNotSupported,
            value => Self::__Unknown(value),
        }
    }
}

impl glib::error::ErrorDomain for VpnPluginError {
    #[inline]
    fn domain() -> glib::Quark {
        skip_assert_initialized!();

        unsafe { from_glib(ffi::nm_vpn_plugin_error_quark()) }
    }

    #[inline]
    fn code(self) -> i32 {
        self.into_glib()
    }

    #[inline]
    #[allow(clippy::match_single_binding)]
    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match unsafe { from_glib(code) } {
            Self::__Unknown(_) => Some(Self::Failed),
            value => Some(value),
        }
    }
}

impl StaticType for VpnPluginError {
    #[inline]
    #[doc(alias = "nm_vpn_plugin_error_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_vpn_plugin_error_get_type()) }
    }
}

impl glib::HasParamSpec for VpnPluginError {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for VpnPluginError {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for VpnPluginError {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for VpnPluginError {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<VpnPluginError> for glib::Value {
    #[inline]
    fn from(v: VpnPluginError) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// VPN plugin failure reasons
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMVpnPluginFailure")]
pub enum VpnPluginFailure {
    /// Login failed.
    #[doc(alias = "NM_VPN_PLUGIN_FAILURE_LOGIN_FAILED")]
    LoginFailed,
    /// Connect failed.
    #[doc(alias = "NM_VPN_PLUGIN_FAILURE_CONNECT_FAILED")]
    ConnectFailed,
    /// Invalid IP configuration returned from
    ///   the VPN plugin.
    #[doc(alias = "NM_VPN_PLUGIN_FAILURE_BAD_IP_CONFIG")]
    BadIpConfig,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for VpnPluginFailure {
    type GlibType = ffi::NMVpnPluginFailure;

    #[inline]
    fn into_glib(self) -> ffi::NMVpnPluginFailure {
        match self {
            Self::LoginFailed => ffi::NM_VPN_PLUGIN_FAILURE_LOGIN_FAILED,
            Self::ConnectFailed => ffi::NM_VPN_PLUGIN_FAILURE_CONNECT_FAILED,
            Self::BadIpConfig => ffi::NM_VPN_PLUGIN_FAILURE_BAD_IP_CONFIG,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMVpnPluginFailure> for VpnPluginFailure {
    #[inline]
    unsafe fn from_glib(value: ffi::NMVpnPluginFailure) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_VPN_PLUGIN_FAILURE_LOGIN_FAILED => Self::LoginFailed,
            ffi::NM_VPN_PLUGIN_FAILURE_CONNECT_FAILED => Self::ConnectFailed,
            ffi::NM_VPN_PLUGIN_FAILURE_BAD_IP_CONFIG => Self::BadIpConfig,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for VpnPluginFailure {
    #[inline]
    #[doc(alias = "nm_vpn_plugin_failure_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_vpn_plugin_failure_get_type()) }
    }
}

impl glib::HasParamSpec for VpnPluginFailure {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for VpnPluginFailure {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for VpnPluginFailure {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for VpnPluginFailure {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<VpnPluginFailure> for glib::Value {
    #[inline]
    fn from(v: VpnPluginFailure) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// VPN daemon states
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMVpnServiceState")]
pub enum VpnServiceState {
    /// The state of the VPN plugin is unknown.
    #[doc(alias = "NM_VPN_SERVICE_STATE_UNKNOWN")]
    Unknown,
    /// The VPN plugin is initialized.
    #[doc(alias = "NM_VPN_SERVICE_STATE_INIT")]
    Init,
    /// Not used.
    #[doc(alias = "NM_VPN_SERVICE_STATE_SHUTDOWN")]
    Shutdown,
    /// The plugin is attempting to connect to a VPN server.
    #[doc(alias = "NM_VPN_SERVICE_STATE_STARTING")]
    Starting,
    /// The plugin has connected to a VPN server.
    #[doc(alias = "NM_VPN_SERVICE_STATE_STARTED")]
    Started,
    /// The plugin is disconnecting from the VPN server.
    #[doc(alias = "NM_VPN_SERVICE_STATE_STOPPING")]
    Stopping,
    /// The plugin has disconnected from the VPN server.
    #[doc(alias = "NM_VPN_SERVICE_STATE_STOPPED")]
    Stopped,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for VpnServiceState {
    type GlibType = ffi::NMVpnServiceState;

    #[inline]
    fn into_glib(self) -> ffi::NMVpnServiceState {
        match self {
            Self::Unknown => ffi::NM_VPN_SERVICE_STATE_UNKNOWN,
            Self::Init => ffi::NM_VPN_SERVICE_STATE_INIT,
            Self::Shutdown => ffi::NM_VPN_SERVICE_STATE_SHUTDOWN,
            Self::Starting => ffi::NM_VPN_SERVICE_STATE_STARTING,
            Self::Started => ffi::NM_VPN_SERVICE_STATE_STARTED,
            Self::Stopping => ffi::NM_VPN_SERVICE_STATE_STOPPING,
            Self::Stopped => ffi::NM_VPN_SERVICE_STATE_STOPPED,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMVpnServiceState> for VpnServiceState {
    #[inline]
    unsafe fn from_glib(value: ffi::NMVpnServiceState) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_VPN_SERVICE_STATE_UNKNOWN => Self::Unknown,
            ffi::NM_VPN_SERVICE_STATE_INIT => Self::Init,
            ffi::NM_VPN_SERVICE_STATE_SHUTDOWN => Self::Shutdown,
            ffi::NM_VPN_SERVICE_STATE_STARTING => Self::Starting,
            ffi::NM_VPN_SERVICE_STATE_STARTED => Self::Started,
            ffi::NM_VPN_SERVICE_STATE_STOPPING => Self::Stopping,
            ffi::NM_VPN_SERVICE_STATE_STOPPED => Self::Stopped,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for VpnServiceState {
    #[inline]
    #[doc(alias = "nm_vpn_service_state_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_vpn_service_state_get_type()) }
    }
}

impl glib::HasParamSpec for VpnServiceState {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for VpnServiceState {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for VpnServiceState {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for VpnServiceState {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<VpnServiceState> for glib::Value {
    #[inline]
    fn from(v: VpnServiceState) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// The #NMWepKeyType values specify how any WEP keys present in the setting
/// are interpreted.  There are no standards governing how to hash the various WEP
/// key/passphrase formats into the actual WEP key.  Unfortunately some WEP keys
/// can be interpreted in multiple ways, requiring the setting to specify how to
/// interpret the any WEP keys.  For example, the key "732f2d712e4a394a375d366931"
/// is both a valid Hexadecimal WEP key and a WEP passphrase.  Further, many
/// ASCII keys are also valid WEP passphrases, but since passphrases and ASCII
/// keys are hashed differently to determine the actual WEP key the type must be
/// specified.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMWepKeyType")]
pub enum WepKeyType {
    /// unknown WEP key type
    #[doc(alias = "NM_WEP_KEY_TYPE_UNKNOWN")]
    Unknown,
    /// indicates a hexadecimal or ASCII formatted WEP key.
    /// Hex keys are either 10 or 26 hexadecimal characters (ie "5f782f2f5f" or
    /// "732f2d712e4a394a375d366931"), while ASCII keys are either 5 or 13 ASCII
    /// characters (ie "abcde" or "blahblah99$*1").
    #[doc(alias = "NM_WEP_KEY_TYPE_KEY")]
    Key,
    /// indicates a WEP passphrase (ex "I bought a duck
    /// on my way back from the market 235Q&^%^*%") instead of a hexadecimal or ASCII
    /// key.  Passphrases are between 8 and 64 characters inclusive and are hashed
    /// the actual WEP key using the MD5 hash algorithm.
    #[doc(alias = "NM_WEP_KEY_TYPE_PASSPHRASE")]
    Passphrase,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for WepKeyType {
    type GlibType = ffi::NMWepKeyType;

    #[inline]
    fn into_glib(self) -> ffi::NMWepKeyType {
        match self {
            Self::Unknown => ffi::NM_WEP_KEY_TYPE_UNKNOWN,
            Self::Key => ffi::NM_WEP_KEY_TYPE_KEY,
            Self::Passphrase => ffi::NM_WEP_KEY_TYPE_PASSPHRASE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMWepKeyType> for WepKeyType {
    #[inline]
    unsafe fn from_glib(value: ffi::NMWepKeyType) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_WEP_KEY_TYPE_UNKNOWN => Self::Unknown,
            ffi::NM_WEP_KEY_TYPE_KEY => Self::Key,
            ffi::NM_WEP_KEY_TYPE_PASSPHRASE => Self::Passphrase,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for WepKeyType {
    #[inline]
    #[doc(alias = "nm_wep_key_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_wep_key_type_get_type()) }
    }
}

impl glib::HasParamSpec for WepKeyType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for WepKeyType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for WepKeyType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for WepKeyType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<WepKeyType> for glib::Value {
    #[inline]
    fn from(v: WepKeyType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// WiMAX network type.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NMWimaxNspNetworkType")]
pub enum WimaxNspNetworkType {
    /// unknown network type
    #[doc(alias = "NM_WIMAX_NSP_NETWORK_TYPE_UNKNOWN")]
    Unknown,
    /// home network
    #[doc(alias = "NM_WIMAX_NSP_NETWORK_TYPE_HOME")]
    Home,
    /// partner network
    #[doc(alias = "NM_WIMAX_NSP_NETWORK_TYPE_PARTNER")]
    Partner,
    /// roaming partner network
    #[doc(alias = "NM_WIMAX_NSP_NETWORK_TYPE_ROAMING_PARTNER")]
    RoamingPartner,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for WimaxNspNetworkType {
    type GlibType = ffi::NMWimaxNspNetworkType;

    #[inline]
    fn into_glib(self) -> ffi::NMWimaxNspNetworkType {
        match self {
            Self::Unknown => ffi::NM_WIMAX_NSP_NETWORK_TYPE_UNKNOWN,
            Self::Home => ffi::NM_WIMAX_NSP_NETWORK_TYPE_HOME,
            Self::Partner => ffi::NM_WIMAX_NSP_NETWORK_TYPE_PARTNER,
            Self::RoamingPartner => ffi::NM_WIMAX_NSP_NETWORK_TYPE_ROAMING_PARTNER,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NMWimaxNspNetworkType> for WimaxNspNetworkType {
    #[inline]
    unsafe fn from_glib(value: ffi::NMWimaxNspNetworkType) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::NM_WIMAX_NSP_NETWORK_TYPE_UNKNOWN => Self::Unknown,
            ffi::NM_WIMAX_NSP_NETWORK_TYPE_HOME => Self::Home,
            ffi::NM_WIMAX_NSP_NETWORK_TYPE_PARTNER => Self::Partner,
            ffi::NM_WIMAX_NSP_NETWORK_TYPE_ROAMING_PARTNER => Self::RoamingPartner,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for WimaxNspNetworkType {
    #[inline]
    #[doc(alias = "nm_wimax_nsp_network_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::nm_wimax_nsp_network_type_get_type()) }
    }
}

impl glib::HasParamSpec for WimaxNspNetworkType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for WimaxNspNetworkType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for WimaxNspNetworkType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for WimaxNspNetworkType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<WimaxNspNetworkType> for glib::Value {
    #[inline]
    fn from(v: WimaxNspNetworkType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}
