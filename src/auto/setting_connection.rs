// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir
// from gtk-girs (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT
#![allow(deprecated)]

#[cfg(feature = "v1_42")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
use crate::MptcpFlags;
#[cfg(feature = "v1_34")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_34")))]
use crate::SettingConnectionDnsOverTls;
#[cfg(feature = "v1_48")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_48")))]
use crate::SettingConnectionDownOnPoweroff;
#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
use crate::SettingConnectionMdns;
#[cfg(feature = "v1_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
use crate::Ternary;
#[cfg(feature = "v1_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
use crate::{ConnectionMultiConnect, SettingConnectionLlmnr};
#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
use crate::{Metered, SettingConnectionAutoconnectSlaves, SettingConnectionLldp};
use crate::{Setting, ffi};
use glib::{
    prelude::*,
    signal::{SignalHandlerId, connect_raw},
    translate::*,
};
use std::boxed::Box as Box_;

glib::wrapper! {
    /// General Connection Profile Settings
    ///
    /// ## Properties
    ///
    ///
    /// #### `auth-retries`
    ///  The number of retries for the authentication. Zero means to try indefinitely; -1 means
    /// to use a global default. If the global default is not set, the authentication
    /// retries for 3 times before failing the connection.
    ///
    /// Currently, this only applies to 802-1x authentication.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `autoconnect`
    ///  Whether or not the connection should be automatically connected by
    /// NetworkManager when the resources for the connection are available.
    /// [`true`] to automatically activate the connection, [`false`] to require manual
    /// intervention to activate the connection.
    ///
    /// Autoconnect happens when the circumstances are suitable. That means for
    /// example that the device is currently managed and not active. Autoconnect
    /// thus never replaces or competes with an already active profile.
    ///
    /// Note that autoconnect is not implemented for VPN profiles. See
    /// #NMSettingConnection:secondaries as an alternative to automatically
    /// connect VPN profiles.
    ///
    /// If multiple profiles are ready to autoconnect on the same device,
    /// the one with the better "connection.autoconnect-priority" is chosen. If
    /// the priorities are equal, then the most recently connected profile is activated.
    /// If the profiles were not connected earlier or their
    /// "connection.timestamp" is identical, the choice is undefined.
    ///
    /// Depending on "connection.multi-connect", a profile can (auto)connect only
    /// once at a time or multiple times.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `autoconnect-ports`
    ///  Whether or not ports of this connection should be automatically brought up
    /// when NetworkManager activates this connection. This only has a real effect
    /// for controller connections. The properties #NMSettingConnection:autoconnect,
    /// #NMSettingConnection:autoconnect-priority and #NMSettingConnection:autoconnect-retries
    /// are unrelated to this setting.
    /// The permitted values are: 0: leave port connections untouched,
    /// 1: activate all the port connections with this connection, -1: default.
    /// If -1 (default) is set, global connection.autoconnect-ports is read to
    /// determine the real value. If it is default as well, this fallbacks to 0.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `autoconnect-priority`
    ///  The autoconnect priority in range -999 to 999. If the connection is set
    /// to autoconnect, connections with higher priority will be preferred.
    /// The higher number means higher priority. Defaults to 0.
    /// Note that this property only matters if there are more than one candidate
    /// profile to select for autoconnect. In case of equal priority, the profile
    /// used most recently is chosen.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `autoconnect-retries`
    ///  The number of times a connection should be tried when autoactivating before
    /// giving up. Zero means forever, -1 means the global default (4 times if not
    /// overridden). Setting this to 1 means to try activation only once before
    /// blocking autoconnect. Note that after a timeout, NetworkManager will try
    /// to autoconnect again.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `autoconnect-slaves`
    ///  Whether or not ports of this connection should be automatically brought up
    /// when NetworkManager activates this connection. This only has a real effect
    /// for controller connections. The properties #NMSettingConnection:autoconnect,
    /// #NMSettingConnection:autoconnect-priority and #NMSettingConnection:autoconnect-retries
    /// are unrelated to this setting.
    /// The permitted values are: 0: leave port connections untouched,
    /// 1: activate all the port connections with this connection, -1: default.
    /// If -1 (default) is set, global connection.autoconnect-slaves is read to
    /// determine the real value. If it is default as well, this fallbacks to 0.
    ///
    /// Deprecated 1.46. Use #NMSettingConnection:autoconnect-ports instead, this is just an alias.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `controller`
    ///  Interface name of the controller device or UUID of the controller connection.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `dns-over-tls`
    ///  Whether DNSOverTls (dns-over-tls) is enabled for the connection.
    /// DNSOverTls is a technology which uses TLS to encrypt dns traffic.
    ///
    /// The permitted values are: "yes" (2) use DNSOverTls and disabled fallback,
    /// "opportunistic" (1) use DNSOverTls but allow fallback to unencrypted resolution,
    /// "no" (0) don't ever use DNSOverTls.
    /// If unspecified "default" depends on the plugin used. Systemd-resolved
    /// uses global setting.
    ///
    /// This feature requires a plugin which supports DNSOverTls. Otherwise, the
    /// setting has no effect. One such plugin is dns-systemd-resolved.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `down-on-poweroff`
    ///  Whether the connection will be brought down before the system is powered
    /// off.  The default value is [`SettingConnectionDownOnPoweroff::Default`][crate::SettingConnectionDownOnPoweroff::Default]. When
    /// the default value is specified, then the global value from
    /// NetworkManager configuration is looked up, if not set, it is considered
    /// as [`SettingConnectionDownOnPoweroff::No`][crate::SettingConnectionDownOnPoweroff::No].
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `gateway-ping-timeout`
    ///  If greater than zero, delay success of IP addressing until either the
    /// timeout is reached, or an IP gateway replies to a ping.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `id`
    ///  A human readable unique identifier for the connection, like "Work Wi-Fi"
    /// or "T-Mobile 3G".
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `interface-name`
    ///  The name of the network interface this connection is bound to. If not
    /// set, then the connection can be attached to any interface of the
    /// appropriate type (subject to restrictions imposed by other settings).
    ///
    /// For software devices this specifies the name of the created device.
    ///
    /// For connection types where interface names cannot easily be made
    /// persistent (e.g. mobile broadband or USB Ethernet), this property should
    /// not be used. Setting this property restricts the interfaces a connection
    /// can be used with, and if interface names change or are reordered the
    /// connection may be applied to the wrong interface.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `ip-ping-addresses`
    ///  The property specifies a list of target IP addresses for pinging.
    /// When multiple targets are set, NetworkManager will start multiple ping processes
    /// in parallel. This property can only be set if connection.ip-ping-timeout is
    /// set. The ip-ping-timeout is used to delay the success of IP addressing until
    /// either the specified timeout (in seconds) is reached, or an target IP address replies
    /// to a ping. Configuring #NMSettingConnection:ip-ping-addresses may delay reaching the
    /// systemd's network-online.target due to waiting for the ping operations to complete or timeout.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `ip-ping-addresses-require-all`
    ///  The property determines whether it is sufficient for any ping check
    /// to succeed among #NMSettingConnection:ip-ping-addresses, or if all
    /// ping checks must succeed for #NMSettingConnection:ip-ping-addresses.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `ip-ping-timeout`
    ///  If greater than zero, delay success of IP addressing until either the specified
    /// timeout (in seconds) is reached, or a target IP address replies to a ping. The
    /// property specifies the timeout for the #NMSettingConnection:ip-ping-addresses.
    /// This property is incompatible with #NMSettingConnection:gateway-ping-timeout,
    /// you cannot set these two properties at the same time.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `lldp`
    ///  Whether LLDP is enabled for the connection.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `llmnr`
    ///  Whether Link-Local Multicast Name Resolution (LLMNR) is enabled
    /// for the connection. LLMNR is a protocol based on the Domain Name
    /// System (DNS) packet format that allows both IPv4 and IPv6 hosts
    /// to perform name resolution for hosts on the same local link.
    ///
    /// The permitted values are: "yes" (2) register hostname and resolving
    /// for the connection, "no" (0) disable LLMNR for the interface, "resolve"
    /// (1) do not register hostname but allow resolving of LLMNR host names
    /// If unspecified, "default" ultimately depends on the DNS plugin (which
    /// for systemd-resolved currently means "yes").
    ///
    /// This feature requires a plugin which supports LLMNR. Otherwise, the
    /// setting has no effect. One such plugin is dns-systemd-resolved.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `master`
    ///  Interface name of the controller device or UUID of the controller connection.
    ///
    /// Deprecated 1.46. Use #NMSettingConnection:controller instead, this is just an alias.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `mdns`
    ///  Whether mDNS is enabled for the connection.
    ///
    /// The permitted values are: "yes" (2) register hostname and resolving
    /// for the connection, "no" (0) disable mDNS for the interface, "resolve"
    /// (1) do not register hostname but allow resolving of mDNS host names
    /// and "default" (-1) to allow lookup of a global default in NetworkManager.conf.
    /// If unspecified, "default" ultimately depends on the DNS plugin.
    ///
    /// This feature requires a plugin which supports mDNS. Otherwise, the
    /// setting has no effect. Currently the only supported DNS plugin is
    /// systemd-resolved. For systemd-resolved, the default is configurable via
    /// MulticastDNS= setting in resolved.conf.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `metered`
    ///  Whether the connection is metered.
    ///
    /// When updating this property on a currently activated connection,
    /// the change takes effect immediately.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `mptcp-flags`
    ///  Whether to configure MPTCP endpoints and the address flags.
    /// If MPTCP is enabled in NetworkManager, it will configure the
    /// addresses of the interface as MPTCP endpoints. Note that
    /// IPv4 loopback addresses (127.0.0.0/8), IPv4 link local
    /// addresses (169.254.0.0/16), the IPv6 loopback address (::1),
    /// IPv6 link local addresses (fe80::/10), IPv6 unique
    /// local addresses (ULA, fc00::/7) and IPv6 privacy extension addresses
    /// (rfc3041, ipv6.ip6-privacy) will be excluded from being
    /// configured as endpoints.
    ///
    /// If "disabled" (0x1), MPTCP handling for the interface is disabled and
    /// no endpoints are registered.
    ///
    /// The "enabled" (0x2) flag means that MPTCP handling is enabled.
    /// This flag can also be implied from the presence of other flags.
    ///
    /// Even when enabled, MPTCP handling will by default still be disabled
    /// unless "/proc/sys/net/mptcp/enabled" sysctl is on. NetworkManager
    /// does not change the sysctl and this is up to the administrator
    /// or distribution. To configure endpoints even if the sysctl is
    /// disabled, "also-without-sysctl" (0x4) flag can be used. In that case,
    /// NetworkManager doesn't look at the sysctl and configures endpoints
    /// regardless.
    ///
    /// Even when enabled, NetworkManager will only configure MPTCP endpoints
    /// for a certain address family, if there is a unicast default route (0.0.0.0/0
    /// or ::/0) in the main routing table. The flag "also-without-default-route"
    /// (0x8) can override that.
    ///
    /// When MPTCP handling is enabled then endpoints are configured with
    /// the specified address flags "signal" (0x10), "subflow" (0x20), "backup" (0x40),
    /// "fullmesh" (0x80). See ip-mptcp(8) manual for additional information about the flags.
    ///
    /// If the flags are zero (0x0), the global connection default from NetworkManager.conf is
    /// honored. If still unspecified, the fallback is "enabled,subflow".
    /// Note that this means that MPTCP is by default done depending on the
    /// "/proc/sys/net/mptcp/enabled" sysctl.
    ///
    /// NetworkManager does not change the MPTCP limits nor enable MPTCP via
    /// "/proc/sys/net/mptcp/enabled". That is a host configuration which the
    /// admin can change via sysctl and ip-mptcp.
    ///
    /// Strict reverse path filtering (rp_filter) breaks many MPTCP use cases, so when
    /// MPTCP handling for IPv4 addresses on the interface is enabled, NetworkManager would
    /// loosen the strict reverse path filtering (1) to the loose setting (2).
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `mud-url`
    ///  If configured, set to a Manufacturer Usage Description (MUD) URL that points
    /// to manufacturer-recommended network policies for IoT devices. It is transmitted
    /// as a DHCPv4 or DHCPv6 option. The value must be a valid URL starting with "https://".
    ///
    /// The special value "none" is allowed to indicate that no MUD URL is used.
    ///
    /// If the per-profile value is unspecified (the default), a global connection default gets
    /// consulted. If still unspecified, the ultimate default is "none".
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `multi-connect`
    ///  Specifies whether the profile can be active multiple times at a particular
    /// moment. The value is of type #NMConnectionMultiConnect.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `permissions`
    ///  An array of strings defining what access a given user has to this
    /// connection.  If this is [`None`] or empty, all users are allowed to access
    /// this connection; otherwise users are allowed if and only if they are in
    /// this list.  When this is not empty, the connection can be active only when
    /// one of the specified users is logged into an active session.  Each entry
    /// is of the form "[type]:[id]:[reserved]"; for example, "user:dcbw:blah".
    ///
    /// At this time only the "user" [type] is allowed.  Any other values are
    /// ignored and reserved for future use.  [id] is the username that this
    /// permission refers to, which may not contain the ":" character. Any
    /// [reserved] information present must be ignored and is reserved for future
    /// use.  All of [type], [id], and [reserved] must be valid UTF-8.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `port-type`
    ///  Setting name of the device type of this port's controller connection (eg,
    /// [`SETTING_BOND_SETTING_NAME`][crate::SETTING_BOND_SETTING_NAME]), or [`None`] if this connection is not a
    /// port.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `read-only`
    ///  This property is deprecated and has no meaning.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `secondaries`
    ///  List of connection UUIDs that should be activated when the base
    /// connection itself is activated. Currently, only VPN connections are
    /// supported.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `slave-type`
    ///  Setting name of the device type of this port's controller connection (eg,
    /// [`SETTING_BOND_SETTING_NAME`][crate::SETTING_BOND_SETTING_NAME]), or [`None`] if this connection is not a
    /// port.
    ///
    /// Deprecated 1.46. Use #NMSettingConnection:port-type instead, this is just an alias.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `stable-id`
    ///  This represents the identity of the connection used for various purposes.
    /// It allows configuring multiple profiles to share the identity. Also,
    /// the stable-id can contain placeholders that are substituted dynamically and
    /// deterministically depending on the context.
    ///
    /// The stable-id is used for generating IPv6 stable private addresses with
    /// ipv6.addr-gen-mode=stable-privacy. It is also used to seed the generated
    /// cloned MAC address for ethernet.cloned-mac-address=stable and
    /// wifi.cloned-mac-address=stable. It is also used to derive the DHCP
    /// client identifier with ipv4.dhcp-client-id=stable, the DHCPv6 DUID with
    /// ipv6.dhcp-duid=stable-[llt,ll,uuid] and the DHCP IAID with
    /// ipv4.iaid=stable and ipv6.iaid=stable.
    ///
    /// Note that depending on the context where it is used, other parameters are
    /// also seeded into the generation algorithm. For example, a per-host key
    /// is commonly also included, so that different systems end up generating
    /// different IDs. Or with ipv6.addr-gen-mode=stable-privacy, also the device's
    /// name is included, so that different interfaces yield different addresses.
    /// The per-host key is the identity of your machine and stored in /var/lib/NetworkManager/secret_key.
    /// See NetworkManager(8) manual about the secret-key and the host identity.
    ///
    /// The '$' character is treated special to perform dynamic substitutions at
    /// activation time. Currently, supported are "${CONNECTION}", "${DEVICE}",
    /// "${MAC}", "${NETWORK_SSID}", "${BOOT}", "${RANDOM}".  These effectively
    /// create unique IDs per-connection, per-device, per-SSID, per-boot, or
    /// every time.  The "${CONNECTION}" uses the profile's connection.uuid, the
    /// "${DEVICE}" uses the interface name of the device and "${MAC}" the
    /// permanent MAC address of the device. "${NETWORK_SSID}" uses the SSID for
    /// Wi-Fi networks and falls back to "${CONNECTION}" on other networks. Any
    /// unrecognized patterns following '$' are treated verbatim, however are
    /// reserved for future use. You are thus advised to avoid '$' or escape it
    /// as "$$".  For example, set it to "${CONNECTION}-${BOOT}-${DEVICE}" to
    /// create a unique id for this connection that changes with every reboot
    /// and differs depending on the interface where the profile activates.
    ///
    /// If the value is unset, a global connection default is consulted. If the
    /// value is still unset, the default is "default${CONNECTION}" go generate
    /// an ID unique per connection profile.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `timestamp`
    ///  The time, in seconds since the Unix Epoch, that the connection was last
    /// _successfully_ fully activated.
    ///
    /// NetworkManager updates the connection timestamp periodically when the
    /// connection is active to ensure that an active connection has the latest
    /// timestamp. The property is only meant for reading (changes to this
    /// property will not be preserved).
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `type`
    ///  Base type of the connection. For hardware-dependent connections, should
    /// contain the setting name of the hardware-type specific setting (ie,
    /// "802-3-ethernet" or "802-11-wireless" or "bluetooth", etc), and for
    /// non-hardware dependent connections like VPN or otherwise, should contain
    /// the setting name of that setting type (ie, "vpn" or "bridge", etc).
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `uuid`
    ///  A universally unique identifier for the connection, for example generated
    /// with libuuid.  It should be assigned when the connection is created, and
    /// never changed as long as the connection still applies to the same
    /// network.  For example, it should not be changed when the
    /// #NMSettingConnection:id property or #NMSettingIP4Config changes, but
    /// might need to be re-created when the Wi-Fi SSID, mobile broadband network
    /// provider, or #NMSettingConnection:type property changes.
    ///
    /// The UUID must be in the format "2815492f-7e56-435e-b2e9-246bd7cdc664"
    /// (ie, contains only hexadecimal characters and "-").  A suitable UUID may
    /// be generated by nm_utils_uuid_generate() or
    /// nm_uuid_generate_from_string_str().
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `wait-activation-delay`
    ///  Time in milliseconds to wait for connection to be considered activated.
    /// The wait will start after the pre-up dispatcher event.
    ///
    /// The value 0 means no wait time. The default value is -1, which
    /// currently has the same meaning as no wait time.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `wait-device-timeout`
    ///  Timeout in milliseconds to wait for device at startup.
    /// During boot, devices may take a while to be detected by the driver.
    /// This property will cause to delay NetworkManager-wait-online.service
    /// and nm-online to give the device a chance to appear. This works by
    /// waiting for the given timeout until a compatible device for the
    /// profile is available and managed.
    ///
    /// The value 0 means no wait time. The default value is -1, which
    /// currently has the same meaning as no wait time.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `zone`
    ///  The trust level of a the connection.  Free form case-insensitive string
    /// (for example "Home", "Work", "Public").  [`None`] or unspecified zone means
    /// the connection will be placed in the default zone as defined by the
    /// firewall.
    ///
    /// When updating this property on a currently activated connection,
    /// the change takes effect immediately.
    ///
    /// Readable | Writeable
    /// <details><summary><h4>Setting</h4></summary>
    ///
    ///
    /// #### `name`
    ///  The setting's name, which uniquely identifies the setting within the
    /// connection.  Each setting type has a name unique to that type, for
    /// example "ppp" or "802-11-wireless" or "802-3-ethernet".
    ///
    /// Readable
    /// </details>
    ///
    /// # Implements
    ///
    /// [`SettingExt`][trait@crate::prelude::SettingExt]
    #[doc(alias = "NMSettingConnection")]
    pub struct SettingConnection(Object<ffi::NMSettingConnection, ffi::NMSettingConnectionClass>) @extends Setting;

    match fn {
        type_ => || ffi::nm_setting_connection_get_type(),
    }
}

impl SettingConnection {
    /// Creates a new #NMSettingConnection object with default values.
    ///
    /// # Returns
    ///
    /// the new empty #NMSettingConnection object
    #[doc(alias = "nm_setting_connection_new")]
    pub fn new() -> SettingConnection {
        assert_initialized_main_thread!();
        unsafe { Setting::from_glib_full(ffi::nm_setting_connection_new()).unsafe_cast() }
    }

    // rustdoc-stripper-ignore-next
    /// Creates a new builder-pattern struct instance to construct [`SettingConnection`] objects.
    ///
    /// This method returns an instance of [`SettingConnectionBuilder`](crate::builders::SettingConnectionBuilder) which can be used to create [`SettingConnection`] objects.
    pub fn builder() -> SettingConnectionBuilder {
        SettingConnectionBuilder::new()
    }

    /// Adds a new IP address string to the ip-ping-addresses.
    /// ## `address`
    /// the IP address string to add
    ///
    /// # Returns
    ///
    /// [`true`] if the new IP address was added; [`false`] if the IP address
    /// was already present
    #[cfg(feature = "v1_52")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
    #[doc(alias = "nm_setting_connection_add_ip_ping_address")]
    pub fn add_ip_ping_address(&self, address: &str) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_connection_add_ip_ping_address(
                self.to_glib_none().0,
                address.to_glib_none().0,
            ))
        }
    }

    /// Adds a permission to the connection's permission list.  At this time, only
    /// the "user" permission type is supported, and @pitem must be a username. See
    /// #NMSettingConnection:permissions: for more details.
    /// ## `ptype`
    /// the permission type; at this time only "user" is supported
    /// ## `pitem`
    /// the permission item formatted as required for @ptype
    /// ## `detail`
    /// unused at this time; must be [`None`]
    ///
    /// # Returns
    ///
    /// [`true`] if the permission was unique and was successfully added to the
    /// list, [`false`] if @ptype or @pitem was invalid.
    /// If the permission was already present in the list, it will not be added
    /// a second time but [`true`] will be returned. Note that before 1.28, in this
    /// case [`false`] would be returned.
    #[doc(alias = "nm_setting_connection_add_permission")]
    pub fn add_permission(&self, ptype: &str, pitem: &str, detail: Option<&str>) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_connection_add_permission(
                self.to_glib_none().0,
                ptype.to_glib_none().0,
                pitem.to_glib_none().0,
                detail.to_glib_none().0,
            ))
        }
    }

    /// Adds a new secondary connection UUID to the setting.
    /// ## `sec_uuid`
    /// the secondary connection UUID to add
    ///
    /// # Returns
    ///
    /// [`true`] if the secondary connection UUID was added; [`false`] if the UUID
    /// was already present
    #[doc(alias = "nm_setting_connection_add_secondary")]
    pub fn add_secondary(&self, sec_uuid: &str) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_connection_add_secondary(
                self.to_glib_none().0,
                sec_uuid.to_glib_none().0,
            ))
        }
    }

    /// Removes all configured ip-ping-addresses.
    #[cfg(feature = "v1_52")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
    #[doc(alias = "nm_setting_connection_clear_ip_ping_addresses")]
    pub fn clear_ip_ping_addresses(&self) {
        unsafe {
            ffi::nm_setting_connection_clear_ip_ping_addresses(self.to_glib_none().0);
        }
    }

    /// Returns the value contained in the #NMSettingConnection:auth-retries property.
    ///
    /// # Returns
    ///
    /// the configured authentication retries. Zero means
    /// infinity and -1 means a global default value.
    #[cfg(feature = "v1_10")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
    #[doc(alias = "nm_setting_connection_get_auth_retries")]
    #[doc(alias = "get_auth_retries")]
    #[doc(alias = "auth-retries")]
    pub fn auth_retries(&self) -> i32 {
        unsafe { ffi::nm_setting_connection_get_auth_retries(self.to_glib_none().0) }
    }

    /// Returns the #NMSettingConnection:autoconnect property of the connection.
    ///
    /// # Returns
    ///
    /// the connection's autoconnect behavior
    #[doc(alias = "nm_setting_connection_get_autoconnect")]
    #[doc(alias = "get_autoconnect")]
    #[doc(alias = "autoconnect")]
    pub fn is_autoconnect(&self) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_connection_get_autoconnect(
                self.to_glib_none().0,
            ))
        }
    }

    /// Returns the #NMSettingConnection:autoconnect-ports property of the connection.
    ///
    /// # Returns
    ///
    /// whether ports of the connection should be activated together
    ///          with the connection.
    #[cfg(feature = "v1_46")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
    #[doc(alias = "nm_setting_connection_get_autoconnect_ports")]
    #[doc(alias = "get_autoconnect_ports")]
    #[doc(alias = "autoconnect-ports")]
    pub fn autoconnect_ports(&self) -> Ternary {
        unsafe {
            from_glib(ffi::nm_setting_connection_get_autoconnect_ports(
                self.to_glib_none().0,
            ))
        }
    }

    /// Returns the #NMSettingConnection:autoconnect-priority property of the connection.
    /// The higher number, the higher priority.
    ///
    /// # Returns
    ///
    /// the connection's autoconnect priority
    #[doc(alias = "nm_setting_connection_get_autoconnect_priority")]
    #[doc(alias = "get_autoconnect_priority")]
    #[doc(alias = "autoconnect-priority")]
    pub fn autoconnect_priority(&self) -> i32 {
        unsafe { ffi::nm_setting_connection_get_autoconnect_priority(self.to_glib_none().0) }
    }

    /// Returns the #NMSettingConnection:autoconnect-retries property of the connection.
    /// Zero means infinite, -1 means the global default value.
    ///
    /// # Returns
    ///
    /// the connection's autoconnect retries
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    #[doc(alias = "nm_setting_connection_get_autoconnect_retries")]
    #[doc(alias = "get_autoconnect_retries")]
    #[doc(alias = "autoconnect-retries")]
    pub fn autoconnect_retries(&self) -> i32 {
        unsafe { ffi::nm_setting_connection_get_autoconnect_retries(self.to_glib_none().0) }
    }

    /// Returns the #NMSettingConnection:autoconnect-slaves property of the connection.
    ///
    /// # Deprecated since 1.46
    ///
    /// Use nm_setting_connection_get_autoconnect_ports() instead, this
    /// is just an alias.
    ///
    /// # Returns
    ///
    /// whether ports of the connection should be activated together
    ///          with the connection.
    #[cfg_attr(feature = "v1_46", deprecated = "Since 1.46")]
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    #[allow(deprecated)]
    #[doc(alias = "nm_setting_connection_get_autoconnect_slaves")]
    #[doc(alias = "get_autoconnect_slaves")]
    #[doc(alias = "autoconnect-slaves")]
    pub fn autoconnect_slaves(&self) -> SettingConnectionAutoconnectSlaves {
        unsafe {
            from_glib(ffi::nm_setting_connection_get_autoconnect_slaves(
                self.to_glib_none().0,
            ))
        }
    }

    /// Returns the #NMSettingConnection:type property of the connection.
    ///
    /// # Returns
    ///
    /// the connection type
    #[doc(alias = "nm_setting_connection_get_connection_type")]
    #[doc(alias = "get_connection_type")]
    pub fn connection_type(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_setting_connection_get_connection_type(
                self.to_glib_none().0,
            ))
        }
    }

    /// Returns the #NMSettingConnection:controller property of the connection.
    ///
    /// # Returns
    ///
    /// interface name of the controller device or UUID of the controller
    /// connection.
    #[cfg(feature = "v1_46")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
    #[doc(alias = "nm_setting_connection_get_controller")]
    #[doc(alias = "get_controller")]
    pub fn controller(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_setting_connection_get_controller(
                self.to_glib_none().0,
            ))
        }
    }

    ///
    /// # Returns
    ///
    /// the #NMSettingConnection:dns-over-tls property of the setting.
    #[cfg(feature = "v1_34")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_34")))]
    #[doc(alias = "nm_setting_connection_get_dns_over_tls")]
    #[doc(alias = "get_dns_over_tls")]
    #[doc(alias = "dns-over-tls")]
    pub fn dns_over_tls(&self) -> SettingConnectionDnsOverTls {
        unsafe {
            from_glib(ffi::nm_setting_connection_get_dns_over_tls(
                self.to_glib_none().0,
            ))
        }
    }

    /// Returns the [`SETTING_CONNECTION_DOWN_ON_POWEROFF`][crate::SETTING_CONNECTION_DOWN_ON_POWEROFF] property.
    ///
    /// # Returns
    ///
    /// whether the connection will be brought down before the system
    /// is powered off.
    #[cfg(feature = "v1_48")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_48")))]
    #[doc(alias = "nm_setting_connection_get_down_on_poweroff")]
    #[doc(alias = "get_down_on_poweroff")]
    #[doc(alias = "down-on-poweroff")]
    pub fn down_on_poweroff(&self) -> SettingConnectionDownOnPoweroff {
        unsafe {
            from_glib(ffi::nm_setting_connection_get_down_on_poweroff(
                self.to_glib_none().0,
            ))
        }
    }

    ///
    /// # Returns
    ///
    /// the value contained in the #NMSettingConnection:gateway-ping-timeout
    /// property.
    #[doc(alias = "nm_setting_connection_get_gateway_ping_timeout")]
    #[doc(alias = "get_gateway_ping_timeout")]
    #[doc(alias = "gateway-ping-timeout")]
    pub fn gateway_ping_timeout(&self) -> u32 {
        unsafe { ffi::nm_setting_connection_get_gateway_ping_timeout(self.to_glib_none().0) }
    }

    /// Returns the #NMSettingConnection:id property of the connection.
    ///
    /// # Returns
    ///
    /// the connection ID
    #[doc(alias = "nm_setting_connection_get_id")]
    #[doc(alias = "get_id")]
    pub fn id(&self) -> glib::GString {
        unsafe { from_glib_none(ffi::nm_setting_connection_get_id(self.to_glib_none().0)) }
    }

    /// Returns the #NMSettingConnection:interface-name property of the connection.
    ///
    /// # Returns
    ///
    /// the connection's interface name
    #[doc(alias = "nm_setting_connection_get_interface_name")]
    #[doc(alias = "get_interface_name")]
    #[doc(alias = "interface-name")]
    pub fn interface_name(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_setting_connection_get_interface_name(
                self.to_glib_none().0,
            ))
        }
    }

    /// ## `idx`
    /// the zero-based index of the ip-ping-addresses entry.
    ///
    /// # Returns
    ///
    /// the ip address string at index @idx or
    ///   [`None`] if @idx is the number of ip-ping-addresses.
    #[cfg(feature = "v1_52")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
    #[doc(alias = "nm_setting_connection_get_ip_ping_address")]
    #[doc(alias = "get_ip_ping_address")]
    pub fn ip_ping_address(&self, idx: u32) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_setting_connection_get_ip_ping_address(
                self.to_glib_none().0,
                idx,
            ))
        }
    }

    /// Returns the #NMSettingConnection:ip-ping-addresses-require-all property of the connection.
    ///
    /// # Returns
    ///
    /// whether all the ip ping addresses pass the connectivity check.
    #[cfg(feature = "v1_52")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
    #[doc(alias = "nm_setting_connection_get_ip_ping_addresses_require_all")]
    #[doc(alias = "get_ip_ping_addresses_require_all")]
    #[doc(alias = "ip-ping-addresses-require-all")]
    pub fn ip_ping_addresses_require_all(&self) -> Ternary {
        unsafe {
            from_glib(
                ffi::nm_setting_connection_get_ip_ping_addresses_require_all(self.to_glib_none().0),
            )
        }
    }

    ///
    /// # Returns
    ///
    /// the value contained in the #NMSettingConnection:ip-ping-timeout
    /// property.
    #[cfg(feature = "v1_52")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
    #[doc(alias = "nm_setting_connection_get_ip_ping_timeout")]
    #[doc(alias = "get_ip_ping_timeout")]
    #[doc(alias = "ip-ping-timeout")]
    pub fn ip_ping_timeout(&self) -> u32 {
        unsafe { ffi::nm_setting_connection_get_ip_ping_timeout(self.to_glib_none().0) }
    }

    /// Returns the #NMSettingConnection:lldp property of the connection.
    ///
    /// # Returns
    ///
    /// a `NMSettingConnectionLldp` which indicates whether LLDP must be
    /// enabled for the connection.
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    #[doc(alias = "nm_setting_connection_get_lldp")]
    #[doc(alias = "get_lldp")]
    pub fn lldp(&self) -> SettingConnectionLldp {
        unsafe { from_glib(ffi::nm_setting_connection_get_lldp(self.to_glib_none().0)) }
    }

    ///
    /// # Returns
    ///
    /// the #NMSettingConnection:llmnr property of the setting.
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    #[doc(alias = "nm_setting_connection_get_llmnr")]
    #[doc(alias = "get_llmnr")]
    pub fn llmnr(&self) -> SettingConnectionLlmnr {
        unsafe { from_glib(ffi::nm_setting_connection_get_llmnr(self.to_glib_none().0)) }
    }

    /// Returns the #NMSettingConnection:master property of the connection.
    ///
    /// # Deprecated since 1.46
    ///
    /// Use nm_setting_connection_get_master() instead which
    /// is just an alias.
    ///
    /// # Returns
    ///
    /// interface name of the controller device or UUID of the controller
    /// connection.
    #[cfg_attr(feature = "v1_46", deprecated = "Since 1.46")]
    #[allow(deprecated)]
    #[doc(alias = "nm_setting_connection_get_master")]
    #[doc(alias = "get_master")]
    pub fn master(&self) -> glib::GString {
        unsafe { from_glib_none(ffi::nm_setting_connection_get_master(self.to_glib_none().0)) }
    }

    ///
    /// # Returns
    ///
    /// the #NMSettingConnection:mdns property of the setting.
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    #[doc(alias = "nm_setting_connection_get_mdns")]
    #[doc(alias = "get_mdns")]
    pub fn mdns(&self) -> SettingConnectionMdns {
        unsafe { from_glib(ffi::nm_setting_connection_get_mdns(self.to_glib_none().0)) }
    }

    ///
    /// # Returns
    ///
    /// the #NMSettingConnection:metered property of the setting.
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    #[doc(alias = "nm_setting_connection_get_metered")]
    #[doc(alias = "get_metered")]
    pub fn metered(&self) -> Metered {
        unsafe {
            from_glib(ffi::nm_setting_connection_get_metered(
                self.to_glib_none().0,
            ))
        }
    }

    ///
    /// # Returns
    ///
    /// the #NMSettingConnection:mptcp-flags property of the setting.
    #[cfg(feature = "v1_42")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
    #[doc(alias = "nm_setting_connection_get_mptcp_flags")]
    #[doc(alias = "get_mptcp_flags")]
    #[doc(alias = "mptcp-flags")]
    pub fn mptcp_flags(&self) -> MptcpFlags {
        unsafe {
            from_glib(ffi::nm_setting_connection_get_mptcp_flags(
                self.to_glib_none().0,
            ))
        }
    }

    /// Returns the value contained in the #NMSettingConnection:mud-url
    /// property.
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    #[doc(alias = "nm_setting_connection_get_mud_url")]
    #[doc(alias = "get_mud_url")]
    #[doc(alias = "mud-url")]
    pub fn mud_url(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_setting_connection_get_mud_url(
                self.to_glib_none().0,
            ))
        }
    }

    ///
    /// # Returns
    ///
    /// the #NMSettingConnection:multi-connect property of the connection.
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    #[doc(alias = "nm_setting_connection_get_multi_connect")]
    #[doc(alias = "get_multi_connect")]
    #[doc(alias = "multi-connect")]
    pub fn multi_connect(&self) -> ConnectionMultiConnect {
        unsafe {
            from_glib(ffi::nm_setting_connection_get_multi_connect(
                self.to_glib_none().0,
            ))
        }
    }

    /// Returns the number of entries in the #NMSettingConnection:permissions
    /// property of this setting.
    ///
    /// # Returns
    ///
    /// the number of permissions entries
    #[doc(alias = "nm_setting_connection_get_num_permissions")]
    #[doc(alias = "get_num_permissions")]
    pub fn num_permissions(&self) -> u32 {
        unsafe { ffi::nm_setting_connection_get_num_permissions(self.to_glib_none().0) }
    }

    ///
    /// # Returns
    ///
    /// the number of configured secondary connection UUIDs
    #[doc(alias = "nm_setting_connection_get_num_secondaries")]
    #[doc(alias = "get_num_secondaries")]
    pub fn num_secondaries(&self) -> u32 {
        unsafe { ffi::nm_setting_connection_get_num_secondaries(self.to_glib_none().0) }
    }

    /// Retrieve one of the entries of the #NMSettingConnection:permissions property
    /// of this setting.
    /// ## `idx`
    /// the zero-based index of the permissions entry
    /// ## `out_ptype`
    /// on return, the permission type. This is currently always "user",
    ///   unless the entry is invalid, in which case it returns "invalid".
    /// ## `out_pitem`
    /// on return, the permission item (formatted according to @ptype, see
    /// #NMSettingConnection:permissions for more detail
    /// ## `out_detail`
    /// on return, the permission detail (at this time, always [`None`])
    ///
    /// # Returns
    ///
    /// [`true`] if a permission was returned, [`false`] if @idx was invalid
    #[doc(alias = "nm_setting_connection_get_permission")]
    #[doc(alias = "get_permission")]
    pub fn is_permission(
        &self,
        idx: u32,
        out_ptype: &mut str,
        out_pitem: &mut str,
        out_detail: &mut str,
    ) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_connection_get_permission(
                self.to_glib_none().0,
                idx,
                &mut out_ptype.to_glib_none().0,
                &mut out_pitem.to_glib_none().0,
                &mut out_detail.to_glib_none().0,
            ))
        }
    }

    /// Returns the #NMSettingConnection:port-type property of the connection.
    ///
    /// # Returns
    ///
    /// the type of port this connection is, if any.
    #[cfg(feature = "v1_46")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
    #[doc(alias = "nm_setting_connection_get_port_type")]
    #[doc(alias = "get_port_type")]
    #[doc(alias = "port-type")]
    pub fn port_type(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_setting_connection_get_port_type(
                self.to_glib_none().0,
            ))
        }
    }

    /// Returns the #NMSettingConnection:read-only property of the connection.
    ///
    /// # Deprecated since 1.44
    ///
    /// This property is deprecated and has no meaning.
    ///
    /// # Returns
    ///
    /// [`true`] if the connection is read-only, [`false`] if it is not
    #[cfg_attr(feature = "v1_44", deprecated = "Since 1.44")]
    #[allow(deprecated)]
    #[doc(alias = "nm_setting_connection_get_read_only")]
    #[doc(alias = "get_read_only")]
    #[doc(alias = "read-only")]
    pub fn is_read_only(&self) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_connection_get_read_only(
                self.to_glib_none().0,
            ))
        }
    }

    /// ## `idx`
    /// the zero-based index of the secondary connection UUID entry.
    ///   Access one past the length of secondaries is ok and will return
    ///   [`None`]. Otherwise, it is a user error.
    ///
    /// # Returns
    ///
    /// the secondary connection UUID at index @idx or
    ///   [`None`] if @idx is the number of secondaries.
    #[doc(alias = "nm_setting_connection_get_secondary")]
    #[doc(alias = "get_secondary")]
    pub fn secondary(&self, idx: u32) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_setting_connection_get_secondary(
                self.to_glib_none().0,
                idx,
            ))
        }
    }

    /// Returns the #NMSettingConnection:slave-type property of the connection.
    ///
    /// # Deprecated since 1.46
    ///
    /// Use nm_setting_connection_get_port_type() instead which
    /// is just an alias.
    ///
    /// # Returns
    ///
    /// the type of port this connection is, if any
    #[cfg_attr(feature = "v1_46", deprecated = "Since 1.46")]
    #[allow(deprecated)]
    #[doc(alias = "nm_setting_connection_get_slave_type")]
    #[doc(alias = "get_slave_type")]
    #[doc(alias = "slave-type")]
    pub fn slave_type(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_setting_connection_get_slave_type(
                self.to_glib_none().0,
            ))
        }
    }

    /// Returns the #NMSettingConnection:stable_id property of the connection.
    ///
    /// # Returns
    ///
    /// the stable-id for the connection
    #[cfg(feature = "v1_4")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_4")))]
    #[doc(alias = "nm_setting_connection_get_stable_id")]
    #[doc(alias = "get_stable_id")]
    #[doc(alias = "stable-id")]
    pub fn stable_id(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_setting_connection_get_stable_id(
                self.to_glib_none().0,
            ))
        }
    }

    /// Returns the #NMSettingConnection:timestamp property of the connection.
    ///
    /// # Returns
    ///
    /// the connection's timestamp
    #[doc(alias = "nm_setting_connection_get_timestamp")]
    #[doc(alias = "get_timestamp")]
    pub fn timestamp(&self) -> u64 {
        unsafe { ffi::nm_setting_connection_get_timestamp(self.to_glib_none().0) }
    }

    /// Returns the #NMSettingConnection:uuid property of the connection.
    ///
    /// # Returns
    ///
    /// the connection UUID
    #[doc(alias = "nm_setting_connection_get_uuid")]
    #[doc(alias = "get_uuid")]
    pub fn uuid(&self) -> glib::GString {
        unsafe { from_glib_none(ffi::nm_setting_connection_get_uuid(self.to_glib_none().0)) }
    }

    ///
    /// # Returns
    ///
    /// the [`SETTING_CONNECTION_WAIT_ACTIVATION_DELAY`][crate::SETTING_CONNECTION_WAIT_ACTIVATION_DELAY] property with
    ///   the delay in milliseconds. -1 is the default.
    #[cfg(feature = "v1_40")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_40")))]
    #[doc(alias = "nm_setting_connection_get_wait_activation_delay")]
    #[doc(alias = "get_wait_activation_delay")]
    #[doc(alias = "wait-activation-delay")]
    pub fn wait_activation_delay(&self) -> i32 {
        unsafe { ffi::nm_setting_connection_get_wait_activation_delay(self.to_glib_none().0) }
    }

    ///
    /// # Returns
    ///
    /// the [`SETTING_CONNECTION_WAIT_DEVICE_TIMEOUT`][crate::SETTING_CONNECTION_WAIT_DEVICE_TIMEOUT] property with
    ///   the timeout in milliseconds. -1 is the default.
    #[cfg(feature = "v1_20")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
    #[doc(alias = "nm_setting_connection_get_wait_device_timeout")]
    #[doc(alias = "get_wait_device_timeout")]
    #[doc(alias = "wait-device-timeout")]
    pub fn wait_device_timeout(&self) -> i32 {
        unsafe { ffi::nm_setting_connection_get_wait_device_timeout(self.to_glib_none().0) }
    }

    /// Returns the #NMSettingConnection:zone property of the connection.
    ///
    /// # Returns
    ///
    /// the trust level of a connection
    #[doc(alias = "nm_setting_connection_get_zone")]
    #[doc(alias = "get_zone")]
    pub fn zone(&self) -> glib::GString {
        unsafe { from_glib_none(ffi::nm_setting_connection_get_zone(self.to_glib_none().0)) }
    }

    ///
    /// # Deprecated since 1.46
    ///
    /// ## `type_`
    /// the setting name (ie #NM_SETTING_BOND_SETTING_NAME) to be matched
    /// against @self's port type
    ///
    /// # Returns
    ///
    /// [`true`] if connection is of the given port @type_
    #[cfg_attr(feature = "v1_46", deprecated = "Since 1.46")]
    #[allow(deprecated)]
    #[doc(alias = "nm_setting_connection_is_slave_type")]
    pub fn is_slave_type(&self, type_: &str) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_connection_is_slave_type(
                self.to_glib_none().0,
                type_.to_glib_none().0,
            ))
        }
    }

    /// Checks whether the given username is allowed to view/access this connection.
    /// ## `uname`
    /// the user name to check permissions for
    ///
    /// # Returns
    ///
    /// [`true`] if the requested user is allowed to view this connection,
    /// [`false`] if the given user is not allowed to view this connection
    #[doc(alias = "nm_setting_connection_permissions_user_allowed")]
    pub fn permissions_user_allowed(&self, uname: &str) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_connection_permissions_user_allowed(
                self.to_glib_none().0,
                uname.to_glib_none().0,
            ))
        }
    }

    /// Removes the IP address at index @idx.
    /// ## `idx`
    /// index number of the IP address
    #[cfg(feature = "v1_52")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
    #[doc(alias = "nm_setting_connection_remove_ip_ping_address")]
    pub fn remove_ip_ping_address(&self, idx: u32) {
        unsafe {
            ffi::nm_setting_connection_remove_ip_ping_address(self.to_glib_none().0, idx);
        }
    }

    /// Removes the IP address @address from ip-ping-addresses.
    /// ## `address`
    /// the IP address to remove
    ///
    /// # Returns
    ///
    /// [`true`] if the IP address was found and removed; [`false`] if it was not.
    #[cfg(feature = "v1_52")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
    #[doc(alias = "nm_setting_connection_remove_ip_ping_address_by_value")]
    pub fn remove_ip_ping_address_by_value(&self, address: &str) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_connection_remove_ip_ping_address_by_value(
                self.to_glib_none().0,
                address.to_glib_none().0,
            ))
        }
    }

    /// Removes the permission at index @idx from the connection.
    /// ## `idx`
    /// the zero-based index of the permission to remove
    #[doc(alias = "nm_setting_connection_remove_permission")]
    pub fn remove_permission(&self, idx: u32) {
        unsafe {
            ffi::nm_setting_connection_remove_permission(self.to_glib_none().0, idx);
        }
    }

    /// Removes the permission from the connection.
    /// At this time, only the "user" permission type is supported, and @pitem must
    /// be a username. See #NMSettingConnection:permissions: for more details.
    /// ## `ptype`
    /// the permission type; at this time only "user" is supported
    /// ## `pitem`
    /// the permission item formatted as required for @ptype
    /// ## `detail`
    /// unused at this time; must be [`None`]
    ///
    /// # Returns
    ///
    /// [`true`] if the permission was found and removed; [`false`] if it was not.
    #[doc(alias = "nm_setting_connection_remove_permission_by_value")]
    pub fn remove_permission_by_value(
        &self,
        ptype: &str,
        pitem: &str,
        detail: Option<&str>,
    ) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_connection_remove_permission_by_value(
                self.to_glib_none().0,
                ptype.to_glib_none().0,
                pitem.to_glib_none().0,
                detail.to_glib_none().0,
            ))
        }
    }

    /// Removes the secondary connection UUID at index @idx.
    /// ## `idx`
    /// index number of the secondary connection UUID
    #[doc(alias = "nm_setting_connection_remove_secondary")]
    pub fn remove_secondary(&self, idx: u32) {
        unsafe {
            ffi::nm_setting_connection_remove_secondary(self.to_glib_none().0, idx);
        }
    }

    /// Removes the secondary connection UUID @sec_uuid.
    /// ## `sec_uuid`
    /// the secondary connection UUID to remove
    ///
    /// # Returns
    ///
    /// [`true`] if the secondary connection UUID was found and removed; [`false`] if it was not.
    #[doc(alias = "nm_setting_connection_remove_secondary_by_value")]
    pub fn remove_secondary_by_value(&self, sec_uuid: &str) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_connection_remove_secondary_by_value(
                self.to_glib_none().0,
                sec_uuid.to_glib_none().0,
            ))
        }
    }

    /// The number of retries for the authentication. Zero means to try indefinitely; -1 means
    /// to use a global default. If the global default is not set, the authentication
    /// retries for 3 times before failing the connection.
    ///
    /// Currently, this only applies to 802-1x authentication.
    #[cfg(feature = "v1_10")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
    #[doc(alias = "auth-retries")]
    pub fn set_auth_retries(&self, auth_retries: i32) {
        ObjectExt::set_property(self, "auth-retries", auth_retries)
    }

    /// Whether or not the connection should be automatically connected by
    /// NetworkManager when the resources for the connection are available.
    /// [`true`] to automatically activate the connection, [`false`] to require manual
    /// intervention to activate the connection.
    ///
    /// Autoconnect happens when the circumstances are suitable. That means for
    /// example that the device is currently managed and not active. Autoconnect
    /// thus never replaces or competes with an already active profile.
    ///
    /// Note that autoconnect is not implemented for VPN profiles. See
    /// #NMSettingConnection:secondaries as an alternative to automatically
    /// connect VPN profiles.
    ///
    /// If multiple profiles are ready to autoconnect on the same device,
    /// the one with the better "connection.autoconnect-priority" is chosen. If
    /// the priorities are equal, then the most recently connected profile is activated.
    /// If the profiles were not connected earlier or their
    /// "connection.timestamp" is identical, the choice is undefined.
    ///
    /// Depending on "connection.multi-connect", a profile can (auto)connect only
    /// once at a time or multiple times.
    pub fn set_autoconnect(&self, autoconnect: bool) {
        ObjectExt::set_property(self, "autoconnect", autoconnect)
    }

    /// Whether or not ports of this connection should be automatically brought up
    /// when NetworkManager activates this connection. This only has a real effect
    /// for controller connections. The properties #NMSettingConnection:autoconnect,
    /// #NMSettingConnection:autoconnect-priority and #NMSettingConnection:autoconnect-retries
    /// are unrelated to this setting.
    /// The permitted values are: 0: leave port connections untouched,
    /// 1: activate all the port connections with this connection, -1: default.
    /// If -1 (default) is set, global connection.autoconnect-ports is read to
    /// determine the real value. If it is default as well, this fallbacks to 0.
    #[cfg(feature = "v1_46")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
    #[doc(alias = "autoconnect-ports")]
    pub fn set_autoconnect_ports(&self, autoconnect_ports: i32) {
        ObjectExt::set_property(self, "autoconnect-ports", autoconnect_ports)
    }

    /// The autoconnect priority in range -999 to 999. If the connection is set
    /// to autoconnect, connections with higher priority will be preferred.
    /// The higher number means higher priority. Defaults to 0.
    /// Note that this property only matters if there are more than one candidate
    /// profile to select for autoconnect. In case of equal priority, the profile
    /// used most recently is chosen.
    #[doc(alias = "autoconnect-priority")]
    pub fn set_autoconnect_priority(&self, autoconnect_priority: i32) {
        ObjectExt::set_property(self, "autoconnect-priority", autoconnect_priority)
    }

    #[cfg(not(feature = "v1_6"))]
    #[cfg_attr(docsrs, doc(cfg(not(feature = "v1_6"))))]
    #[doc(alias = "autoconnect-retries")]
    pub fn autoconnect_retries(&self) -> i32 {
        ObjectExt::property(self, "autoconnect-retries")
    }

    /// The number of times a connection should be tried when autoactivating before
    /// giving up. Zero means forever, -1 means the global default (4 times if not
    /// overridden). Setting this to 1 means to try activation only once before
    /// blocking autoconnect. Note that after a timeout, NetworkManager will try
    /// to autoconnect again.
    #[doc(alias = "autoconnect-retries")]
    pub fn set_autoconnect_retries(&self, autoconnect_retries: i32) {
        ObjectExt::set_property(self, "autoconnect-retries", autoconnect_retries)
    }

    /// Whether or not ports of this connection should be automatically brought up
    /// when NetworkManager activates this connection. This only has a real effect
    /// for controller connections. The properties #NMSettingConnection:autoconnect,
    /// #NMSettingConnection:autoconnect-priority and #NMSettingConnection:autoconnect-retries
    /// are unrelated to this setting.
    /// The permitted values are: 0: leave port connections untouched,
    /// 1: activate all the port connections with this connection, -1: default.
    /// If -1 (default) is set, global connection.autoconnect-slaves is read to
    /// determine the real value. If it is default as well, this fallbacks to 0.
    ///
    /// Deprecated 1.46. Use #NMSettingConnection:autoconnect-ports instead, this is just an alias.
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    #[doc(alias = "autoconnect-slaves")]
    pub fn set_autoconnect_slaves(&self, autoconnect_slaves: SettingConnectionAutoconnectSlaves) {
        ObjectExt::set_property(self, "autoconnect-slaves", autoconnect_slaves)
    }

    #[cfg(not(feature = "v1_46"))]
    #[cfg_attr(docsrs, doc(cfg(not(feature = "v1_46"))))]
    pub fn controller(&self) -> Option<glib::GString> {
        ObjectExt::property(self, "controller")
    }

    /// Interface name of the controller device or UUID of the controller connection.
    pub fn set_controller(&self, controller: Option<&str>) {
        ObjectExt::set_property(self, "controller", controller)
    }

    /// Whether DNSOverTls (dns-over-tls) is enabled for the connection.
    /// DNSOverTls is a technology which uses TLS to encrypt dns traffic.
    ///
    /// The permitted values are: "yes" (2) use DNSOverTls and disabled fallback,
    /// "opportunistic" (1) use DNSOverTls but allow fallback to unencrypted resolution,
    /// "no" (0) don't ever use DNSOverTls.
    /// If unspecified "default" depends on the plugin used. Systemd-resolved
    /// uses global setting.
    ///
    /// This feature requires a plugin which supports DNSOverTls. Otherwise, the
    /// setting has no effect. One such plugin is dns-systemd-resolved.
    #[cfg(feature = "v1_34")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_34")))]
    #[doc(alias = "dns-over-tls")]
    pub fn set_dns_over_tls(&self, dns_over_tls: i32) {
        ObjectExt::set_property(self, "dns-over-tls", dns_over_tls)
    }

    /// Whether the connection will be brought down before the system is powered
    /// off.  The default value is [`SettingConnectionDownOnPoweroff::Default`][crate::SettingConnectionDownOnPoweroff::Default]. When
    /// the default value is specified, then the global value from
    /// NetworkManager configuration is looked up, if not set, it is considered
    /// as [`SettingConnectionDownOnPoweroff::No`][crate::SettingConnectionDownOnPoweroff::No].
    #[cfg(feature = "v1_48")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_48")))]
    #[doc(alias = "down-on-poweroff")]
    pub fn set_down_on_poweroff(&self, down_on_poweroff: i32) {
        ObjectExt::set_property(self, "down-on-poweroff", down_on_poweroff)
    }

    /// If greater than zero, delay success of IP addressing until either the
    /// timeout is reached, or an IP gateway replies to a ping.
    #[doc(alias = "gateway-ping-timeout")]
    pub fn set_gateway_ping_timeout(&self, gateway_ping_timeout: u32) {
        ObjectExt::set_property(self, "gateway-ping-timeout", gateway_ping_timeout)
    }

    /// A human readable unique identifier for the connection, like "Work Wi-Fi"
    /// or "T-Mobile 3G".
    pub fn set_id(&self, id: Option<&str>) {
        ObjectExt::set_property(self, "id", id)
    }

    /// The name of the network interface this connection is bound to. If not
    /// set, then the connection can be attached to any interface of the
    /// appropriate type (subject to restrictions imposed by other settings).
    ///
    /// For software devices this specifies the name of the created device.
    ///
    /// For connection types where interface names cannot easily be made
    /// persistent (e.g. mobile broadband or USB Ethernet), this property should
    /// not be used. Setting this property restricts the interfaces a connection
    /// can be used with, and if interface names change or are reordered the
    /// connection may be applied to the wrong interface.
    #[doc(alias = "interface-name")]
    pub fn set_interface_name(&self, interface_name: Option<&str>) {
        ObjectExt::set_property(self, "interface-name", interface_name)
    }

    /// The property specifies a list of target IP addresses for pinging.
    /// When multiple targets are set, NetworkManager will start multiple ping processes
    /// in parallel. This property can only be set if connection.ip-ping-timeout is
    /// set. The ip-ping-timeout is used to delay the success of IP addressing until
    /// either the specified timeout (in seconds) is reached, or an target IP address replies
    /// to a ping. Configuring #NMSettingConnection:ip-ping-addresses may delay reaching the
    /// systemd's network-online.target due to waiting for the ping operations to complete or timeout.
    #[cfg(feature = "v1_52")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
    #[doc(alias = "ip-ping-addresses")]
    pub fn ip_ping_addresses(&self) -> Vec<glib::GString> {
        ObjectExt::property(self, "ip-ping-addresses")
    }

    /// The property specifies a list of target IP addresses for pinging.
    /// When multiple targets are set, NetworkManager will start multiple ping processes
    /// in parallel. This property can only be set if connection.ip-ping-timeout is
    /// set. The ip-ping-timeout is used to delay the success of IP addressing until
    /// either the specified timeout (in seconds) is reached, or an target IP address replies
    /// to a ping. Configuring #NMSettingConnection:ip-ping-addresses may delay reaching the
    /// systemd's network-online.target due to waiting for the ping operations to complete or timeout.
    #[cfg(feature = "v1_52")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
    #[doc(alias = "ip-ping-addresses")]
    pub fn set_ip_ping_addresses(&self, ip_ping_addresses: &[&str]) {
        ObjectExt::set_property(self, "ip-ping-addresses", ip_ping_addresses)
    }

    /// The property determines whether it is sufficient for any ping check
    /// to succeed among #NMSettingConnection:ip-ping-addresses, or if all
    /// ping checks must succeed for #NMSettingConnection:ip-ping-addresses.
    #[cfg(feature = "v1_52")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
    #[doc(alias = "ip-ping-addresses-require-all")]
    pub fn set_ip_ping_addresses_require_all(&self, ip_ping_addresses_require_all: i32) {
        ObjectExt::set_property(
            self,
            "ip-ping-addresses-require-all",
            ip_ping_addresses_require_all,
        )
    }

    /// If greater than zero, delay success of IP addressing until either the specified
    /// timeout (in seconds) is reached, or a target IP address replies to a ping. The
    /// property specifies the timeout for the #NMSettingConnection:ip-ping-addresses.
    /// This property is incompatible with #NMSettingConnection:gateway-ping-timeout,
    /// you cannot set these two properties at the same time.
    #[cfg(feature = "v1_52")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
    #[doc(alias = "ip-ping-timeout")]
    pub fn set_ip_ping_timeout(&self, ip_ping_timeout: u32) {
        ObjectExt::set_property(self, "ip-ping-timeout", ip_ping_timeout)
    }

    /// Whether LLDP is enabled for the connection.
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn set_lldp(&self, lldp: i32) {
        ObjectExt::set_property(self, "lldp", lldp)
    }

    /// Whether Link-Local Multicast Name Resolution (LLMNR) is enabled
    /// for the connection. LLMNR is a protocol based on the Domain Name
    /// System (DNS) packet format that allows both IPv4 and IPv6 hosts
    /// to perform name resolution for hosts on the same local link.
    ///
    /// The permitted values are: "yes" (2) register hostname and resolving
    /// for the connection, "no" (0) disable LLMNR for the interface, "resolve"
    /// (1) do not register hostname but allow resolving of LLMNR host names
    /// If unspecified, "default" ultimately depends on the DNS plugin (which
    /// for systemd-resolved currently means "yes").
    ///
    /// This feature requires a plugin which supports LLMNR. Otherwise, the
    /// setting has no effect. One such plugin is dns-systemd-resolved.
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn set_llmnr(&self, llmnr: i32) {
        ObjectExt::set_property(self, "llmnr", llmnr)
    }

    /// Interface name of the controller device or UUID of the controller connection.
    ///
    /// Deprecated 1.46. Use #NMSettingConnection:controller instead, this is just an alias.
    pub fn set_master(&self, master: Option<&str>) {
        ObjectExt::set_property(self, "master", master)
    }

    /// Whether mDNS is enabled for the connection.
    ///
    /// The permitted values are: "yes" (2) register hostname and resolving
    /// for the connection, "no" (0) disable mDNS for the interface, "resolve"
    /// (1) do not register hostname but allow resolving of mDNS host names
    /// and "default" (-1) to allow lookup of a global default in NetworkManager.conf.
    /// If unspecified, "default" ultimately depends on the DNS plugin.
    ///
    /// This feature requires a plugin which supports mDNS. Otherwise, the
    /// setting has no effect. Currently the only supported DNS plugin is
    /// systemd-resolved. For systemd-resolved, the default is configurable via
    /// MulticastDNS= setting in resolved.conf.
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn set_mdns(&self, mdns: i32) {
        ObjectExt::set_property(self, "mdns", mdns)
    }

    /// Whether the connection is metered.
    ///
    /// When updating this property on a currently activated connection,
    /// the change takes effect immediately.
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn set_metered(&self, metered: Metered) {
        ObjectExt::set_property(self, "metered", metered)
    }

    #[cfg(not(feature = "v1_42"))]
    #[cfg_attr(docsrs, doc(cfg(not(feature = "v1_42"))))]
    #[doc(alias = "mptcp-flags")]
    pub fn mptcp_flags(&self) -> u32 {
        ObjectExt::property(self, "mptcp-flags")
    }

    /// Whether to configure MPTCP endpoints and the address flags.
    /// If MPTCP is enabled in NetworkManager, it will configure the
    /// addresses of the interface as MPTCP endpoints. Note that
    /// IPv4 loopback addresses (127.0.0.0/8), IPv4 link local
    /// addresses (169.254.0.0/16), the IPv6 loopback address (::1),
    /// IPv6 link local addresses (fe80::/10), IPv6 unique
    /// local addresses (ULA, fc00::/7) and IPv6 privacy extension addresses
    /// (rfc3041, ipv6.ip6-privacy) will be excluded from being
    /// configured as endpoints.
    ///
    /// If "disabled" (0x1), MPTCP handling for the interface is disabled and
    /// no endpoints are registered.
    ///
    /// The "enabled" (0x2) flag means that MPTCP handling is enabled.
    /// This flag can also be implied from the presence of other flags.
    ///
    /// Even when enabled, MPTCP handling will by default still be disabled
    /// unless "/proc/sys/net/mptcp/enabled" sysctl is on. NetworkManager
    /// does not change the sysctl and this is up to the administrator
    /// or distribution. To configure endpoints even if the sysctl is
    /// disabled, "also-without-sysctl" (0x4) flag can be used. In that case,
    /// NetworkManager doesn't look at the sysctl and configures endpoints
    /// regardless.
    ///
    /// Even when enabled, NetworkManager will only configure MPTCP endpoints
    /// for a certain address family, if there is a unicast default route (0.0.0.0/0
    /// or ::/0) in the main routing table. The flag "also-without-default-route"
    /// (0x8) can override that.
    ///
    /// When MPTCP handling is enabled then endpoints are configured with
    /// the specified address flags "signal" (0x10), "subflow" (0x20), "backup" (0x40),
    /// "fullmesh" (0x80). See ip-mptcp(8) manual for additional information about the flags.
    ///
    /// If the flags are zero (0x0), the global connection default from NetworkManager.conf is
    /// honored. If still unspecified, the fallback is "enabled,subflow".
    /// Note that this means that MPTCP is by default done depending on the
    /// "/proc/sys/net/mptcp/enabled" sysctl.
    ///
    /// NetworkManager does not change the MPTCP limits nor enable MPTCP via
    /// "/proc/sys/net/mptcp/enabled". That is a host configuration which the
    /// admin can change via sysctl and ip-mptcp.
    ///
    /// Strict reverse path filtering (rp_filter) breaks many MPTCP use cases, so when
    /// MPTCP handling for IPv4 addresses on the interface is enabled, NetworkManager would
    /// loosen the strict reverse path filtering (1) to the loose setting (2).
    #[cfg(feature = "v1_40")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_40")))]
    #[doc(alias = "mptcp-flags")]
    pub fn set_mptcp_flags(&self, mptcp_flags: u32) {
        ObjectExt::set_property(self, "mptcp-flags", mptcp_flags)
    }

    /// If configured, set to a Manufacturer Usage Description (MUD) URL that points
    /// to manufacturer-recommended network policies for IoT devices. It is transmitted
    /// as a DHCPv4 or DHCPv6 option. The value must be a valid URL starting with "https://".
    ///
    /// The special value "none" is allowed to indicate that no MUD URL is used.
    ///
    /// If the per-profile value is unspecified (the default), a global connection default gets
    /// consulted. If still unspecified, the ultimate default is "none".
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    #[doc(alias = "mud-url")]
    pub fn set_mud_url(&self, mud_url: Option<&str>) {
        ObjectExt::set_property(self, "mud-url", mud_url)
    }

    /// Specifies whether the profile can be active multiple times at a particular
    /// moment. The value is of type #NMConnectionMultiConnect.
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    #[doc(alias = "multi-connect")]
    pub fn set_multi_connect(&self, multi_connect: i32) {
        ObjectExt::set_property(self, "multi-connect", multi_connect)
    }

    /// An array of strings defining what access a given user has to this
    /// connection.  If this is [`None`] or empty, all users are allowed to access
    /// this connection; otherwise users are allowed if and only if they are in
    /// this list.  When this is not empty, the connection can be active only when
    /// one of the specified users is logged into an active session.  Each entry
    /// is of the form "[type]:[id]:[reserved]"; for example, "user:dcbw:blah".
    ///
    /// At this time only the "user" [type] is allowed.  Any other values are
    /// ignored and reserved for future use.  [id] is the username that this
    /// permission refers to, which may not contain the ":" character. Any
    /// [reserved] information present must be ignored and is reserved for future
    /// use.  All of [type], [id], and [reserved] must be valid UTF-8.
    pub fn permissions(&self) -> Vec<glib::GString> {
        ObjectExt::property(self, "permissions")
    }

    /// An array of strings defining what access a given user has to this
    /// connection.  If this is [`None`] or empty, all users are allowed to access
    /// this connection; otherwise users are allowed if and only if they are in
    /// this list.  When this is not empty, the connection can be active only when
    /// one of the specified users is logged into an active session.  Each entry
    /// is of the form "[type]:[id]:[reserved]"; for example, "user:dcbw:blah".
    ///
    /// At this time only the "user" [type] is allowed.  Any other values are
    /// ignored and reserved for future use.  [id] is the username that this
    /// permission refers to, which may not contain the ":" character. Any
    /// [reserved] information present must be ignored and is reserved for future
    /// use.  All of [type], [id], and [reserved] must be valid UTF-8.
    pub fn set_permissions(&self, permissions: &[&str]) {
        ObjectExt::set_property(self, "permissions", permissions)
    }

    /// Setting name of the device type of this port's controller connection (eg,
    /// [`SETTING_BOND_SETTING_NAME`][crate::SETTING_BOND_SETTING_NAME]), or [`None`] if this connection is not a
    /// port.
    #[cfg(feature = "v1_46")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
    #[doc(alias = "port-type")]
    pub fn set_port_type(&self, port_type: Option<&str>) {
        ObjectExt::set_property(self, "port-type", port_type)
    }

    /// This property is deprecated and has no meaning.
    ///
    /// # Deprecated since 1.44
    ///
    /// This property is deprecated and has no meaning.
    #[cfg_attr(feature = "v1_44", deprecated = "Since 1.44")]
    #[doc(alias = "read-only")]
    pub fn set_read_only(&self, read_only: bool) {
        ObjectExt::set_property(self, "read-only", read_only)
    }

    /// List of connection UUIDs that should be activated when the base
    /// connection itself is activated. Currently, only VPN connections are
    /// supported.
    pub fn secondaries(&self) -> Vec<glib::GString> {
        ObjectExt::property(self, "secondaries")
    }

    /// List of connection UUIDs that should be activated when the base
    /// connection itself is activated. Currently, only VPN connections are
    /// supported.
    pub fn set_secondaries(&self, secondaries: &[&str]) {
        ObjectExt::set_property(self, "secondaries", secondaries)
    }

    /// Setting name of the device type of this port's controller connection (eg,
    /// [`SETTING_BOND_SETTING_NAME`][crate::SETTING_BOND_SETTING_NAME]), or [`None`] if this connection is not a
    /// port.
    ///
    /// Deprecated 1.46. Use #NMSettingConnection:port-type instead, this is just an alias.
    #[doc(alias = "slave-type")]
    pub fn set_slave_type(&self, slave_type: Option<&str>) {
        ObjectExt::set_property(self, "slave-type", slave_type)
    }

    /// This represents the identity of the connection used for various purposes.
    /// It allows configuring multiple profiles to share the identity. Also,
    /// the stable-id can contain placeholders that are substituted dynamically and
    /// deterministically depending on the context.
    ///
    /// The stable-id is used for generating IPv6 stable private addresses with
    /// ipv6.addr-gen-mode=stable-privacy. It is also used to seed the generated
    /// cloned MAC address for ethernet.cloned-mac-address=stable and
    /// wifi.cloned-mac-address=stable. It is also used to derive the DHCP
    /// client identifier with ipv4.dhcp-client-id=stable, the DHCPv6 DUID with
    /// ipv6.dhcp-duid=stable-[llt,ll,uuid] and the DHCP IAID with
    /// ipv4.iaid=stable and ipv6.iaid=stable.
    ///
    /// Note that depending on the context where it is used, other parameters are
    /// also seeded into the generation algorithm. For example, a per-host key
    /// is commonly also included, so that different systems end up generating
    /// different IDs. Or with ipv6.addr-gen-mode=stable-privacy, also the device's
    /// name is included, so that different interfaces yield different addresses.
    /// The per-host key is the identity of your machine and stored in /var/lib/NetworkManager/secret_key.
    /// See NetworkManager(8) manual about the secret-key and the host identity.
    ///
    /// The '$' character is treated special to perform dynamic substitutions at
    /// activation time. Currently, supported are "${CONNECTION}", "${DEVICE}",
    /// "${MAC}", "${NETWORK_SSID}", "${BOOT}", "${RANDOM}".  These effectively
    /// create unique IDs per-connection, per-device, per-SSID, per-boot, or
    /// every time.  The "${CONNECTION}" uses the profile's connection.uuid, the
    /// "${DEVICE}" uses the interface name of the device and "${MAC}" the
    /// permanent MAC address of the device. "${NETWORK_SSID}" uses the SSID for
    /// Wi-Fi networks and falls back to "${CONNECTION}" on other networks. Any
    /// unrecognized patterns following '$' are treated verbatim, however are
    /// reserved for future use. You are thus advised to avoid '$' or escape it
    /// as "$$".  For example, set it to "${CONNECTION}-${BOOT}-${DEVICE}" to
    /// create a unique id for this connection that changes with every reboot
    /// and differs depending on the interface where the profile activates.
    ///
    /// If the value is unset, a global connection default is consulted. If the
    /// value is still unset, the default is "default${CONNECTION}" go generate
    /// an ID unique per connection profile.
    #[cfg(feature = "v1_4")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_4")))]
    #[doc(alias = "stable-id")]
    pub fn set_stable_id(&self, stable_id: Option<&str>) {
        ObjectExt::set_property(self, "stable-id", stable_id)
    }

    /// The time, in seconds since the Unix Epoch, that the connection was last
    /// _successfully_ fully activated.
    ///
    /// NetworkManager updates the connection timestamp periodically when the
    /// connection is active to ensure that an active connection has the latest
    /// timestamp. The property is only meant for reading (changes to this
    /// property will not be preserved).
    pub fn set_timestamp(&self, timestamp: u64) {
        ObjectExt::set_property(self, "timestamp", timestamp)
    }

    /// Base type of the connection. For hardware-dependent connections, should
    /// contain the setting name of the hardware-type specific setting (ie,
    /// "802-3-ethernet" or "802-11-wireless" or "bluetooth", etc), and for
    /// non-hardware dependent connections like VPN or otherwise, should contain
    /// the setting name of that setting type (ie, "vpn" or "bridge", etc).
    #[doc(alias = "type")]
    pub fn type_(&self) -> Option<glib::GString> {
        ObjectExt::property(self, "type")
    }

    /// Base type of the connection. For hardware-dependent connections, should
    /// contain the setting name of the hardware-type specific setting (ie,
    /// "802-3-ethernet" or "802-11-wireless" or "bluetooth", etc), and for
    /// non-hardware dependent connections like VPN or otherwise, should contain
    /// the setting name of that setting type (ie, "vpn" or "bridge", etc).
    #[doc(alias = "type")]
    pub fn set_type(&self, type_: Option<&str>) {
        ObjectExt::set_property(self, "type", type_)
    }

    /// A universally unique identifier for the connection, for example generated
    /// with libuuid.  It should be assigned when the connection is created, and
    /// never changed as long as the connection still applies to the same
    /// network.  For example, it should not be changed when the
    /// #NMSettingConnection:id property or #NMSettingIP4Config changes, but
    /// might need to be re-created when the Wi-Fi SSID, mobile broadband network
    /// provider, or #NMSettingConnection:type property changes.
    ///
    /// The UUID must be in the format "2815492f-7e56-435e-b2e9-246bd7cdc664"
    /// (ie, contains only hexadecimal characters and "-").  A suitable UUID may
    /// be generated by nm_utils_uuid_generate() or
    /// nm_uuid_generate_from_string_str().
    pub fn set_uuid(&self, uuid: Option<&str>) {
        ObjectExt::set_property(self, "uuid", uuid)
    }

    /// Time in milliseconds to wait for connection to be considered activated.
    /// The wait will start after the pre-up dispatcher event.
    ///
    /// The value 0 means no wait time. The default value is -1, which
    /// currently has the same meaning as no wait time.
    #[cfg(feature = "v1_40")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_40")))]
    #[doc(alias = "wait-activation-delay")]
    pub fn set_wait_activation_delay(&self, wait_activation_delay: i32) {
        ObjectExt::set_property(self, "wait-activation-delay", wait_activation_delay)
    }

    /// Timeout in milliseconds to wait for device at startup.
    /// During boot, devices may take a while to be detected by the driver.
    /// This property will cause to delay NetworkManager-wait-online.service
    /// and nm-online to give the device a chance to appear. This works by
    /// waiting for the given timeout until a compatible device for the
    /// profile is available and managed.
    ///
    /// The value 0 means no wait time. The default value is -1, which
    /// currently has the same meaning as no wait time.
    #[cfg(feature = "v1_20")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
    #[doc(alias = "wait-device-timeout")]
    pub fn set_wait_device_timeout(&self, wait_device_timeout: i32) {
        ObjectExt::set_property(self, "wait-device-timeout", wait_device_timeout)
    }

    /// The trust level of a the connection.  Free form case-insensitive string
    /// (for example "Home", "Work", "Public").  [`None`] or unspecified zone means
    /// the connection will be placed in the default zone as defined by the
    /// firewall.
    ///
    /// When updating this property on a currently activated connection,
    /// the change takes effect immediately.
    pub fn set_zone(&self, zone: Option<&str>) {
        ObjectExt::set_property(self, "zone", zone)
    }

    #[cfg(feature = "v1_10")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
    #[doc(alias = "auth-retries")]
    pub fn connect_auth_retries_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_auth_retries_trampoline<F: Fn(&SettingConnection) + 'static>(
            this: *mut ffi::NMSettingConnection,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::auth-retries".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_auth_retries_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "autoconnect")]
    pub fn connect_autoconnect_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_autoconnect_trampoline<F: Fn(&SettingConnection) + 'static>(
            this: *mut ffi::NMSettingConnection,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::autoconnect".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_autoconnect_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(feature = "v1_46")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
    #[doc(alias = "autoconnect-ports")]
    pub fn connect_autoconnect_ports_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_autoconnect_ports_trampoline<
            F: Fn(&SettingConnection) + 'static,
        >(
            this: *mut ffi::NMSettingConnection,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::autoconnect-ports".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_autoconnect_ports_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "autoconnect-priority")]
    pub fn connect_autoconnect_priority_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_autoconnect_priority_trampoline<
            F: Fn(&SettingConnection) + 'static,
        >(
            this: *mut ffi::NMSettingConnection,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::autoconnect-priority".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_autoconnect_priority_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "autoconnect-retries")]
    pub fn connect_autoconnect_retries_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_autoconnect_retries_trampoline<
            F: Fn(&SettingConnection) + 'static,
        >(
            this: *mut ffi::NMSettingConnection,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::autoconnect-retries".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_autoconnect_retries_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    #[doc(alias = "autoconnect-slaves")]
    pub fn connect_autoconnect_slaves_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_autoconnect_slaves_trampoline<
            F: Fn(&SettingConnection) + 'static,
        >(
            this: *mut ffi::NMSettingConnection,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::autoconnect-slaves".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_autoconnect_slaves_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "controller")]
    pub fn connect_controller_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_controller_trampoline<F: Fn(&SettingConnection) + 'static>(
            this: *mut ffi::NMSettingConnection,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::controller".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_controller_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(feature = "v1_34")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_34")))]
    #[doc(alias = "dns-over-tls")]
    pub fn connect_dns_over_tls_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_dns_over_tls_trampoline<F: Fn(&SettingConnection) + 'static>(
            this: *mut ffi::NMSettingConnection,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::dns-over-tls".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_dns_over_tls_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(feature = "v1_48")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_48")))]
    #[doc(alias = "down-on-poweroff")]
    pub fn connect_down_on_poweroff_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_down_on_poweroff_trampoline<
            F: Fn(&SettingConnection) + 'static,
        >(
            this: *mut ffi::NMSettingConnection,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::down-on-poweroff".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_down_on_poweroff_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "gateway-ping-timeout")]
    pub fn connect_gateway_ping_timeout_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_gateway_ping_timeout_trampoline<
            F: Fn(&SettingConnection) + 'static,
        >(
            this: *mut ffi::NMSettingConnection,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::gateway-ping-timeout".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_gateway_ping_timeout_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "id")]
    pub fn connect_id_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_id_trampoline<F: Fn(&SettingConnection) + 'static>(
            this: *mut ffi::NMSettingConnection,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::id".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_id_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "interface-name")]
    pub fn connect_interface_name_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_interface_name_trampoline<
            F: Fn(&SettingConnection) + 'static,
        >(
            this: *mut ffi::NMSettingConnection,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::interface-name".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_interface_name_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(feature = "v1_52")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
    #[doc(alias = "ip-ping-addresses")]
    pub fn connect_ip_ping_addresses_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_ip_ping_addresses_trampoline<
            F: Fn(&SettingConnection) + 'static,
        >(
            this: *mut ffi::NMSettingConnection,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::ip-ping-addresses".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_ip_ping_addresses_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(feature = "v1_52")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
    #[doc(alias = "ip-ping-addresses-require-all")]
    pub fn connect_ip_ping_addresses_require_all_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_ip_ping_addresses_require_all_trampoline<
            F: Fn(&SettingConnection) + 'static,
        >(
            this: *mut ffi::NMSettingConnection,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::ip-ping-addresses-require-all".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_ip_ping_addresses_require_all_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(feature = "v1_52")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
    #[doc(alias = "ip-ping-timeout")]
    pub fn connect_ip_ping_timeout_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_ip_ping_timeout_trampoline<
            F: Fn(&SettingConnection) + 'static,
        >(
            this: *mut ffi::NMSettingConnection,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::ip-ping-timeout".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_ip_ping_timeout_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    #[doc(alias = "lldp")]
    pub fn connect_lldp_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_lldp_trampoline<F: Fn(&SettingConnection) + 'static>(
            this: *mut ffi::NMSettingConnection,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::lldp".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_lldp_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    #[doc(alias = "llmnr")]
    pub fn connect_llmnr_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_llmnr_trampoline<F: Fn(&SettingConnection) + 'static>(
            this: *mut ffi::NMSettingConnection,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::llmnr".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_llmnr_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "master")]
    pub fn connect_master_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_master_trampoline<F: Fn(&SettingConnection) + 'static>(
            this: *mut ffi::NMSettingConnection,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::master".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_master_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    #[doc(alias = "mdns")]
    pub fn connect_mdns_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_mdns_trampoline<F: Fn(&SettingConnection) + 'static>(
            this: *mut ffi::NMSettingConnection,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::mdns".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_mdns_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    #[doc(alias = "metered")]
    pub fn connect_metered_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_metered_trampoline<F: Fn(&SettingConnection) + 'static>(
            this: *mut ffi::NMSettingConnection,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::metered".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_metered_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(feature = "v1_40")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_40")))]
    #[doc(alias = "mptcp-flags")]
    pub fn connect_mptcp_flags_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_mptcp_flags_trampoline<F: Fn(&SettingConnection) + 'static>(
            this: *mut ffi::NMSettingConnection,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::mptcp-flags".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_mptcp_flags_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    #[doc(alias = "mud-url")]
    pub fn connect_mud_url_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_mud_url_trampoline<F: Fn(&SettingConnection) + 'static>(
            this: *mut ffi::NMSettingConnection,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::mud-url".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_mud_url_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    #[doc(alias = "multi-connect")]
    pub fn connect_multi_connect_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_multi_connect_trampoline<
            F: Fn(&SettingConnection) + 'static,
        >(
            this: *mut ffi::NMSettingConnection,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::multi-connect".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_multi_connect_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "permissions")]
    pub fn connect_permissions_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_permissions_trampoline<F: Fn(&SettingConnection) + 'static>(
            this: *mut ffi::NMSettingConnection,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::permissions".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_permissions_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(feature = "v1_46")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
    #[doc(alias = "port-type")]
    pub fn connect_port_type_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_port_type_trampoline<F: Fn(&SettingConnection) + 'static>(
            this: *mut ffi::NMSettingConnection,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::port-type".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_port_type_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg_attr(feature = "v1_44", deprecated = "Since 1.44")]
    #[doc(alias = "read-only")]
    pub fn connect_read_only_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_read_only_trampoline<F: Fn(&SettingConnection) + 'static>(
            this: *mut ffi::NMSettingConnection,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::read-only".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_read_only_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "secondaries")]
    pub fn connect_secondaries_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_secondaries_trampoline<F: Fn(&SettingConnection) + 'static>(
            this: *mut ffi::NMSettingConnection,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::secondaries".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_secondaries_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "slave-type")]
    pub fn connect_slave_type_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_slave_type_trampoline<F: Fn(&SettingConnection) + 'static>(
            this: *mut ffi::NMSettingConnection,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::slave-type".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_slave_type_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(feature = "v1_4")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_4")))]
    #[doc(alias = "stable-id")]
    pub fn connect_stable_id_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_stable_id_trampoline<F: Fn(&SettingConnection) + 'static>(
            this: *mut ffi::NMSettingConnection,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::stable-id".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_stable_id_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "timestamp")]
    pub fn connect_timestamp_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_timestamp_trampoline<F: Fn(&SettingConnection) + 'static>(
            this: *mut ffi::NMSettingConnection,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::timestamp".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_timestamp_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "type")]
    pub fn connect_type_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_type_trampoline<F: Fn(&SettingConnection) + 'static>(
            this: *mut ffi::NMSettingConnection,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::type".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_type_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "uuid")]
    pub fn connect_uuid_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_uuid_trampoline<F: Fn(&SettingConnection) + 'static>(
            this: *mut ffi::NMSettingConnection,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::uuid".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_uuid_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(feature = "v1_40")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_40")))]
    #[doc(alias = "wait-activation-delay")]
    pub fn connect_wait_activation_delay_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_wait_activation_delay_trampoline<
            F: Fn(&SettingConnection) + 'static,
        >(
            this: *mut ffi::NMSettingConnection,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::wait-activation-delay".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_wait_activation_delay_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(feature = "v1_20")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
    #[doc(alias = "wait-device-timeout")]
    pub fn connect_wait_device_timeout_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_wait_device_timeout_trampoline<
            F: Fn(&SettingConnection) + 'static,
        >(
            this: *mut ffi::NMSettingConnection,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::wait-device-timeout".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_wait_device_timeout_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "zone")]
    pub fn connect_zone_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_zone_trampoline<F: Fn(&SettingConnection) + 'static>(
            this: *mut ffi::NMSettingConnection,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::zone".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_zone_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }
}

impl Default for SettingConnection {
    fn default() -> Self {
        Self::new()
    }
}

// rustdoc-stripper-ignore-next
/// A [builder-pattern] type to construct [`SettingConnection`] objects.
///
/// [builder-pattern]: https://doc.rust-lang.org/1.0.0/style/ownership/builders.html
#[must_use = "The builder must be built to be used"]
pub struct SettingConnectionBuilder {
    builder: glib::object::ObjectBuilder<'static, SettingConnection>,
}

impl SettingConnectionBuilder {
    fn new() -> Self {
        Self {
            builder: glib::object::Object::builder(),
        }
    }

    /// The number of retries for the authentication. Zero means to try indefinitely; -1 means
    /// to use a global default. If the global default is not set, the authentication
    /// retries for 3 times before failing the connection.
    ///
    /// Currently, this only applies to 802-1x authentication.
    #[cfg(feature = "v1_10")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
    pub fn auth_retries(self, auth_retries: i32) -> Self {
        Self {
            builder: self.builder.property("auth-retries", auth_retries),
        }
    }

    /// Whether or not the connection should be automatically connected by
    /// NetworkManager when the resources for the connection are available.
    /// [`true`] to automatically activate the connection, [`false`] to require manual
    /// intervention to activate the connection.
    ///
    /// Autoconnect happens when the circumstances are suitable. That means for
    /// example that the device is currently managed and not active. Autoconnect
    /// thus never replaces or competes with an already active profile.
    ///
    /// Note that autoconnect is not implemented for VPN profiles. See
    /// #NMSettingConnection:secondaries as an alternative to automatically
    /// connect VPN profiles.
    ///
    /// If multiple profiles are ready to autoconnect on the same device,
    /// the one with the better "connection.autoconnect-priority" is chosen. If
    /// the priorities are equal, then the most recently connected profile is activated.
    /// If the profiles were not connected earlier or their
    /// "connection.timestamp" is identical, the choice is undefined.
    ///
    /// Depending on "connection.multi-connect", a profile can (auto)connect only
    /// once at a time or multiple times.
    pub fn autoconnect(self, autoconnect: bool) -> Self {
        Self {
            builder: self.builder.property("autoconnect", autoconnect),
        }
    }

    /// Whether or not ports of this connection should be automatically brought up
    /// when NetworkManager activates this connection. This only has a real effect
    /// for controller connections. The properties #NMSettingConnection:autoconnect,
    /// #NMSettingConnection:autoconnect-priority and #NMSettingConnection:autoconnect-retries
    /// are unrelated to this setting.
    /// The permitted values are: 0: leave port connections untouched,
    /// 1: activate all the port connections with this connection, -1: default.
    /// If -1 (default) is set, global connection.autoconnect-ports is read to
    /// determine the real value. If it is default as well, this fallbacks to 0.
    #[cfg(feature = "v1_46")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
    pub fn autoconnect_ports(self, autoconnect_ports: i32) -> Self {
        Self {
            builder: self
                .builder
                .property("autoconnect-ports", autoconnect_ports),
        }
    }

    /// The autoconnect priority in range -999 to 999. If the connection is set
    /// to autoconnect, connections with higher priority will be preferred.
    /// The higher number means higher priority. Defaults to 0.
    /// Note that this property only matters if there are more than one candidate
    /// profile to select for autoconnect. In case of equal priority, the profile
    /// used most recently is chosen.
    pub fn autoconnect_priority(self, autoconnect_priority: i32) -> Self {
        Self {
            builder: self
                .builder
                .property("autoconnect-priority", autoconnect_priority),
        }
    }

    /// The number of times a connection should be tried when autoactivating before
    /// giving up. Zero means forever, -1 means the global default (4 times if not
    /// overridden). Setting this to 1 means to try activation only once before
    /// blocking autoconnect. Note that after a timeout, NetworkManager will try
    /// to autoconnect again.
    pub fn autoconnect_retries(self, autoconnect_retries: i32) -> Self {
        Self {
            builder: self
                .builder
                .property("autoconnect-retries", autoconnect_retries),
        }
    }

    /// Whether or not ports of this connection should be automatically brought up
    /// when NetworkManager activates this connection. This only has a real effect
    /// for controller connections. The properties #NMSettingConnection:autoconnect,
    /// #NMSettingConnection:autoconnect-priority and #NMSettingConnection:autoconnect-retries
    /// are unrelated to this setting.
    /// The permitted values are: 0: leave port connections untouched,
    /// 1: activate all the port connections with this connection, -1: default.
    /// If -1 (default) is set, global connection.autoconnect-slaves is read to
    /// determine the real value. If it is default as well, this fallbacks to 0.
    ///
    /// Deprecated 1.46. Use #NMSettingConnection:autoconnect-ports instead, this is just an alias.
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn autoconnect_slaves(
        self,
        autoconnect_slaves: SettingConnectionAutoconnectSlaves,
    ) -> Self {
        Self {
            builder: self
                .builder
                .property("autoconnect-slaves", autoconnect_slaves),
        }
    }

    /// Interface name of the controller device or UUID of the controller connection.
    pub fn controller(self, controller: impl Into<glib::GString>) -> Self {
        Self {
            builder: self.builder.property("controller", controller.into()),
        }
    }

    /// Whether DNSOverTls (dns-over-tls) is enabled for the connection.
    /// DNSOverTls is a technology which uses TLS to encrypt dns traffic.
    ///
    /// The permitted values are: "yes" (2) use DNSOverTls and disabled fallback,
    /// "opportunistic" (1) use DNSOverTls but allow fallback to unencrypted resolution,
    /// "no" (0) don't ever use DNSOverTls.
    /// If unspecified "default" depends on the plugin used. Systemd-resolved
    /// uses global setting.
    ///
    /// This feature requires a plugin which supports DNSOverTls. Otherwise, the
    /// setting has no effect. One such plugin is dns-systemd-resolved.
    #[cfg(feature = "v1_34")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_34")))]
    pub fn dns_over_tls(self, dns_over_tls: i32) -> Self {
        Self {
            builder: self.builder.property("dns-over-tls", dns_over_tls),
        }
    }

    /// Whether the connection will be brought down before the system is powered
    /// off.  The default value is [`SettingConnectionDownOnPoweroff::Default`][crate::SettingConnectionDownOnPoweroff::Default]. When
    /// the default value is specified, then the global value from
    /// NetworkManager configuration is looked up, if not set, it is considered
    /// as [`SettingConnectionDownOnPoweroff::No`][crate::SettingConnectionDownOnPoweroff::No].
    #[cfg(feature = "v1_48")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_48")))]
    pub fn down_on_poweroff(self, down_on_poweroff: i32) -> Self {
        Self {
            builder: self.builder.property("down-on-poweroff", down_on_poweroff),
        }
    }

    /// If greater than zero, delay success of IP addressing until either the
    /// timeout is reached, or an IP gateway replies to a ping.
    pub fn gateway_ping_timeout(self, gateway_ping_timeout: u32) -> Self {
        Self {
            builder: self
                .builder
                .property("gateway-ping-timeout", gateway_ping_timeout),
        }
    }

    /// A human readable unique identifier for the connection, like "Work Wi-Fi"
    /// or "T-Mobile 3G".
    pub fn id(self, id: impl Into<glib::GString>) -> Self {
        Self {
            builder: self.builder.property("id", id.into()),
        }
    }

    /// The name of the network interface this connection is bound to. If not
    /// set, then the connection can be attached to any interface of the
    /// appropriate type (subject to restrictions imposed by other settings).
    ///
    /// For software devices this specifies the name of the created device.
    ///
    /// For connection types where interface names cannot easily be made
    /// persistent (e.g. mobile broadband or USB Ethernet), this property should
    /// not be used. Setting this property restricts the interfaces a connection
    /// can be used with, and if interface names change or are reordered the
    /// connection may be applied to the wrong interface.
    pub fn interface_name(self, interface_name: impl Into<glib::GString>) -> Self {
        Self {
            builder: self
                .builder
                .property("interface-name", interface_name.into()),
        }
    }

    /// The property specifies a list of target IP addresses for pinging.
    /// When multiple targets are set, NetworkManager will start multiple ping processes
    /// in parallel. This property can only be set if connection.ip-ping-timeout is
    /// set. The ip-ping-timeout is used to delay the success of IP addressing until
    /// either the specified timeout (in seconds) is reached, or an target IP address replies
    /// to a ping. Configuring #NMSettingConnection:ip-ping-addresses may delay reaching the
    /// systemd's network-online.target due to waiting for the ping operations to complete or timeout.
    #[cfg(feature = "v1_52")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
    pub fn ip_ping_addresses(self, ip_ping_addresses: impl Into<glib::StrV>) -> Self {
        Self {
            builder: self
                .builder
                .property("ip-ping-addresses", ip_ping_addresses.into()),
        }
    }

    /// The property determines whether it is sufficient for any ping check
    /// to succeed among #NMSettingConnection:ip-ping-addresses, or if all
    /// ping checks must succeed for #NMSettingConnection:ip-ping-addresses.
    #[cfg(feature = "v1_52")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
    pub fn ip_ping_addresses_require_all(self, ip_ping_addresses_require_all: i32) -> Self {
        Self {
            builder: self.builder.property(
                "ip-ping-addresses-require-all",
                ip_ping_addresses_require_all,
            ),
        }
    }

    /// If greater than zero, delay success of IP addressing until either the specified
    /// timeout (in seconds) is reached, or a target IP address replies to a ping. The
    /// property specifies the timeout for the #NMSettingConnection:ip-ping-addresses.
    /// This property is incompatible with #NMSettingConnection:gateway-ping-timeout,
    /// you cannot set these two properties at the same time.
    #[cfg(feature = "v1_52")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
    pub fn ip_ping_timeout(self, ip_ping_timeout: u32) -> Self {
        Self {
            builder: self.builder.property("ip-ping-timeout", ip_ping_timeout),
        }
    }

    /// Whether LLDP is enabled for the connection.
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn lldp(self, lldp: i32) -> Self {
        Self {
            builder: self.builder.property("lldp", lldp),
        }
    }

    /// Whether Link-Local Multicast Name Resolution (LLMNR) is enabled
    /// for the connection. LLMNR is a protocol based on the Domain Name
    /// System (DNS) packet format that allows both IPv4 and IPv6 hosts
    /// to perform name resolution for hosts on the same local link.
    ///
    /// The permitted values are: "yes" (2) register hostname and resolving
    /// for the connection, "no" (0) disable LLMNR for the interface, "resolve"
    /// (1) do not register hostname but allow resolving of LLMNR host names
    /// If unspecified, "default" ultimately depends on the DNS plugin (which
    /// for systemd-resolved currently means "yes").
    ///
    /// This feature requires a plugin which supports LLMNR. Otherwise, the
    /// setting has no effect. One such plugin is dns-systemd-resolved.
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn llmnr(self, llmnr: i32) -> Self {
        Self {
            builder: self.builder.property("llmnr", llmnr),
        }
    }

    /// Interface name of the controller device or UUID of the controller connection.
    ///
    /// Deprecated 1.46. Use #NMSettingConnection:controller instead, this is just an alias.
    pub fn master(self, master: impl Into<glib::GString>) -> Self {
        Self {
            builder: self.builder.property("master", master.into()),
        }
    }

    /// Whether mDNS is enabled for the connection.
    ///
    /// The permitted values are: "yes" (2) register hostname and resolving
    /// for the connection, "no" (0) disable mDNS for the interface, "resolve"
    /// (1) do not register hostname but allow resolving of mDNS host names
    /// and "default" (-1) to allow lookup of a global default in NetworkManager.conf.
    /// If unspecified, "default" ultimately depends on the DNS plugin.
    ///
    /// This feature requires a plugin which supports mDNS. Otherwise, the
    /// setting has no effect. Currently the only supported DNS plugin is
    /// systemd-resolved. For systemd-resolved, the default is configurable via
    /// MulticastDNS= setting in resolved.conf.
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn mdns(self, mdns: i32) -> Self {
        Self {
            builder: self.builder.property("mdns", mdns),
        }
    }

    /// Whether the connection is metered.
    ///
    /// When updating this property on a currently activated connection,
    /// the change takes effect immediately.
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn metered(self, metered: Metered) -> Self {
        Self {
            builder: self.builder.property("metered", metered),
        }
    }

    /// Whether to configure MPTCP endpoints and the address flags.
    /// If MPTCP is enabled in NetworkManager, it will configure the
    /// addresses of the interface as MPTCP endpoints. Note that
    /// IPv4 loopback addresses (127.0.0.0/8), IPv4 link local
    /// addresses (169.254.0.0/16), the IPv6 loopback address (::1),
    /// IPv6 link local addresses (fe80::/10), IPv6 unique
    /// local addresses (ULA, fc00::/7) and IPv6 privacy extension addresses
    /// (rfc3041, ipv6.ip6-privacy) will be excluded from being
    /// configured as endpoints.
    ///
    /// If "disabled" (0x1), MPTCP handling for the interface is disabled and
    /// no endpoints are registered.
    ///
    /// The "enabled" (0x2) flag means that MPTCP handling is enabled.
    /// This flag can also be implied from the presence of other flags.
    ///
    /// Even when enabled, MPTCP handling will by default still be disabled
    /// unless "/proc/sys/net/mptcp/enabled" sysctl is on. NetworkManager
    /// does not change the sysctl and this is up to the administrator
    /// or distribution. To configure endpoints even if the sysctl is
    /// disabled, "also-without-sysctl" (0x4) flag can be used. In that case,
    /// NetworkManager doesn't look at the sysctl and configures endpoints
    /// regardless.
    ///
    /// Even when enabled, NetworkManager will only configure MPTCP endpoints
    /// for a certain address family, if there is a unicast default route (0.0.0.0/0
    /// or ::/0) in the main routing table. The flag "also-without-default-route"
    /// (0x8) can override that.
    ///
    /// When MPTCP handling is enabled then endpoints are configured with
    /// the specified address flags "signal" (0x10), "subflow" (0x20), "backup" (0x40),
    /// "fullmesh" (0x80). See ip-mptcp(8) manual for additional information about the flags.
    ///
    /// If the flags are zero (0x0), the global connection default from NetworkManager.conf is
    /// honored. If still unspecified, the fallback is "enabled,subflow".
    /// Note that this means that MPTCP is by default done depending on the
    /// "/proc/sys/net/mptcp/enabled" sysctl.
    ///
    /// NetworkManager does not change the MPTCP limits nor enable MPTCP via
    /// "/proc/sys/net/mptcp/enabled". That is a host configuration which the
    /// admin can change via sysctl and ip-mptcp.
    ///
    /// Strict reverse path filtering (rp_filter) breaks many MPTCP use cases, so when
    /// MPTCP handling for IPv4 addresses on the interface is enabled, NetworkManager would
    /// loosen the strict reverse path filtering (1) to the loose setting (2).
    #[cfg(feature = "v1_40")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_40")))]
    pub fn mptcp_flags(self, mptcp_flags: u32) -> Self {
        Self {
            builder: self.builder.property("mptcp-flags", mptcp_flags),
        }
    }

    /// If configured, set to a Manufacturer Usage Description (MUD) URL that points
    /// to manufacturer-recommended network policies for IoT devices. It is transmitted
    /// as a DHCPv4 or DHCPv6 option. The value must be a valid URL starting with "https://".
    ///
    /// The special value "none" is allowed to indicate that no MUD URL is used.
    ///
    /// If the per-profile value is unspecified (the default), a global connection default gets
    /// consulted. If still unspecified, the ultimate default is "none".
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    pub fn mud_url(self, mud_url: impl Into<glib::GString>) -> Self {
        Self {
            builder: self.builder.property("mud-url", mud_url.into()),
        }
    }

    /// Specifies whether the profile can be active multiple times at a particular
    /// moment. The value is of type #NMConnectionMultiConnect.
    #[cfg(feature = "v1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
    pub fn multi_connect(self, multi_connect: i32) -> Self {
        Self {
            builder: self.builder.property("multi-connect", multi_connect),
        }
    }

    /// An array of strings defining what access a given user has to this
    /// connection.  If this is [`None`] or empty, all users are allowed to access
    /// this connection; otherwise users are allowed if and only if they are in
    /// this list.  When this is not empty, the connection can be active only when
    /// one of the specified users is logged into an active session.  Each entry
    /// is of the form "[type]:[id]:[reserved]"; for example, "user:dcbw:blah".
    ///
    /// At this time only the "user" [type] is allowed.  Any other values are
    /// ignored and reserved for future use.  [id] is the username that this
    /// permission refers to, which may not contain the ":" character. Any
    /// [reserved] information present must be ignored and is reserved for future
    /// use.  All of [type], [id], and [reserved] must be valid UTF-8.
    pub fn permissions(self, permissions: impl Into<glib::StrV>) -> Self {
        Self {
            builder: self.builder.property("permissions", permissions.into()),
        }
    }

    /// Setting name of the device type of this port's controller connection (eg,
    /// [`SETTING_BOND_SETTING_NAME`][crate::SETTING_BOND_SETTING_NAME]), or [`None`] if this connection is not a
    /// port.
    #[cfg(feature = "v1_46")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
    pub fn port_type(self, port_type: impl Into<glib::GString>) -> Self {
        Self {
            builder: self.builder.property("port-type", port_type.into()),
        }
    }

    /// This property is deprecated and has no meaning.
    /// This property is deprecated and has no meaning.
    #[cfg_attr(feature = "v1_44", deprecated = "Since 1.44")]
    pub fn read_only(self, read_only: bool) -> Self {
        Self {
            builder: self.builder.property("read-only", read_only),
        }
    }

    /// List of connection UUIDs that should be activated when the base
    /// connection itself is activated. Currently, only VPN connections are
    /// supported.
    pub fn secondaries(self, secondaries: impl Into<glib::StrV>) -> Self {
        Self {
            builder: self.builder.property("secondaries", secondaries.into()),
        }
    }

    /// Setting name of the device type of this port's controller connection (eg,
    /// [`SETTING_BOND_SETTING_NAME`][crate::SETTING_BOND_SETTING_NAME]), or [`None`] if this connection is not a
    /// port.
    ///
    /// Deprecated 1.46. Use #NMSettingConnection:port-type instead, this is just an alias.
    pub fn slave_type(self, slave_type: impl Into<glib::GString>) -> Self {
        Self {
            builder: self.builder.property("slave-type", slave_type.into()),
        }
    }

    /// This represents the identity of the connection used for various purposes.
    /// It allows configuring multiple profiles to share the identity. Also,
    /// the stable-id can contain placeholders that are substituted dynamically and
    /// deterministically depending on the context.
    ///
    /// The stable-id is used for generating IPv6 stable private addresses with
    /// ipv6.addr-gen-mode=stable-privacy. It is also used to seed the generated
    /// cloned MAC address for ethernet.cloned-mac-address=stable and
    /// wifi.cloned-mac-address=stable. It is also used to derive the DHCP
    /// client identifier with ipv4.dhcp-client-id=stable, the DHCPv6 DUID with
    /// ipv6.dhcp-duid=stable-[llt,ll,uuid] and the DHCP IAID with
    /// ipv4.iaid=stable and ipv6.iaid=stable.
    ///
    /// Note that depending on the context where it is used, other parameters are
    /// also seeded into the generation algorithm. For example, a per-host key
    /// is commonly also included, so that different systems end up generating
    /// different IDs. Or with ipv6.addr-gen-mode=stable-privacy, also the device's
    /// name is included, so that different interfaces yield different addresses.
    /// The per-host key is the identity of your machine and stored in /var/lib/NetworkManager/secret_key.
    /// See NetworkManager(8) manual about the secret-key and the host identity.
    ///
    /// The '$' character is treated special to perform dynamic substitutions at
    /// activation time. Currently, supported are "${CONNECTION}", "${DEVICE}",
    /// "${MAC}", "${NETWORK_SSID}", "${BOOT}", "${RANDOM}".  These effectively
    /// create unique IDs per-connection, per-device, per-SSID, per-boot, or
    /// every time.  The "${CONNECTION}" uses the profile's connection.uuid, the
    /// "${DEVICE}" uses the interface name of the device and "${MAC}" the
    /// permanent MAC address of the device. "${NETWORK_SSID}" uses the SSID for
    /// Wi-Fi networks and falls back to "${CONNECTION}" on other networks. Any
    /// unrecognized patterns following '$' are treated verbatim, however are
    /// reserved for future use. You are thus advised to avoid '$' or escape it
    /// as "$$".  For example, set it to "${CONNECTION}-${BOOT}-${DEVICE}" to
    /// create a unique id for this connection that changes with every reboot
    /// and differs depending on the interface where the profile activates.
    ///
    /// If the value is unset, a global connection default is consulted. If the
    /// value is still unset, the default is "default${CONNECTION}" go generate
    /// an ID unique per connection profile.
    #[cfg(feature = "v1_4")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_4")))]
    pub fn stable_id(self, stable_id: impl Into<glib::GString>) -> Self {
        Self {
            builder: self.builder.property("stable-id", stable_id.into()),
        }
    }

    /// The time, in seconds since the Unix Epoch, that the connection was last
    /// _successfully_ fully activated.
    ///
    /// NetworkManager updates the connection timestamp periodically when the
    /// connection is active to ensure that an active connection has the latest
    /// timestamp. The property is only meant for reading (changes to this
    /// property will not be preserved).
    pub fn timestamp(self, timestamp: u64) -> Self {
        Self {
            builder: self.builder.property("timestamp", timestamp),
        }
    }

    pub fn type_(self, type_: impl Into<glib::GString>) -> Self {
        Self {
            builder: self.builder.property("type", type_.into()),
        }
    }

    /// A universally unique identifier for the connection, for example generated
    /// with libuuid.  It should be assigned when the connection is created, and
    /// never changed as long as the connection still applies to the same
    /// network.  For example, it should not be changed when the
    /// #NMSettingConnection:id property or #NMSettingIP4Config changes, but
    /// might need to be re-created when the Wi-Fi SSID, mobile broadband network
    /// provider, or #NMSettingConnection:type property changes.
    ///
    /// The UUID must be in the format "2815492f-7e56-435e-b2e9-246bd7cdc664"
    /// (ie, contains only hexadecimal characters and "-").  A suitable UUID may
    /// be generated by nm_utils_uuid_generate() or
    /// nm_uuid_generate_from_string_str().
    pub fn uuid(self, uuid: impl Into<glib::GString>) -> Self {
        Self {
            builder: self.builder.property("uuid", uuid.into()),
        }
    }

    /// Time in milliseconds to wait for connection to be considered activated.
    /// The wait will start after the pre-up dispatcher event.
    ///
    /// The value 0 means no wait time. The default value is -1, which
    /// currently has the same meaning as no wait time.
    #[cfg(feature = "v1_40")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_40")))]
    pub fn wait_activation_delay(self, wait_activation_delay: i32) -> Self {
        Self {
            builder: self
                .builder
                .property("wait-activation-delay", wait_activation_delay),
        }
    }

    /// Timeout in milliseconds to wait for device at startup.
    /// During boot, devices may take a while to be detected by the driver.
    /// This property will cause to delay NetworkManager-wait-online.service
    /// and nm-online to give the device a chance to appear. This works by
    /// waiting for the given timeout until a compatible device for the
    /// profile is available and managed.
    ///
    /// The value 0 means no wait time. The default value is -1, which
    /// currently has the same meaning as no wait time.
    #[cfg(feature = "v1_20")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
    pub fn wait_device_timeout(self, wait_device_timeout: i32) -> Self {
        Self {
            builder: self
                .builder
                .property("wait-device-timeout", wait_device_timeout),
        }
    }

    /// The trust level of a the connection.  Free form case-insensitive string
    /// (for example "Home", "Work", "Public").  [`None`] or unspecified zone means
    /// the connection will be placed in the default zone as defined by the
    /// firewall.
    ///
    /// When updating this property on a currently activated connection,
    /// the change takes effect immediately.
    pub fn zone(self, zone: impl Into<glib::GString>) -> Self {
        Self {
            builder: self.builder.property("zone", zone.into()),
        }
    }

    // rustdoc-stripper-ignore-next
    /// Build the [`SettingConnection`].
    #[must_use = "Building the object from the builder is usually expensive and is not expected to have side effects"]
    pub fn build(self) -> SettingConnection {
        assert_initialized_main_thread!();
        self.builder.build()
    }
}
