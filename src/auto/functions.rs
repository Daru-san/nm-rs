// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir
// from gtk-girs (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use crate::{80211ApFlags,80211ApSecurityFlags,ffi,DeviceWifiCapabilities,UtilsSecurityType,WepKeyType};
#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
use crate::{TCAction,TCQdisc,TCTfilter};
#[cfg(feature = "v1_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
use crate::{SriovVF};
#[cfg(feature = "v1_40")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_40")))]
use crate::{Connection};
use glib::{translate::*};


#[cfg(feature = "v1_40")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_40")))]
#[doc(alias = "nm_conn_wireguard_import")]
pub fn conn_wireguard_import(filename: &str) -> Result<Connection, glib::Error> {
    assert_initialized_main_thread!();
    unsafe {
        let mut error = std::ptr::null_mut();
        let ret = ffi::nm_conn_wireguard_import(filename.to_glib_none().0, &mut error);
        if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) }
    }
}

#[cfg(feature = "v1_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
#[doc(alias = "nm_ethtool_optname_is_channels")]
pub fn ethtool_optname_is_channels(optname: Option<&str>) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::nm_ethtool_optname_is_channels(optname.to_glib_none().0))
    }
}

#[cfg(feature = "v1_26")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
#[doc(alias = "nm_ethtool_optname_is_coalesce")]
pub fn ethtool_optname_is_coalesce(optname: Option<&str>) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::nm_ethtool_optname_is_coalesce(optname.to_glib_none().0))
    }
}

#[cfg(feature = "v1_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
#[doc(alias = "nm_ethtool_optname_is_eee")]
pub fn ethtool_optname_is_eee(optname: Option<&str>) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::nm_ethtool_optname_is_eee(optname.to_glib_none().0))
    }
}

#[cfg(feature = "v1_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
#[doc(alias = "nm_ethtool_optname_is_feature")]
pub fn ethtool_optname_is_feature(optname: Option<&str>) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::nm_ethtool_optname_is_feature(optname.to_glib_none().0))
    }
}

#[cfg(feature = "v1_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_52")))]
#[doc(alias = "nm_ethtool_optname_is_fec")]
pub fn ethtool_optname_is_fec(optname: Option<&str>) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::nm_ethtool_optname_is_fec(optname.to_glib_none().0))
    }
}

#[cfg(feature = "v1_32")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_32")))]
#[doc(alias = "nm_ethtool_optname_is_pause")]
pub fn ethtool_optname_is_pause(optname: Option<&str>) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::nm_ethtool_optname_is_pause(optname.to_glib_none().0))
    }
}

#[cfg(feature = "v1_26")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
#[doc(alias = "nm_ethtool_optname_is_ring")]
pub fn ethtool_optname_is_ring(optname: Option<&str>) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::nm_ethtool_optname_is_ring(optname.to_glib_none().0))
    }
}

//#[cfg(feature = "v1_30")]
//#[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
//#[doc(alias = "nm_keyfile_read")]
//pub fn keyfile_read(keyfile: /*Ignored*/&glib::KeyFile, base_dir: &str, handler_flags: KeyfileHandlerFlags, handler: /*Unimplemented*/FnMut(/*Ignored*/glib::KeyFile, &Connection, &KeyfileHandlerType, &KeyfileHandlerData) -> bool, user_data: /*Unimplemented*/Option<Basic: Pointer>) -> Result<Connection, glib::Error> {
//    unsafe { TODO: call ffi:nm_keyfile_read() }
//}

//#[cfg(feature = "v1_30")]
//#[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
//#[doc(alias = "nm_keyfile_write")]
//pub fn keyfile_write(connection: &impl IsA<Connection>, handler_flags: KeyfileHandlerFlags, handler: /*Unimplemented*/FnMut(&Connection, /*Ignored*/glib::KeyFile, &KeyfileHandlerType, &KeyfileHandlerData) -> bool, user_data: /*Unimplemented*/Option<Basic: Pointer>) -> Result</*Ignored*/glib::KeyFile, glib::Error> {
//    unsafe { TODO: call ffi:nm_keyfile_write() }
//}

#[doc(alias = "nm_utils_ap_mode_security_valid")]
pub fn utils_ap_mode_security_valid(type_: UtilsSecurityType, wifi_caps: DeviceWifiCapabilities) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::nm_utils_ap_mode_security_valid(type_.into_glib(), wifi_caps.into_glib()))
    }
}

#[cfg(feature = "v1_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
#[doc(alias = "nm_utils_base64secret_decode")]
pub fn utils_base64secret_decode(base64_key: &str) -> Option<u8> {
    assert_initialized_main_thread!();
    let required_key_len = base64_key.len() as _;
    unsafe {
        let mut out_key = std::mem::MaybeUninit::uninit();
        let ret = from_glib(ffi::nm_utils_base64secret_decode(base64_key.to_glib_none().0, required_key_len, out_key.as_mut_ptr()));
        if ret { Some(out_key.assume_init()) } else { None }
    }
}

#[doc(alias = "nm_utils_bin2hexstr")]
pub fn utils_bin2hexstr(src: &[u8], final_len: i32) -> glib::GString {
    assert_initialized_main_thread!();
    let len = src.len() as _;
    unsafe {
        from_glib_full(ffi::nm_utils_bin2hexstr(src.to_glib_none().0, len, final_len))
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
#[doc(alias = "nm_utils_bond_mode_int_to_string")]
pub fn utils_bond_mode_int_to_string(mode: i32) -> glib::GString {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::nm_utils_bond_mode_int_to_string(mode))
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
#[doc(alias = "nm_utils_bond_mode_string_to_int")]
pub fn utils_bond_mode_string_to_int(mode: &str) -> i32 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::nm_utils_bond_mode_string_to_int(mode.to_glib_none().0)
    }
}

#[doc(alias = "nm_utils_check_virtual_device_compatibility")]
pub fn utils_check_virtual_device_compatibility(virtual_type: glib::types::Type, other_type: glib::types::Type) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::nm_utils_check_virtual_device_compatibility(virtual_type.into_glib(), other_type.into_glib()))
    }
}

#[cfg(feature = "v1_42")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
#[doc(alias = "nm_utils_ensure_gtypes")]
pub fn utils_ensure_gtypes() {
    assert_initialized_main_thread!();
    unsafe {
        ffi::nm_utils_ensure_gtypes();
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
#[doc(alias = "nm_utils_enum_from_str")]
pub fn utils_enum_from_str(type_: glib::types::Type, str: &str) -> Option<(i32, Option<glib::GString>)> {
    assert_initialized_main_thread!();
    unsafe {
        let mut out_value = std::mem::MaybeUninit::uninit();
        let mut err_token = std::ptr::null_mut();
        let ret = from_glib(ffi::nm_utils_enum_from_str(type_.into_glib(), str.to_glib_none().0, out_value.as_mut_ptr(), &mut err_token));
        if ret { Some((out_value.assume_init(), from_glib_full(err_token))) } else { None }
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
#[doc(alias = "nm_utils_enum_get_values")]
pub fn utils_enum_get_values(type_: glib::types::Type, from: i32, to: i32) -> Vec<glib::GString> {
    assert_initialized_main_thread!();
    unsafe {
        FromGlibPtrContainer::from_glib_container(ffi::nm_utils_enum_get_values(type_.into_glib(), from, to))
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
#[doc(alias = "nm_utils_enum_to_str")]
pub fn utils_enum_to_str(type_: glib::types::Type, value: i32) -> glib::GString {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::nm_utils_enum_to_str(type_.into_glib(), value))
    }
}

#[cfg_attr(feature = "v1_46", deprecated = "Since 1.46")]
#[allow(deprecated)]
#[doc(alias = "nm_utils_escape_ssid")]
pub fn utils_escape_ssid(ssid: &[u8]) -> glib::GString {
    assert_initialized_main_thread!();
    let len = ssid.len() as _;
    unsafe {
        from_glib_none(ffi::nm_utils_escape_ssid(ssid.to_glib_none().0, len))
    }
}

#[doc(alias = "nm_utils_file_is_certificate")]
pub fn utils_file_is_certificate(filename: &str) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::nm_utils_file_is_certificate(filename.to_glib_none().0))
    }
}

#[doc(alias = "nm_utils_file_is_pkcs12")]
pub fn utils_file_is_pkcs12(filename: &str) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::nm_utils_file_is_pkcs12(filename.to_glib_none().0))
    }
}

#[doc(alias = "nm_utils_file_is_private_key")]
pub fn utils_file_is_private_key(filename: &str) -> Option<bool> {
    assert_initialized_main_thread!();
    unsafe {
        let mut out_encrypted = std::mem::MaybeUninit::uninit();
        let ret = from_glib(ffi::nm_utils_file_is_private_key(filename.to_glib_none().0, out_encrypted.as_mut_ptr()));
        if ret { Some(from_glib(out_encrypted.assume_init())) } else { None }
    }
}

//#[doc(alias = "nm_utils_file_search_in_paths")]
//pub fn utils_file_search_in_paths<P: FnMut(&str) -> bool>(progname: &str, try_first: Option<&str>, paths: Option<&str>, file_test_flags: /*Ignored*/glib::FileTest, predicate: P) -> Result<glib::GString, glib::Error> {
//    unsafe { TODO: call ffi:nm_utils_file_search_in_paths() }
//}

//#[cfg(feature = "v1_8")]
//#[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
//#[doc(alias = "nm_utils_format_variant_attributes")]
//pub fn utils_format_variant_attributes(attributes: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 2, id: 226 }, attr_separator: glib::Char, key_value_separator: glib::Char) -> glib::GString {
//    unsafe { TODO: call ffi:nm_utils_format_variant_attributes() }
//}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
#[doc(alias = "nm_utils_get_timestamp_msec")]
pub fn utils_get_timestamp_msec() -> i64 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::nm_utils_get_timestamp_msec()
    }
}

//#[doc(alias = "nm_utils_hexstr2bin")]
//pub fn utils_hexstr2bin(hex: &str) -> /*Ignored*/glib::Bytes {
//    unsafe { TODO: call ffi:nm_utils_hexstr2bin() }
//}

//#[doc(alias = "nm_utils_hwaddr_atoba")]
//pub fn utils_hwaddr_atoba(asc: &str) -> /*Ignored*/glib::ByteArray {
//    unsafe { TODO: call ffi:nm_utils_hwaddr_atoba() }
//}

#[doc(alias = "nm_utils_hwaddr_aton")]
pub fn utils_hwaddr_aton(asc: &str, buffer: &[u8]) -> u8 {
    assert_initialized_main_thread!();
    let length = buffer.len() as _;
    unsafe {
        ffi::nm_utils_hwaddr_aton(asc.to_glib_none().0, buffer.to_glib_none().0 as glib::ffi::gpointer, length)
    }
}

#[doc(alias = "nm_utils_hwaddr_canonical")]
pub fn utils_hwaddr_canonical(asc: &str) -> glib::GString {
    assert_initialized_main_thread!();
    let length = asc.len() as _;
    unsafe {
        from_glib_full(ffi::nm_utils_hwaddr_canonical(asc.to_glib_none().0, length))
    }
}

#[doc(alias = "nm_utils_hwaddr_len")]
pub fn utils_hwaddr_len(type_: i32) -> usize {
    assert_initialized_main_thread!();
    unsafe {
        ffi::nm_utils_hwaddr_len(type_)
    }
}

//#[doc(alias = "nm_utils_hwaddr_matches")]
//pub fn utils_hwaddr_matches(hwaddr1: /*Unimplemented*/Option<Basic: Pointer>, hwaddr1_len: isize, hwaddr2: /*Unimplemented*/Option<Basic: Pointer>, hwaddr2_len: isize) -> bool {
//    unsafe { TODO: call ffi:nm_utils_hwaddr_matches() }
//}

#[doc(alias = "nm_utils_hwaddr_ntoa")]
pub fn utils_hwaddr_ntoa(addr: &[u8]) -> glib::GString {
    assert_initialized_main_thread!();
    let length = addr.len() as _;
    unsafe {
        from_glib_full(ffi::nm_utils_hwaddr_ntoa(addr.to_glib_none().0, length))
    }
}

#[doc(alias = "nm_utils_hwaddr_valid")]
pub fn utils_hwaddr_valid(asc: &str) -> bool {
    assert_initialized_main_thread!();
    let length = asc.len() as _;
    unsafe {
        from_glib(ffi::nm_utils_hwaddr_valid(asc.to_glib_none().0, length))
    }
}

#[cfg_attr(feature = "v1_6", deprecated = "Since 1.6")]
#[allow(deprecated)]
#[doc(alias = "nm_utils_iface_valid_name")]
pub fn utils_iface_valid_name(name: Option<&str>) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::nm_utils_iface_valid_name(name.to_glib_none().0))
    }
}

#[doc(alias = "nm_utils_inet4_ntop")]
pub fn utils_inet4_ntop(inaddr: u32, dst: &str) -> glib::GString {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::nm_utils_inet4_ntop(inaddr, dst.to_glib_none().0))
    }
}

//#[doc(alias = "nm_utils_inet6_ntop")]
//pub fn utils_inet6_ntop(in6addr: /*Unimplemented*/Option<Basic: Pointer>, dst: &str) -> glib::GString {
//    unsafe { TODO: call ffi:nm_utils_inet6_ntop() }
//}

//#[doc(alias = "nm_utils_ip4_addresses_from_variant")]
//pub fn utils_ip4_addresses_from_variant(value: /*Ignored*/&glib::Variant) -> (Vec<IPAddress>, Option<glib::GString>) {
//    unsafe { TODO: call ffi:nm_utils_ip4_addresses_from_variant() }
//}

//#[doc(alias = "nm_utils_ip4_addresses_to_variant")]
//pub fn utils_ip4_addresses_to_variant(addresses: &[&IPAddress], gateway: Option<&str>) -> /*Ignored*/glib::Variant {
//    unsafe { TODO: call ffi:nm_utils_ip4_addresses_to_variant() }
//}

//#[doc(alias = "nm_utils_ip4_dns_from_variant")]
//pub fn utils_ip4_dns_from_variant(value: /*Ignored*/&glib::Variant) -> glib::GString {
//    unsafe { TODO: call ffi:nm_utils_ip4_dns_from_variant() }
//}

//#[doc(alias = "nm_utils_ip4_dns_to_variant")]
//pub fn utils_ip4_dns_to_variant(dns: &str) -> /*Ignored*/glib::Variant {
//    unsafe { TODO: call ffi:nm_utils_ip4_dns_to_variant() }
//}

#[doc(alias = "nm_utils_ip4_get_default_prefix")]
pub fn utils_ip4_get_default_prefix(ip: u32) -> u32 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::nm_utils_ip4_get_default_prefix(ip)
    }
}

#[doc(alias = "nm_utils_ip4_netmask_to_prefix")]
pub fn utils_ip4_netmask_to_prefix(netmask: u32) -> u32 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::nm_utils_ip4_netmask_to_prefix(netmask)
    }
}

#[doc(alias = "nm_utils_ip4_prefix_to_netmask")]
pub fn utils_ip4_prefix_to_netmask(prefix: u32) -> u32 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::nm_utils_ip4_prefix_to_netmask(prefix)
    }
}

//#[doc(alias = "nm_utils_ip4_routes_from_variant")]
//pub fn utils_ip4_routes_from_variant(value: /*Ignored*/&glib::Variant) -> Vec<IPRoute> {
//    unsafe { TODO: call ffi:nm_utils_ip4_routes_from_variant() }
//}

//#[doc(alias = "nm_utils_ip4_routes_to_variant")]
//pub fn utils_ip4_routes_to_variant(routes: &[&IPRoute]) -> /*Ignored*/glib::Variant {
//    unsafe { TODO: call ffi:nm_utils_ip4_routes_to_variant() }
//}

//#[doc(alias = "nm_utils_ip6_addresses_from_variant")]
//pub fn utils_ip6_addresses_from_variant(value: /*Ignored*/&glib::Variant) -> (Vec<IPAddress>, Option<glib::GString>) {
//    unsafe { TODO: call ffi:nm_utils_ip6_addresses_from_variant() }
//}

//#[doc(alias = "nm_utils_ip6_addresses_to_variant")]
//pub fn utils_ip6_addresses_to_variant(addresses: &[&IPAddress], gateway: Option<&str>) -> /*Ignored*/glib::Variant {
//    unsafe { TODO: call ffi:nm_utils_ip6_addresses_to_variant() }
//}

//#[doc(alias = "nm_utils_ip6_dns_from_variant")]
//pub fn utils_ip6_dns_from_variant(value: /*Ignored*/&glib::Variant) -> glib::GString {
//    unsafe { TODO: call ffi:nm_utils_ip6_dns_from_variant() }
//}

//#[doc(alias = "nm_utils_ip6_dns_to_variant")]
//pub fn utils_ip6_dns_to_variant(dns: &str) -> /*Ignored*/glib::Variant {
//    unsafe { TODO: call ffi:nm_utils_ip6_dns_to_variant() }
//}

//#[doc(alias = "nm_utils_ip6_routes_from_variant")]
//pub fn utils_ip6_routes_from_variant(value: /*Ignored*/&glib::Variant) -> Vec<IPRoute> {
//    unsafe { TODO: call ffi:nm_utils_ip6_routes_from_variant() }
//}

//#[doc(alias = "nm_utils_ip6_routes_to_variant")]
//pub fn utils_ip6_routes_to_variant(routes: &[&IPRoute]) -> /*Ignored*/glib::Variant {
//    unsafe { TODO: call ffi:nm_utils_ip6_routes_to_variant() }
//}

//#[cfg(feature = "v1_42")]
//#[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
//#[doc(alias = "nm_utils_ip_addresses_from_variant")]
//pub fn utils_ip_addresses_from_variant(value: /*Ignored*/&glib::Variant, family: i32) -> Vec<IPAddress> {
//    unsafe { TODO: call ffi:nm_utils_ip_addresses_from_variant() }
//}

//#[cfg(feature = "v1_42")]
//#[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
//#[doc(alias = "nm_utils_ip_addresses_to_variant")]
//pub fn utils_ip_addresses_to_variant(addresses: &[&IPAddress]) -> /*Ignored*/glib::Variant {
//    unsafe { TODO: call ffi:nm_utils_ip_addresses_to_variant() }
//}

//#[cfg(feature = "v1_42")]
//#[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
//#[doc(alias = "nm_utils_ip_routes_from_variant")]
//pub fn utils_ip_routes_from_variant(value: /*Ignored*/&glib::Variant, family: i32) -> Vec<IPRoute> {
//    unsafe { TODO: call ffi:nm_utils_ip_routes_from_variant() }
//}

//#[cfg(feature = "v1_42")]
//#[cfg_attr(docsrs, doc(cfg(feature = "v1_42")))]
//#[doc(alias = "nm_utils_ip_routes_to_variant")]
//pub fn utils_ip_routes_to_variant(routes: &[&IPRoute]) -> /*Ignored*/glib::Variant {
//    unsafe { TODO: call ffi:nm_utils_ip_routes_to_variant() }
//}

#[doc(alias = "nm_utils_ipaddr_valid")]
pub fn utils_ipaddr_valid(family: i32, ip: &str) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::nm_utils_ipaddr_valid(family, ip.to_glib_none().0))
    }
}

#[doc(alias = "nm_utils_is_empty_ssid")]
pub fn utils_is_empty_ssid(ssid: &[u8]) -> bool {
    assert_initialized_main_thread!();
    let len = ssid.len() as _;
    unsafe {
        from_glib(ffi::nm_utils_is_empty_ssid(ssid.to_glib_none().0, len))
    }
}

#[cfg(feature = "v1_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
#[doc(alias = "nm_utils_is_json_object")]
pub fn utils_is_json_object(str: &str) -> Result<(), glib::Error> {
    assert_initialized_main_thread!();
    unsafe {
        let mut error = std::ptr::null_mut();
        let is_ok = ffi::nm_utils_is_json_object(str.to_glib_none().0, &mut error);
        debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
        if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
    }
}

#[cfg_attr(feature = "v1_32", deprecated = "Since 1.32")]
#[allow(deprecated)]
#[doc(alias = "nm_utils_is_uuid")]
pub fn utils_is_uuid(str: Option<&str>) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::nm_utils_is_uuid(str.to_glib_none().0))
    }
}

#[cfg(feature = "v1_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
#[doc(alias = "nm_utils_is_valid_iface_name")]
pub fn utils_is_valid_iface_name(name: Option<&str>) -> Result<(), glib::Error> {
    assert_initialized_main_thread!();
    unsafe {
        let mut error = std::ptr::null_mut();
        let is_ok = ffi::nm_utils_is_valid_iface_name(name.to_glib_none().0, &mut error);
        debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
        if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
    }
}

//#[cfg(feature = "v1_8")]
//#[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
//#[doc(alias = "nm_utils_parse_variant_attributes")]
//pub fn utils_parse_variant_attributes(string: &str, attr_separator: glib::Char, key_value_separator: glib::Char, ignore_unknown: bool, spec: &VariantAttributeSpec) -> Result</*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 2, id: 226 }, glib::Error> {
//    unsafe { TODO: call ffi:nm_utils_parse_variant_attributes() }
//}

#[cfg(feature = "v1_30")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_30")))]
#[doc(alias = "nm_utils_print")]
pub fn utils_print(output_mode: i32, msg: &str) {
    assert_initialized_main_thread!();
    unsafe {
        ffi::nm_utils_print(output_mode, msg.to_glib_none().0);
    }
}

#[doc(alias = "nm_utils_same_ssid")]
pub fn utils_same_ssid(ssid1: &[u8], ssid2: &[u8], ignore_trailing_null: bool) -> bool {
    assert_initialized_main_thread!();
    let len1 = ssid1.len() as _;
    let len2 = ssid2.len() as _;
    unsafe {
        from_glib(ffi::nm_utils_same_ssid(ssid1.to_glib_none().0, len1, ssid2.to_glib_none().0, len2, ignore_trailing_null.into_glib()))
    }
}

#[doc(alias = "nm_utils_security_valid")]
pub fn utils_security_valid(type_: UtilsSecurityType, wifi_caps: DeviceWifiCapabilities, have_ap: bool, adhoc: bool, ap_flags: 80211ApFlags, ap_wpa: 80211ApSecurityFlags, ap_rsn: 80211ApSecurityFlags) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::nm_utils_security_valid(type_.into_glib(), wifi_caps.into_glib(), have_ap.into_glib(), adhoc.into_glib(), ap_flags.into_glib(), ap_wpa.into_glib(), ap_rsn.into_glib()))
    }
}

#[cfg(feature = "v1_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
#[doc(alias = "nm_utils_sriov_vf_from_str")]
pub fn utils_sriov_vf_from_str(str: &str) -> Result<SriovVF, glib::Error> {
    assert_initialized_main_thread!();
    unsafe {
        let mut error = std::ptr::null_mut();
        let ret = ffi::nm_utils_sriov_vf_from_str(str.to_glib_none().0, &mut error);
        if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) }
    }
}

#[cfg(feature = "v1_14")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_14")))]
#[doc(alias = "nm_utils_sriov_vf_to_str")]
pub fn utils_sriov_vf_to_str(vf: &SriovVF, omit_index: bool) -> Result<glib::GString, glib::Error> {
    assert_initialized_main_thread!();
    unsafe {
        let mut error = std::ptr::null_mut();
        let ret = ffi::nm_utils_sriov_vf_to_str(vf.to_glib_none().0, omit_index.into_glib(), &mut error);
        if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) }
    }
}

#[doc(alias = "nm_utils_ssid_to_utf8")]
pub fn utils_ssid_to_utf8(ssid: &[u8]) -> glib::GString {
    assert_initialized_main_thread!();
    let len = ssid.len() as _;
    unsafe {
        from_glib_full(ffi::nm_utils_ssid_to_utf8(ssid.to_glib_none().0, len))
    }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
#[doc(alias = "nm_utils_tc_action_from_str")]
pub fn utils_tc_action_from_str(str: &str) -> Result<TCAction, glib::Error> {
    assert_initialized_main_thread!();
    unsafe {
        let mut error = std::ptr::null_mut();
        let ret = ffi::nm_utils_tc_action_from_str(str.to_glib_none().0, &mut error);
        if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) }
    }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
#[doc(alias = "nm_utils_tc_action_to_str")]
pub fn utils_tc_action_to_str(action: &TCAction) -> Result<glib::GString, glib::Error> {
    assert_initialized_main_thread!();
    unsafe {
        let mut error = std::ptr::null_mut();
        let ret = ffi::nm_utils_tc_action_to_str(action.to_glib_none().0, &mut error);
        if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) }
    }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
#[doc(alias = "nm_utils_tc_qdisc_from_str")]
pub fn utils_tc_qdisc_from_str(str: &str) -> Result<TCQdisc, glib::Error> {
    assert_initialized_main_thread!();
    unsafe {
        let mut error = std::ptr::null_mut();
        let ret = ffi::nm_utils_tc_qdisc_from_str(str.to_glib_none().0, &mut error);
        if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) }
    }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
#[doc(alias = "nm_utils_tc_qdisc_to_str")]
pub fn utils_tc_qdisc_to_str(qdisc: &TCQdisc) -> Result<glib::GString, glib::Error> {
    assert_initialized_main_thread!();
    unsafe {
        let mut error = std::ptr::null_mut();
        let ret = ffi::nm_utils_tc_qdisc_to_str(qdisc.to_glib_none().0, &mut error);
        if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) }
    }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
#[doc(alias = "nm_utils_tc_tfilter_from_str")]
pub fn utils_tc_tfilter_from_str(str: &str) -> Result<TCTfilter, glib::Error> {
    assert_initialized_main_thread!();
    unsafe {
        let mut error = std::ptr::null_mut();
        let ret = ffi::nm_utils_tc_tfilter_from_str(str.to_glib_none().0, &mut error);
        if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) }
    }
}

#[cfg(feature = "v1_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
#[doc(alias = "nm_utils_tc_tfilter_to_str")]
pub fn utils_tc_tfilter_to_str(tfilter: &TCTfilter) -> Result<glib::GString, glib::Error> {
    assert_initialized_main_thread!();
    unsafe {
        let mut error = std::ptr::null_mut();
        let ret = ffi::nm_utils_tc_tfilter_to_str(tfilter.to_glib_none().0, &mut error);
        if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) }
    }
}

#[doc(alias = "nm_utils_uuid_generate")]
pub fn utils_uuid_generate() -> glib::GString {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::nm_utils_uuid_generate())
    }
}

#[cfg(feature = "v1_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
#[doc(alias = "nm_utils_version")]
pub fn utils_version() -> u32 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::nm_utils_version()
    }
}

#[doc(alias = "nm_utils_wep_key_valid")]
pub fn utils_wep_key_valid(key: &str, wep_type: WepKeyType) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::nm_utils_wep_key_valid(key.to_glib_none().0, wep_type.into_glib()))
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
#[doc(alias = "nm_utils_wifi_2ghz_freqs")]
pub fn utils_wifi_2ghz_freqs() -> u32 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::nm_utils_wifi_2ghz_freqs()
    }
}

#[cfg(feature = "v1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
#[doc(alias = "nm_utils_wifi_5ghz_freqs")]
pub fn utils_wifi_5ghz_freqs() -> u32 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::nm_utils_wifi_5ghz_freqs()
    }
}

#[doc(alias = "nm_utils_wifi_channel_to_freq")]
pub fn utils_wifi_channel_to_freq(channel: u32, band: &str) -> u32 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::nm_utils_wifi_channel_to_freq(channel, band.to_glib_none().0)
    }
}

#[doc(alias = "nm_utils_wifi_find_next_channel")]
pub fn utils_wifi_find_next_channel(channel: u32, direction: i32, band: &str) -> u32 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::nm_utils_wifi_find_next_channel(channel, direction, band.to_glib_none().0)
    }
}

#[doc(alias = "nm_utils_wifi_freq_to_channel")]
pub fn utils_wifi_freq_to_channel(freq: u32) -> u32 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::nm_utils_wifi_freq_to_channel(freq)
    }
}

#[doc(alias = "nm_utils_wifi_is_channel_valid")]
pub fn utils_wifi_is_channel_valid(channel: u32, band: &str) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::nm_utils_wifi_is_channel_valid(channel, band.to_glib_none().0))
    }
}

#[doc(alias = "nm_utils_wifi_strength_bars")]
pub fn utils_wifi_strength_bars(strength: u8) -> glib::GString {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::nm_utils_wifi_strength_bars(strength))
    }
}

#[doc(alias = "nm_utils_wpa_psk_valid")]
pub fn utils_wpa_psk_valid(psk: &str) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::nm_utils_wpa_psk_valid(psk.to_glib_none().0))
    }
}
