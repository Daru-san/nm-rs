// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir
// from gtk-girs (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use crate::{ffi,VpnPluginFailure,VpnServiceState};
use glib::{object::ObjectType as _,prelude::*,signal::{connect_raw, SignalHandlerId},translate::*};
use std::{boxed::Box as Box_};

#[cfg(feature = "gio_v2_22")]
#[cfg_attr(docsrs, doc(cfg(feature = "gio_v2_22")))]
glib::wrapper! {
    #[doc(alias = "NMVpnServicePlugin")]
    pub struct VpnServicePlugin(Object<ffi::NMVpnServicePlugin, ffi::NMVpnServicePluginClass>) @implements gio::Initable;

    match fn {
        type_ => || ffi::nm_vpn_service_plugin_get_type(),
    }
}

#[cfg(not(any(feature = "gio_v2_22")))]
glib::wrapper! {
    #[doc(alias = "NMVpnServicePlugin")]
    pub struct VpnServicePlugin(Object<ffi::NMVpnServicePlugin, ffi::NMVpnServicePluginClass>);

    match fn {
        type_ => || ffi::nm_vpn_service_plugin_get_type(),
    }
}

impl VpnServicePlugin {
        pub const NONE: Option<&'static VpnServicePlugin> = None;
    

    //#[doc(alias = "nm_vpn_service_plugin_get_secret_flags")]
    //#[doc(alias = "get_secret_flags")]
    //pub fn secret_flags(data: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 25 }/TypeId { ns_id: 0, id: 25 }, secret_name: &str) -> Option<SettingSecretFlags> {
    //    unsafe { TODO: call ffi:nm_vpn_service_plugin_get_secret_flags() }
    //}

    //#[doc(alias = "nm_vpn_service_plugin_read_vpn_details")]
    //pub fn read_vpn_details(fd: i32, out_data: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 25 }/TypeId { ns_id: 0, id: 25 }, out_secrets: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 25 }/TypeId { ns_id: 0, id: 25 }) -> bool {
    //    unsafe { TODO: call ffi:nm_vpn_service_plugin_read_vpn_details() }
    //}
}

pub trait VpnServicePluginExt: IsA<VpnServicePlugin> + 'static {
    #[doc(alias = "nm_vpn_service_plugin_disconnect")]
    fn disconnect(&self) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::nm_vpn_service_plugin_disconnect(self.as_ref().to_glib_none().0, &mut error);
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
        }
    }

    #[doc(alias = "nm_vpn_service_plugin_failure")]
    fn failure(&self, reason: VpnPluginFailure) {
        unsafe {
            ffi::nm_vpn_service_plugin_failure(self.as_ref().to_glib_none().0, reason.into_glib());
        }
    }

    //#[doc(alias = "nm_vpn_service_plugin_get_connection")]
    //#[doc(alias = "get_connection")]
    //fn connection(&self) -> /*Ignored*/gio::DBusConnection {
    //    unsafe { TODO: call ffi:nm_vpn_service_plugin_get_connection() }
    //}

    #[doc(alias = "nm_vpn_service_plugin_secrets_required")]
    fn secrets_required(&self, message: &str, hints: &str) {
        unsafe {
            ffi::nm_vpn_service_plugin_secrets_required(self.as_ref().to_glib_none().0, message.to_glib_none().0, hints.to_glib_none().0);
        }
    }

    //#[doc(alias = "nm_vpn_service_plugin_set_config")]
    //fn set_config(&self, config: /*Ignored*/&glib::Variant) {
    //    unsafe { TODO: call ffi:nm_vpn_service_plugin_set_config() }
    //}

    //#[doc(alias = "nm_vpn_service_plugin_set_ip4_config")]
    //fn set_ip4_config(&self, ip4_config: /*Ignored*/&glib::Variant) {
    //    unsafe { TODO: call ffi:nm_vpn_service_plugin_set_ip4_config() }
    //}

    //#[doc(alias = "nm_vpn_service_plugin_set_ip6_config")]
    //fn set_ip6_config(&self, ip6_config: /*Ignored*/&glib::Variant) {
    //    unsafe { TODO: call ffi:nm_vpn_service_plugin_set_ip6_config() }
    //}

    #[doc(alias = "nm_vpn_service_plugin_set_login_banner")]
    fn set_login_banner(&self, banner: &str) {
        unsafe {
            ffi::nm_vpn_service_plugin_set_login_banner(self.as_ref().to_glib_none().0, banner.to_glib_none().0);
        }
    }

    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    #[doc(alias = "nm_vpn_service_plugin_shutdown")]
    fn shutdown(&self) {
        unsafe {
            ffi::nm_vpn_service_plugin_shutdown(self.as_ref().to_glib_none().0);
        }
    }

    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    #[doc(alias = "service-name")]
    fn service_name(&self) -> Option<glib::GString> {
        ObjectExt::property(self.as_ref(), "service-name")
    }

    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    fn state(&self) -> VpnServiceState {
        ObjectExt::property(self.as_ref(), "state")
    }

    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    fn set_state(&self, state: VpnServiceState) {
        ObjectExt::set_property(self.as_ref(),"state", state)
    }

    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    #[doc(alias = "watch-peer")]
    fn is_watch_peer(&self) -> bool {
        ObjectExt::property(self.as_ref(), "watch-peer")
    }

    //#[doc(alias = "config")]
    //fn connect_config<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Ignored object: GLib.Variant
    //}

    #[doc(alias = "failure")]
    fn connect_failure<F: Fn(&Self, u32) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn failure_trampoline<P: IsA<VpnServicePlugin>, F: Fn(&P, u32) + 'static>(this: *mut ffi::NMVpnServicePlugin, object: std::ffi::c_uint, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(VpnServicePlugin::from_glib_borrow(this).unsafe_cast_ref(), object)
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"failure".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(failure_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    //#[doc(alias = "ip4-config")]
    //fn connect_ip4_config<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Ignored object: GLib.Variant
    //}

    //#[doc(alias = "ip6-config")]
    //fn connect_ip6_config<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Ignored object: GLib.Variant
    //}

    #[doc(alias = "login-banner")]
    fn connect_login_banner<F: Fn(&Self, &str) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn login_banner_trampoline<P: IsA<VpnServicePlugin>, F: Fn(&P, &str) + 'static>(this: *mut ffi::NMVpnServicePlugin, object: *mut std::ffi::c_char, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(VpnServicePlugin::from_glib_borrow(this).unsafe_cast_ref(), &glib::GString::from_glib_borrow(object))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"login-banner".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(login_banner_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "quit")]
    fn connect_quit<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn quit_trampoline<P: IsA<VpnServicePlugin>, F: Fn(&P) + 'static>(this: *mut ffi::NMVpnServicePlugin, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(VpnServicePlugin::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"quit".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(quit_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    //#[doc(alias = "secrets-required")]
    //fn connect_secrets_required<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Empty ctype p0: *.CArray TypeId { ns_id: 0, id: 28 }
    //}

    #[doc(alias = "state-changed")]
    fn connect_state_changed<F: Fn(&Self, u32) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn state_changed_trampoline<P: IsA<VpnServicePlugin>, F: Fn(&P, u32) + 'static>(this: *mut ffi::NMVpnServicePlugin, object: std::ffi::c_uint, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(VpnServicePlugin::from_glib_borrow(this).unsafe_cast_ref(), object)
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"state-changed".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(state_changed_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    #[doc(alias = "state")]
    fn connect_state_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_state_trampoline<P: IsA<VpnServicePlugin>, F: Fn(&P) + 'static>(this: *mut ffi::NMVpnServicePlugin, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(VpnServicePlugin::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::state".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_state_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }
}

impl<O: IsA<VpnServicePlugin>> VpnServicePluginExt for O {}
