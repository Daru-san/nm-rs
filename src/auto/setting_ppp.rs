// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir
// from gtk-girs (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use crate::{ffi,Setting};
use glib::{prelude::*,signal::{connect_raw, SignalHandlerId},translate::*};
use std::{boxed::Box as Box_};

glib::wrapper! {
    /// Point-to-Point Protocol Settings
    ///
    /// ## Properties
    ///
    ///
    /// #### `baud`
    ///  If non-zero, instruct pppd to set the serial port to the specified
    /// baudrate.  This value should normally be left as 0 to automatically
    /// choose the speed.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `crtscts`
    ///  If [`true`], specify that pppd should set the serial port to use hardware
    /// flow control with RTS and CTS signals.  This value should normally be set
    /// to [`false`].
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `lcp-echo-failure`
    ///  If non-zero, instruct pppd to presume the connection to the peer has
    /// failed if the specified number of LCP echo-requests go unanswered by the
    /// peer.  The "lcp-echo-interval" property must also be set to a non-zero
    /// value if this property is used.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `lcp-echo-interval`
    ///  If non-zero, instruct pppd to send an LCP echo-request frame to the peer
    /// every n seconds (where n is the specified value).  Note that some PPP
    /// peers will respond to echo requests and some will not, and it is not
    /// possible to autodetect this.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `mppe-stateful`
    ///  If [`true`], stateful MPPE is used.  See pppd documentation for more
    /// information on stateful MPPE.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `mru`
    ///  If non-zero, instruct pppd to request that the peer send packets no
    /// larger than the specified size.  If non-zero, the MRU should be between
    /// 128 and 16384.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `mtu`
    ///  If non-zero, instruct pppd to send packets no larger than the specified
    /// size.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `no-vj-comp`
    ///  If [`true`], Van Jacobsen TCP header compression will not be requested.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `noauth`
    ///  If [`true`], do not require the other side (usually the PPP server) to
    /// authenticate itself to the client.  If [`false`], require authentication
    /// from the remote side.  In almost all cases, this should be [`true`].
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `nobsdcomp`
    ///  If [`true`], BSD compression will not be requested.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `nodeflate`
    ///  If [`true`], "deflate" compression will not be requested.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `refuse-chap`
    ///  If [`true`], the CHAP authentication method will not be used.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `refuse-eap`
    ///  If [`true`], the EAP authentication method will not be used.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `refuse-mschap`
    ///  If [`true`], the MSCHAP authentication method will not be used.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `refuse-mschapv2`
    ///  If [`true`], the MSCHAPv2 authentication method will not be used.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `refuse-pap`
    ///  If [`true`], the PAP authentication method will not be used.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `require-mppe`
    ///  If [`true`], MPPE (Microsoft Point-to-Point Encryption) will be required for
    /// the PPP session.  If either 64-bit or 128-bit MPPE is not available the
    /// session will fail.  Note that MPPE is not used on mobile broadband
    /// connections.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `require-mppe-128`
    ///  If [`true`], 128-bit MPPE (Microsoft Point-to-Point Encryption) will be
    /// required for the PPP session, and the "require-mppe" property must also
    /// be set to [`true`].  If 128-bit MPPE is not available the session will fail.
    ///
    /// Readable | Writeable
    /// <details><summary><h4>Setting</h4></summary>
    ///
    ///
    /// #### `name`
    ///  The setting's name, which uniquely identifies the setting within the
    /// connection.  Each setting type has a name unique to that type, for
    /// example "ppp" or "802-11-wireless" or "802-3-ethernet".
    ///
    /// Readable
    /// </details>
    ///
    /// # Implements
    ///
    /// [`SettingExt`][trait@crate::prelude::SettingExt]
    #[doc(alias = "NMSettingPpp")]
    pub struct SettingPpp(Object<ffi::NMSettingPpp, ffi::NMSettingPppClass>) @extends Setting;

    match fn {
        type_ => || ffi::nm_setting_ppp_get_type(),
    }
}

impl SettingPpp {
    /// Creates a new #NMSettingPpp object with default values.
    ///
    /// # Returns
    ///
    /// the new empty #NMSettingPpp object
    #[doc(alias = "nm_setting_ppp_new")]
    pub fn new() -> SettingPpp {
        assert_initialized_main_thread!();
        unsafe {
            Setting::from_glib_full(ffi::nm_setting_ppp_new()).unsafe_cast()
        }
    }

            // rustdoc-stripper-ignore-next
            /// Creates a new builder-pattern struct instance to construct [`SettingPpp`] objects.
            ///
            /// This method returns an instance of [`SettingPppBuilder`](crate::builders::SettingPppBuilder) which can be used to create [`SettingPpp`] objects.
            pub fn builder() -> SettingPppBuilder {
                SettingPppBuilder::new()
            }
        

    ///
    /// # Returns
    ///
    /// the #NMSettingPpp:baud property of the setting
    #[doc(alias = "nm_setting_ppp_get_baud")]
    #[doc(alias = "get_baud")]
    pub fn baud(&self) -> u32 {
        unsafe {
            ffi::nm_setting_ppp_get_baud(self.to_glib_none().0)
        }
    }

    ///
    /// # Returns
    ///
    /// the #NMSettingPpp:crtscts property of the setting
    #[doc(alias = "nm_setting_ppp_get_crtscts")]
    #[doc(alias = "get_crtscts")]
    #[doc(alias = "crtscts")]
    pub fn is_crtscts(&self) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_ppp_get_crtscts(self.to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// the #NMSettingPpp:lcp-echo-failure property of the setting
    #[doc(alias = "nm_setting_ppp_get_lcp_echo_failure")]
    #[doc(alias = "get_lcp_echo_failure")]
    #[doc(alias = "lcp-echo-failure")]
    pub fn lcp_echo_failure(&self) -> u32 {
        unsafe {
            ffi::nm_setting_ppp_get_lcp_echo_failure(self.to_glib_none().0)
        }
    }

    ///
    /// # Returns
    ///
    /// the #NMSettingPpp:lcp-echo-interval property of the setting
    #[doc(alias = "nm_setting_ppp_get_lcp_echo_interval")]
    #[doc(alias = "get_lcp_echo_interval")]
    #[doc(alias = "lcp-echo-interval")]
    pub fn lcp_echo_interval(&self) -> u32 {
        unsafe {
            ffi::nm_setting_ppp_get_lcp_echo_interval(self.to_glib_none().0)
        }
    }

    ///
    /// # Returns
    ///
    /// the #NMSettingPpp:mppe-stateful property of the setting
    #[doc(alias = "nm_setting_ppp_get_mppe_stateful")]
    #[doc(alias = "get_mppe_stateful")]
    #[doc(alias = "mppe-stateful")]
    pub fn is_mppe_stateful(&self) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_ppp_get_mppe_stateful(self.to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// the #NMSettingPpp:mru property of the setting
    #[doc(alias = "nm_setting_ppp_get_mru")]
    #[doc(alias = "get_mru")]
    pub fn mru(&self) -> u32 {
        unsafe {
            ffi::nm_setting_ppp_get_mru(self.to_glib_none().0)
        }
    }

    ///
    /// # Returns
    ///
    /// the #NMSettingPpp:mtu property of the setting
    #[doc(alias = "nm_setting_ppp_get_mtu")]
    #[doc(alias = "get_mtu")]
    pub fn mtu(&self) -> u32 {
        unsafe {
            ffi::nm_setting_ppp_get_mtu(self.to_glib_none().0)
        }
    }

    ///
    /// # Returns
    ///
    /// the #NMSettingPpp:no-vj-comp property of the setting
    #[doc(alias = "nm_setting_ppp_get_no_vj_comp")]
    #[doc(alias = "get_no_vj_comp")]
    #[doc(alias = "no-vj-comp")]
    pub fn is_no_vj_comp(&self) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_ppp_get_no_vj_comp(self.to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// the #NMSettingPpp:noauth property of the setting
    #[doc(alias = "nm_setting_ppp_get_noauth")]
    #[doc(alias = "get_noauth")]
    #[doc(alias = "noauth")]
    pub fn is_noauth(&self) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_ppp_get_noauth(self.to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// the #NMSettingPpp:nobsdcomp property of the setting
    #[doc(alias = "nm_setting_ppp_get_nobsdcomp")]
    #[doc(alias = "get_nobsdcomp")]
    #[doc(alias = "nobsdcomp")]
    pub fn is_nobsdcomp(&self) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_ppp_get_nobsdcomp(self.to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// the #NMSettingPpp:nodeflate property of the setting
    #[doc(alias = "nm_setting_ppp_get_nodeflate")]
    #[doc(alias = "get_nodeflate")]
    #[doc(alias = "nodeflate")]
    pub fn is_nodeflate(&self) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_ppp_get_nodeflate(self.to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// the #NMSettingPpp:refuse-chap property of the setting
    #[doc(alias = "nm_setting_ppp_get_refuse_chap")]
    #[doc(alias = "get_refuse_chap")]
    #[doc(alias = "refuse-chap")]
    pub fn is_refuse_chap(&self) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_ppp_get_refuse_chap(self.to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// the #NMSettingPpp:refuse-eap property of the setting
    #[doc(alias = "nm_setting_ppp_get_refuse_eap")]
    #[doc(alias = "get_refuse_eap")]
    #[doc(alias = "refuse-eap")]
    pub fn is_refuse_eap(&self) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_ppp_get_refuse_eap(self.to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// the #NMSettingPpp:refuse-mschap property of the setting
    #[doc(alias = "nm_setting_ppp_get_refuse_mschap")]
    #[doc(alias = "get_refuse_mschap")]
    #[doc(alias = "refuse-mschap")]
    pub fn is_refuse_mschap(&self) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_ppp_get_refuse_mschap(self.to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// the #NMSettingPpp:refuse-mschapv2 property of the setting
    #[doc(alias = "nm_setting_ppp_get_refuse_mschapv2")]
    #[doc(alias = "get_refuse_mschapv2")]
    #[doc(alias = "refuse-mschapv2")]
    pub fn is_refuse_mschapv2(&self) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_ppp_get_refuse_mschapv2(self.to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// the #NMSettingPpp:refuse-pap property of the setting
    #[doc(alias = "nm_setting_ppp_get_refuse_pap")]
    #[doc(alias = "get_refuse_pap")]
    #[doc(alias = "refuse-pap")]
    pub fn is_refuse_pap(&self) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_ppp_get_refuse_pap(self.to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// the #NMSettingPpp:require-mppe property of the setting
    #[doc(alias = "nm_setting_ppp_get_require_mppe")]
    #[doc(alias = "get_require_mppe")]
    #[doc(alias = "require-mppe")]
    pub fn requires_mppe(&self) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_ppp_get_require_mppe(self.to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// the #NMSettingPpp:require-mppe-128 property of the setting
    #[doc(alias = "nm_setting_ppp_get_require_mppe_128")]
    #[doc(alias = "get_require_mppe_128")]
    #[doc(alias = "require-mppe-128")]
    pub fn requires_mppe_128(&self) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_ppp_get_require_mppe_128(self.to_glib_none().0))
        }
    }

    /// If non-zero, instruct pppd to set the serial port to the specified
    /// baudrate.  This value should normally be left as 0 to automatically
    /// choose the speed.
    pub fn set_baud(&self, baud: u32) {
        ObjectExt::set_property(self,"baud", baud)
    }

    /// If [`true`], specify that pppd should set the serial port to use hardware
    /// flow control with RTS and CTS signals.  This value should normally be set
    /// to [`false`].
    pub fn set_crtscts(&self, crtscts: bool) {
        ObjectExt::set_property(self,"crtscts", crtscts)
    }

    /// If non-zero, instruct pppd to presume the connection to the peer has
    /// failed if the specified number of LCP echo-requests go unanswered by the
    /// peer.  The "lcp-echo-interval" property must also be set to a non-zero
    /// value if this property is used.
    #[doc(alias = "lcp-echo-failure")]
    pub fn set_lcp_echo_failure(&self, lcp_echo_failure: u32) {
        ObjectExt::set_property(self,"lcp-echo-failure", lcp_echo_failure)
    }

    /// If non-zero, instruct pppd to send an LCP echo-request frame to the peer
    /// every n seconds (where n is the specified value).  Note that some PPP
    /// peers will respond to echo requests and some will not, and it is not
    /// possible to autodetect this.
    #[doc(alias = "lcp-echo-interval")]
    pub fn set_lcp_echo_interval(&self, lcp_echo_interval: u32) {
        ObjectExt::set_property(self,"lcp-echo-interval", lcp_echo_interval)
    }

    /// If [`true`], stateful MPPE is used.  See pppd documentation for more
    /// information on stateful MPPE.
    #[doc(alias = "mppe-stateful")]
    pub fn set_mppe_stateful(&self, mppe_stateful: bool) {
        ObjectExt::set_property(self,"mppe-stateful", mppe_stateful)
    }

    /// If non-zero, instruct pppd to request that the peer send packets no
    /// larger than the specified size.  If non-zero, the MRU should be between
    /// 128 and 16384.
    pub fn set_mru(&self, mru: u32) {
        ObjectExt::set_property(self,"mru", mru)
    }

    /// If non-zero, instruct pppd to send packets no larger than the specified
    /// size.
    pub fn set_mtu(&self, mtu: u32) {
        ObjectExt::set_property(self,"mtu", mtu)
    }

    /// If [`true`], Van Jacobsen TCP header compression will not be requested.
    #[doc(alias = "no-vj-comp")]
    pub fn set_no_vj_comp(&self, no_vj_comp: bool) {
        ObjectExt::set_property(self,"no-vj-comp", no_vj_comp)
    }

    /// If [`true`], do not require the other side (usually the PPP server) to
    /// authenticate itself to the client.  If [`false`], require authentication
    /// from the remote side.  In almost all cases, this should be [`true`].
    pub fn set_noauth(&self, noauth: bool) {
        ObjectExt::set_property(self,"noauth", noauth)
    }

    /// If [`true`], BSD compression will not be requested.
    pub fn set_nobsdcomp(&self, nobsdcomp: bool) {
        ObjectExt::set_property(self,"nobsdcomp", nobsdcomp)
    }

    /// If [`true`], "deflate" compression will not be requested.
    pub fn set_nodeflate(&self, nodeflate: bool) {
        ObjectExt::set_property(self,"nodeflate", nodeflate)
    }

    /// If [`true`], the CHAP authentication method will not be used.
    #[doc(alias = "refuse-chap")]
    pub fn set_refuse_chap(&self, refuse_chap: bool) {
        ObjectExt::set_property(self,"refuse-chap", refuse_chap)
    }

    /// If [`true`], the EAP authentication method will not be used.
    #[doc(alias = "refuse-eap")]
    pub fn set_refuse_eap(&self, refuse_eap: bool) {
        ObjectExt::set_property(self,"refuse-eap", refuse_eap)
    }

    /// If [`true`], the MSCHAP authentication method will not be used.
    #[doc(alias = "refuse-mschap")]
    pub fn set_refuse_mschap(&self, refuse_mschap: bool) {
        ObjectExt::set_property(self,"refuse-mschap", refuse_mschap)
    }

    /// If [`true`], the MSCHAPv2 authentication method will not be used.
    #[doc(alias = "refuse-mschapv2")]
    pub fn set_refuse_mschapv2(&self, refuse_mschapv2: bool) {
        ObjectExt::set_property(self,"refuse-mschapv2", refuse_mschapv2)
    }

    /// If [`true`], the PAP authentication method will not be used.
    #[doc(alias = "refuse-pap")]
    pub fn set_refuse_pap(&self, refuse_pap: bool) {
        ObjectExt::set_property(self,"refuse-pap", refuse_pap)
    }

    /// If [`true`], MPPE (Microsoft Point-to-Point Encryption) will be required for
    /// the PPP session.  If either 64-bit or 128-bit MPPE is not available the
    /// session will fail.  Note that MPPE is not used on mobile broadband
    /// connections.
    #[doc(alias = "require-mppe")]
    pub fn set_require_mppe(&self, require_mppe: bool) {
        ObjectExt::set_property(self,"require-mppe", require_mppe)
    }

    /// If [`true`], 128-bit MPPE (Microsoft Point-to-Point Encryption) will be
    /// required for the PPP session, and the "require-mppe" property must also
    /// be set to [`true`].  If 128-bit MPPE is not available the session will fail.
    #[doc(alias = "require-mppe-128")]
    pub fn set_require_mppe_128(&self, require_mppe_128: bool) {
        ObjectExt::set_property(self,"require-mppe-128", require_mppe_128)
    }

    #[doc(alias = "baud")]
    pub fn connect_baud_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_baud_trampoline<F: Fn(&SettingPpp) + 'static>(this: *mut ffi::NMSettingPpp, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::baud".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_baud_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "crtscts")]
    pub fn connect_crtscts_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_crtscts_trampoline<F: Fn(&SettingPpp) + 'static>(this: *mut ffi::NMSettingPpp, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::crtscts".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_crtscts_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "lcp-echo-failure")]
    pub fn connect_lcp_echo_failure_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_lcp_echo_failure_trampoline<F: Fn(&SettingPpp) + 'static>(this: *mut ffi::NMSettingPpp, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::lcp-echo-failure".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_lcp_echo_failure_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "lcp-echo-interval")]
    pub fn connect_lcp_echo_interval_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_lcp_echo_interval_trampoline<F: Fn(&SettingPpp) + 'static>(this: *mut ffi::NMSettingPpp, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::lcp-echo-interval".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_lcp_echo_interval_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "mppe-stateful")]
    pub fn connect_mppe_stateful_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_mppe_stateful_trampoline<F: Fn(&SettingPpp) + 'static>(this: *mut ffi::NMSettingPpp, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::mppe-stateful".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_mppe_stateful_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "mru")]
    pub fn connect_mru_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_mru_trampoline<F: Fn(&SettingPpp) + 'static>(this: *mut ffi::NMSettingPpp, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::mru".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_mru_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "mtu")]
    pub fn connect_mtu_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_mtu_trampoline<F: Fn(&SettingPpp) + 'static>(this: *mut ffi::NMSettingPpp, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::mtu".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_mtu_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "no-vj-comp")]
    pub fn connect_no_vj_comp_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_no_vj_comp_trampoline<F: Fn(&SettingPpp) + 'static>(this: *mut ffi::NMSettingPpp, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::no-vj-comp".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_no_vj_comp_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "noauth")]
    pub fn connect_noauth_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_noauth_trampoline<F: Fn(&SettingPpp) + 'static>(this: *mut ffi::NMSettingPpp, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::noauth".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_noauth_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "nobsdcomp")]
    pub fn connect_nobsdcomp_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_nobsdcomp_trampoline<F: Fn(&SettingPpp) + 'static>(this: *mut ffi::NMSettingPpp, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::nobsdcomp".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_nobsdcomp_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "nodeflate")]
    pub fn connect_nodeflate_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_nodeflate_trampoline<F: Fn(&SettingPpp) + 'static>(this: *mut ffi::NMSettingPpp, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::nodeflate".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_nodeflate_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "refuse-chap")]
    pub fn connect_refuse_chap_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_refuse_chap_trampoline<F: Fn(&SettingPpp) + 'static>(this: *mut ffi::NMSettingPpp, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::refuse-chap".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_refuse_chap_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "refuse-eap")]
    pub fn connect_refuse_eap_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_refuse_eap_trampoline<F: Fn(&SettingPpp) + 'static>(this: *mut ffi::NMSettingPpp, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::refuse-eap".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_refuse_eap_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "refuse-mschap")]
    pub fn connect_refuse_mschap_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_refuse_mschap_trampoline<F: Fn(&SettingPpp) + 'static>(this: *mut ffi::NMSettingPpp, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::refuse-mschap".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_refuse_mschap_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "refuse-mschapv2")]
    pub fn connect_refuse_mschapv2_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_refuse_mschapv2_trampoline<F: Fn(&SettingPpp) + 'static>(this: *mut ffi::NMSettingPpp, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::refuse-mschapv2".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_refuse_mschapv2_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "refuse-pap")]
    pub fn connect_refuse_pap_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_refuse_pap_trampoline<F: Fn(&SettingPpp) + 'static>(this: *mut ffi::NMSettingPpp, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::refuse-pap".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_refuse_pap_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "require-mppe")]
    pub fn connect_require_mppe_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_require_mppe_trampoline<F: Fn(&SettingPpp) + 'static>(this: *mut ffi::NMSettingPpp, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::require-mppe".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_require_mppe_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "require-mppe-128")]
    pub fn connect_require_mppe_128_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_require_mppe_128_trampoline<F: Fn(&SettingPpp) + 'static>(this: *mut ffi::NMSettingPpp, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::require-mppe-128".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_require_mppe_128_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }
}

impl Default for SettingPpp {
                     fn default() -> Self {
                         Self::new()
                     }
                 }

// rustdoc-stripper-ignore-next
        /// A [builder-pattern] type to construct [`SettingPpp`] objects.
        ///
        /// [builder-pattern]: https://doc.rust-lang.org/1.0.0/style/ownership/builders.html
#[must_use = "The builder must be built to be used"]
pub struct SettingPppBuilder {
            builder: glib::object::ObjectBuilder<'static, SettingPpp>,
        }

        impl SettingPppBuilder {
        fn new() -> Self {
            Self { builder: glib::object::Object::builder() }
        }

                            /// If non-zero, instruct pppd to set the serial port to the specified
                            /// baudrate.  This value should normally be left as 0 to automatically
                            /// choose the speed.
                            pub fn baud(self, baud: u32) -> Self {
                            Self { builder: self.builder.property("baud", baud), }
                        }

                            /// If [`true`], specify that pppd should set the serial port to use hardware
                            /// flow control with RTS and CTS signals.  This value should normally be set
                            /// to [`false`].
                            pub fn crtscts(self, crtscts: bool) -> Self {
                            Self { builder: self.builder.property("crtscts", crtscts), }
                        }

                            /// If non-zero, instruct pppd to presume the connection to the peer has
                            /// failed if the specified number of LCP echo-requests go unanswered by the
                            /// peer.  The "lcp-echo-interval" property must also be set to a non-zero
                            /// value if this property is used.
                            pub fn lcp_echo_failure(self, lcp_echo_failure: u32) -> Self {
                            Self { builder: self.builder.property("lcp-echo-failure", lcp_echo_failure), }
                        }

                            /// If non-zero, instruct pppd to send an LCP echo-request frame to the peer
                            /// every n seconds (where n is the specified value).  Note that some PPP
                            /// peers will respond to echo requests and some will not, and it is not
                            /// possible to autodetect this.
                            pub fn lcp_echo_interval(self, lcp_echo_interval: u32) -> Self {
                            Self { builder: self.builder.property("lcp-echo-interval", lcp_echo_interval), }
                        }

                            /// If [`true`], stateful MPPE is used.  See pppd documentation for more
                            /// information on stateful MPPE.
                            pub fn mppe_stateful(self, mppe_stateful: bool) -> Self {
                            Self { builder: self.builder.property("mppe-stateful", mppe_stateful), }
                        }

                            /// If non-zero, instruct pppd to request that the peer send packets no
                            /// larger than the specified size.  If non-zero, the MRU should be between
                            /// 128 and 16384.
                            pub fn mru(self, mru: u32) -> Self {
                            Self { builder: self.builder.property("mru", mru), }
                        }

                            /// If non-zero, instruct pppd to send packets no larger than the specified
                            /// size.
                            pub fn mtu(self, mtu: u32) -> Self {
                            Self { builder: self.builder.property("mtu", mtu), }
                        }

                            /// If [`true`], Van Jacobsen TCP header compression will not be requested.
                            pub fn no_vj_comp(self, no_vj_comp: bool) -> Self {
                            Self { builder: self.builder.property("no-vj-comp", no_vj_comp), }
                        }

                            /// If [`true`], do not require the other side (usually the PPP server) to
                            /// authenticate itself to the client.  If [`false`], require authentication
                            /// from the remote side.  In almost all cases, this should be [`true`].
                            pub fn noauth(self, noauth: bool) -> Self {
                            Self { builder: self.builder.property("noauth", noauth), }
                        }

                            /// If [`true`], BSD compression will not be requested.
                            pub fn nobsdcomp(self, nobsdcomp: bool) -> Self {
                            Self { builder: self.builder.property("nobsdcomp", nobsdcomp), }
                        }

                            /// If [`true`], "deflate" compression will not be requested.
                            pub fn nodeflate(self, nodeflate: bool) -> Self {
                            Self { builder: self.builder.property("nodeflate", nodeflate), }
                        }

                            /// If [`true`], the CHAP authentication method will not be used.
                            pub fn refuse_chap(self, refuse_chap: bool) -> Self {
                            Self { builder: self.builder.property("refuse-chap", refuse_chap), }
                        }

                            /// If [`true`], the EAP authentication method will not be used.
                            pub fn refuse_eap(self, refuse_eap: bool) -> Self {
                            Self { builder: self.builder.property("refuse-eap", refuse_eap), }
                        }

                            /// If [`true`], the MSCHAP authentication method will not be used.
                            pub fn refuse_mschap(self, refuse_mschap: bool) -> Self {
                            Self { builder: self.builder.property("refuse-mschap", refuse_mschap), }
                        }

                            /// If [`true`], the MSCHAPv2 authentication method will not be used.
                            pub fn refuse_mschapv2(self, refuse_mschapv2: bool) -> Self {
                            Self { builder: self.builder.property("refuse-mschapv2", refuse_mschapv2), }
                        }

                            /// If [`true`], the PAP authentication method will not be used.
                            pub fn refuse_pap(self, refuse_pap: bool) -> Self {
                            Self { builder: self.builder.property("refuse-pap", refuse_pap), }
                        }

                            /// If [`true`], MPPE (Microsoft Point-to-Point Encryption) will be required for
                            /// the PPP session.  If either 64-bit or 128-bit MPPE is not available the
                            /// session will fail.  Note that MPPE is not used on mobile broadband
                            /// connections.
                            pub fn require_mppe(self, require_mppe: bool) -> Self {
                            Self { builder: self.builder.property("require-mppe", require_mppe), }
                        }

                            /// If [`true`], 128-bit MPPE (Microsoft Point-to-Point Encryption) will be
                            /// required for the PPP session, and the "require-mppe" property must also
                            /// be set to [`true`].  If 128-bit MPPE is not available the session will fail.
                            pub fn require_mppe_128(self, require_mppe_128: bool) -> Self {
                            Self { builder: self.builder.property("require-mppe-128", require_mppe_128), }
                        }

    // rustdoc-stripper-ignore-next
    /// Build the [`SettingPpp`].
    #[must_use = "Building the object from the builder is usually expensive and is not expected to have side effects"]
    pub fn build(self) -> SettingPpp {
assert_initialized_main_thread!();
    self.builder.build() }
}
