// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir
// from gtk-girs (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use crate::{ffi,Setting};
use glib::{prelude::*,signal::{connect_raw, SignalHandlerId},translate::*};
use std::{boxed::Box as Box_};

glib::wrapper! {
    #[doc(alias = "NMSettingPpp")]
    pub struct SettingPpp(Object<ffi::NMSettingPpp, ffi::NMSettingPppClass>) @extends Setting;

    match fn {
        type_ => || ffi::nm_setting_ppp_get_type(),
    }
}

impl SettingPpp {
    #[doc(alias = "nm_setting_ppp_new")]
    pub fn new() -> SettingPpp {
        assert_initialized_main_thread!();
        unsafe {
            Setting::from_glib_full(ffi::nm_setting_ppp_new()).unsafe_cast()
        }
    }

            // rustdoc-stripper-ignore-next
            /// Creates a new builder-pattern struct instance to construct [`SettingPpp`] objects.
            ///
            /// This method returns an instance of [`SettingPppBuilder`](crate::builders::SettingPppBuilder) which can be used to create [`SettingPpp`] objects.
            pub fn builder() -> SettingPppBuilder {
                SettingPppBuilder::new()
            }
        

    #[doc(alias = "nm_setting_ppp_get_baud")]
    #[doc(alias = "get_baud")]
    pub fn baud(&self) -> u32 {
        unsafe {
            ffi::nm_setting_ppp_get_baud(self.to_glib_none().0)
        }
    }

    #[doc(alias = "nm_setting_ppp_get_crtscts")]
    #[doc(alias = "get_crtscts")]
    #[doc(alias = "crtscts")]
    pub fn is_crtscts(&self) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_ppp_get_crtscts(self.to_glib_none().0))
        }
    }

    #[doc(alias = "nm_setting_ppp_get_lcp_echo_failure")]
    #[doc(alias = "get_lcp_echo_failure")]
    #[doc(alias = "lcp-echo-failure")]
    pub fn lcp_echo_failure(&self) -> u32 {
        unsafe {
            ffi::nm_setting_ppp_get_lcp_echo_failure(self.to_glib_none().0)
        }
    }

    #[doc(alias = "nm_setting_ppp_get_lcp_echo_interval")]
    #[doc(alias = "get_lcp_echo_interval")]
    #[doc(alias = "lcp-echo-interval")]
    pub fn lcp_echo_interval(&self) -> u32 {
        unsafe {
            ffi::nm_setting_ppp_get_lcp_echo_interval(self.to_glib_none().0)
        }
    }

    #[doc(alias = "nm_setting_ppp_get_mppe_stateful")]
    #[doc(alias = "get_mppe_stateful")]
    #[doc(alias = "mppe-stateful")]
    pub fn is_mppe_stateful(&self) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_ppp_get_mppe_stateful(self.to_glib_none().0))
        }
    }

    #[doc(alias = "nm_setting_ppp_get_mru")]
    #[doc(alias = "get_mru")]
    pub fn mru(&self) -> u32 {
        unsafe {
            ffi::nm_setting_ppp_get_mru(self.to_glib_none().0)
        }
    }

    #[doc(alias = "nm_setting_ppp_get_mtu")]
    #[doc(alias = "get_mtu")]
    pub fn mtu(&self) -> u32 {
        unsafe {
            ffi::nm_setting_ppp_get_mtu(self.to_glib_none().0)
        }
    }

    #[doc(alias = "nm_setting_ppp_get_no_vj_comp")]
    #[doc(alias = "get_no_vj_comp")]
    #[doc(alias = "no-vj-comp")]
    pub fn is_no_vj_comp(&self) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_ppp_get_no_vj_comp(self.to_glib_none().0))
        }
    }

    #[doc(alias = "nm_setting_ppp_get_noauth")]
    #[doc(alias = "get_noauth")]
    #[doc(alias = "noauth")]
    pub fn is_noauth(&self) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_ppp_get_noauth(self.to_glib_none().0))
        }
    }

    #[doc(alias = "nm_setting_ppp_get_nobsdcomp")]
    #[doc(alias = "get_nobsdcomp")]
    #[doc(alias = "nobsdcomp")]
    pub fn is_nobsdcomp(&self) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_ppp_get_nobsdcomp(self.to_glib_none().0))
        }
    }

    #[doc(alias = "nm_setting_ppp_get_nodeflate")]
    #[doc(alias = "get_nodeflate")]
    #[doc(alias = "nodeflate")]
    pub fn is_nodeflate(&self) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_ppp_get_nodeflate(self.to_glib_none().0))
        }
    }

    #[doc(alias = "nm_setting_ppp_get_refuse_chap")]
    #[doc(alias = "get_refuse_chap")]
    #[doc(alias = "refuse-chap")]
    pub fn is_refuse_chap(&self) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_ppp_get_refuse_chap(self.to_glib_none().0))
        }
    }

    #[doc(alias = "nm_setting_ppp_get_refuse_eap")]
    #[doc(alias = "get_refuse_eap")]
    #[doc(alias = "refuse-eap")]
    pub fn is_refuse_eap(&self) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_ppp_get_refuse_eap(self.to_glib_none().0))
        }
    }

    #[doc(alias = "nm_setting_ppp_get_refuse_mschap")]
    #[doc(alias = "get_refuse_mschap")]
    #[doc(alias = "refuse-mschap")]
    pub fn is_refuse_mschap(&self) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_ppp_get_refuse_mschap(self.to_glib_none().0))
        }
    }

    #[doc(alias = "nm_setting_ppp_get_refuse_mschapv2")]
    #[doc(alias = "get_refuse_mschapv2")]
    #[doc(alias = "refuse-mschapv2")]
    pub fn is_refuse_mschapv2(&self) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_ppp_get_refuse_mschapv2(self.to_glib_none().0))
        }
    }

    #[doc(alias = "nm_setting_ppp_get_refuse_pap")]
    #[doc(alias = "get_refuse_pap")]
    #[doc(alias = "refuse-pap")]
    pub fn is_refuse_pap(&self) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_ppp_get_refuse_pap(self.to_glib_none().0))
        }
    }

    #[doc(alias = "nm_setting_ppp_get_require_mppe")]
    #[doc(alias = "get_require_mppe")]
    #[doc(alias = "require-mppe")]
    pub fn requires_mppe(&self) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_ppp_get_require_mppe(self.to_glib_none().0))
        }
    }

    #[doc(alias = "nm_setting_ppp_get_require_mppe_128")]
    #[doc(alias = "get_require_mppe_128")]
    #[doc(alias = "require-mppe-128")]
    pub fn requires_mppe_128(&self) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_ppp_get_require_mppe_128(self.to_glib_none().0))
        }
    }

    pub fn set_baud(&self, baud: u32) {
        ObjectExt::set_property(self,"baud", baud)
    }

    pub fn set_crtscts(&self, crtscts: bool) {
        ObjectExt::set_property(self,"crtscts", crtscts)
    }

    #[doc(alias = "lcp-echo-failure")]
    pub fn set_lcp_echo_failure(&self, lcp_echo_failure: u32) {
        ObjectExt::set_property(self,"lcp-echo-failure", lcp_echo_failure)
    }

    #[doc(alias = "lcp-echo-interval")]
    pub fn set_lcp_echo_interval(&self, lcp_echo_interval: u32) {
        ObjectExt::set_property(self,"lcp-echo-interval", lcp_echo_interval)
    }

    #[doc(alias = "mppe-stateful")]
    pub fn set_mppe_stateful(&self, mppe_stateful: bool) {
        ObjectExt::set_property(self,"mppe-stateful", mppe_stateful)
    }

    pub fn set_mru(&self, mru: u32) {
        ObjectExt::set_property(self,"mru", mru)
    }

    pub fn set_mtu(&self, mtu: u32) {
        ObjectExt::set_property(self,"mtu", mtu)
    }

    #[doc(alias = "no-vj-comp")]
    pub fn set_no_vj_comp(&self, no_vj_comp: bool) {
        ObjectExt::set_property(self,"no-vj-comp", no_vj_comp)
    }

    pub fn set_noauth(&self, noauth: bool) {
        ObjectExt::set_property(self,"noauth", noauth)
    }

    pub fn set_nobsdcomp(&self, nobsdcomp: bool) {
        ObjectExt::set_property(self,"nobsdcomp", nobsdcomp)
    }

    pub fn set_nodeflate(&self, nodeflate: bool) {
        ObjectExt::set_property(self,"nodeflate", nodeflate)
    }

    #[doc(alias = "refuse-chap")]
    pub fn set_refuse_chap(&self, refuse_chap: bool) {
        ObjectExt::set_property(self,"refuse-chap", refuse_chap)
    }

    #[doc(alias = "refuse-eap")]
    pub fn set_refuse_eap(&self, refuse_eap: bool) {
        ObjectExt::set_property(self,"refuse-eap", refuse_eap)
    }

    #[doc(alias = "refuse-mschap")]
    pub fn set_refuse_mschap(&self, refuse_mschap: bool) {
        ObjectExt::set_property(self,"refuse-mschap", refuse_mschap)
    }

    #[doc(alias = "refuse-mschapv2")]
    pub fn set_refuse_mschapv2(&self, refuse_mschapv2: bool) {
        ObjectExt::set_property(self,"refuse-mschapv2", refuse_mschapv2)
    }

    #[doc(alias = "refuse-pap")]
    pub fn set_refuse_pap(&self, refuse_pap: bool) {
        ObjectExt::set_property(self,"refuse-pap", refuse_pap)
    }

    #[doc(alias = "require-mppe")]
    pub fn set_require_mppe(&self, require_mppe: bool) {
        ObjectExt::set_property(self,"require-mppe", require_mppe)
    }

    #[doc(alias = "require-mppe-128")]
    pub fn set_require_mppe_128(&self, require_mppe_128: bool) {
        ObjectExt::set_property(self,"require-mppe-128", require_mppe_128)
    }

    #[doc(alias = "baud")]
    pub fn connect_baud_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_baud_trampoline<F: Fn(&SettingPpp) + 'static>(this: *mut ffi::NMSettingPpp, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::baud".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_baud_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "crtscts")]
    pub fn connect_crtscts_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_crtscts_trampoline<F: Fn(&SettingPpp) + 'static>(this: *mut ffi::NMSettingPpp, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::crtscts".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_crtscts_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "lcp-echo-failure")]
    pub fn connect_lcp_echo_failure_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_lcp_echo_failure_trampoline<F: Fn(&SettingPpp) + 'static>(this: *mut ffi::NMSettingPpp, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::lcp-echo-failure".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_lcp_echo_failure_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "lcp-echo-interval")]
    pub fn connect_lcp_echo_interval_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_lcp_echo_interval_trampoline<F: Fn(&SettingPpp) + 'static>(this: *mut ffi::NMSettingPpp, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::lcp-echo-interval".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_lcp_echo_interval_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "mppe-stateful")]
    pub fn connect_mppe_stateful_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_mppe_stateful_trampoline<F: Fn(&SettingPpp) + 'static>(this: *mut ffi::NMSettingPpp, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::mppe-stateful".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_mppe_stateful_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "mru")]
    pub fn connect_mru_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_mru_trampoline<F: Fn(&SettingPpp) + 'static>(this: *mut ffi::NMSettingPpp, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::mru".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_mru_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "mtu")]
    pub fn connect_mtu_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_mtu_trampoline<F: Fn(&SettingPpp) + 'static>(this: *mut ffi::NMSettingPpp, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::mtu".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_mtu_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "no-vj-comp")]
    pub fn connect_no_vj_comp_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_no_vj_comp_trampoline<F: Fn(&SettingPpp) + 'static>(this: *mut ffi::NMSettingPpp, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::no-vj-comp".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_no_vj_comp_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "noauth")]
    pub fn connect_noauth_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_noauth_trampoline<F: Fn(&SettingPpp) + 'static>(this: *mut ffi::NMSettingPpp, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::noauth".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_noauth_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "nobsdcomp")]
    pub fn connect_nobsdcomp_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_nobsdcomp_trampoline<F: Fn(&SettingPpp) + 'static>(this: *mut ffi::NMSettingPpp, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::nobsdcomp".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_nobsdcomp_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "nodeflate")]
    pub fn connect_nodeflate_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_nodeflate_trampoline<F: Fn(&SettingPpp) + 'static>(this: *mut ffi::NMSettingPpp, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::nodeflate".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_nodeflate_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "refuse-chap")]
    pub fn connect_refuse_chap_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_refuse_chap_trampoline<F: Fn(&SettingPpp) + 'static>(this: *mut ffi::NMSettingPpp, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::refuse-chap".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_refuse_chap_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "refuse-eap")]
    pub fn connect_refuse_eap_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_refuse_eap_trampoline<F: Fn(&SettingPpp) + 'static>(this: *mut ffi::NMSettingPpp, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::refuse-eap".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_refuse_eap_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "refuse-mschap")]
    pub fn connect_refuse_mschap_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_refuse_mschap_trampoline<F: Fn(&SettingPpp) + 'static>(this: *mut ffi::NMSettingPpp, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::refuse-mschap".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_refuse_mschap_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "refuse-mschapv2")]
    pub fn connect_refuse_mschapv2_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_refuse_mschapv2_trampoline<F: Fn(&SettingPpp) + 'static>(this: *mut ffi::NMSettingPpp, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::refuse-mschapv2".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_refuse_mschapv2_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "refuse-pap")]
    pub fn connect_refuse_pap_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_refuse_pap_trampoline<F: Fn(&SettingPpp) + 'static>(this: *mut ffi::NMSettingPpp, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::refuse-pap".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_refuse_pap_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "require-mppe")]
    pub fn connect_require_mppe_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_require_mppe_trampoline<F: Fn(&SettingPpp) + 'static>(this: *mut ffi::NMSettingPpp, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::require-mppe".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_require_mppe_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "require-mppe-128")]
    pub fn connect_require_mppe_128_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_require_mppe_128_trampoline<F: Fn(&SettingPpp) + 'static>(this: *mut ffi::NMSettingPpp, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::require-mppe-128".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_require_mppe_128_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }
}

impl Default for SettingPpp {
                     fn default() -> Self {
                         Self::new()
                     }
                 }

// rustdoc-stripper-ignore-next
        /// A [builder-pattern] type to construct [`SettingPpp`] objects.
        ///
        /// [builder-pattern]: https://doc.rust-lang.org/1.0.0/style/ownership/builders.html
#[must_use = "The builder must be built to be used"]
pub struct SettingPppBuilder {
            builder: glib::object::ObjectBuilder<'static, SettingPpp>,
        }

        impl SettingPppBuilder {
        fn new() -> Self {
            Self { builder: glib::object::Object::builder() }
        }

                            pub fn baud(self, baud: u32) -> Self {
                            Self { builder: self.builder.property("baud", baud), }
                        }

                            pub fn crtscts(self, crtscts: bool) -> Self {
                            Self { builder: self.builder.property("crtscts", crtscts), }
                        }

                            pub fn lcp_echo_failure(self, lcp_echo_failure: u32) -> Self {
                            Self { builder: self.builder.property("lcp-echo-failure", lcp_echo_failure), }
                        }

                            pub fn lcp_echo_interval(self, lcp_echo_interval: u32) -> Self {
                            Self { builder: self.builder.property("lcp-echo-interval", lcp_echo_interval), }
                        }

                            pub fn mppe_stateful(self, mppe_stateful: bool) -> Self {
                            Self { builder: self.builder.property("mppe-stateful", mppe_stateful), }
                        }

                            pub fn mru(self, mru: u32) -> Self {
                            Self { builder: self.builder.property("mru", mru), }
                        }

                            pub fn mtu(self, mtu: u32) -> Self {
                            Self { builder: self.builder.property("mtu", mtu), }
                        }

                            pub fn no_vj_comp(self, no_vj_comp: bool) -> Self {
                            Self { builder: self.builder.property("no-vj-comp", no_vj_comp), }
                        }

                            pub fn noauth(self, noauth: bool) -> Self {
                            Self { builder: self.builder.property("noauth", noauth), }
                        }

                            pub fn nobsdcomp(self, nobsdcomp: bool) -> Self {
                            Self { builder: self.builder.property("nobsdcomp", nobsdcomp), }
                        }

                            pub fn nodeflate(self, nodeflate: bool) -> Self {
                            Self { builder: self.builder.property("nodeflate", nodeflate), }
                        }

                            pub fn refuse_chap(self, refuse_chap: bool) -> Self {
                            Self { builder: self.builder.property("refuse-chap", refuse_chap), }
                        }

                            pub fn refuse_eap(self, refuse_eap: bool) -> Self {
                            Self { builder: self.builder.property("refuse-eap", refuse_eap), }
                        }

                            pub fn refuse_mschap(self, refuse_mschap: bool) -> Self {
                            Self { builder: self.builder.property("refuse-mschap", refuse_mschap), }
                        }

                            pub fn refuse_mschapv2(self, refuse_mschapv2: bool) -> Self {
                            Self { builder: self.builder.property("refuse-mschapv2", refuse_mschapv2), }
                        }

                            pub fn refuse_pap(self, refuse_pap: bool) -> Self {
                            Self { builder: self.builder.property("refuse-pap", refuse_pap), }
                        }

                            pub fn require_mppe(self, require_mppe: bool) -> Self {
                            Self { builder: self.builder.property("require-mppe", require_mppe), }
                        }

                            pub fn require_mppe_128(self, require_mppe_128: bool) -> Self {
                            Self { builder: self.builder.property("require-mppe-128", require_mppe_128), }
                        }

    // rustdoc-stripper-ignore-next
    /// Build the [`SettingPpp`].
    #[must_use = "Building the object from the builder is usually expensive and is not expected to have side effects"]
    pub fn build(self) -> SettingPpp {
assert_initialized_main_thread!();
    self.builder.build() }
}
