// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir
// from gtk-girs (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT
#![allow(deprecated)]

use crate::{ffi,Connection,SecretAgentCapabilities};
use glib::{prelude::*,signal::{connect_raw, SignalHandlerId},translate::*};
use std::{boxed::Box as Box_,pin::Pin};

#[cfg(feature = "gio_v2_22")]
#[cfg_attr(docsrs, doc(cfg(feature = "gio_v2_22")))]
glib::wrapper! {
    ///
    ///
    /// This is an Abstract Base Class, you cannot instantiate it.
    ///
    /// ## Properties
    ///
    ///
    /// #### `auto-register`
    ///  If [`true`] (the default), the agent will always be registered when
    /// NetworkManager is running; if NetworkManager exits and restarts, the
    /// agent will re-register itself automatically.
    ///
    /// In particular, if this property is [`true`] at construct time, then the
    /// agent will register itself with NetworkManager during
    /// construction/initialization and initialization will only complete
    /// after registration is completed (either successfully or unsuccessfully).
    /// Since 1.24, a failure to register will no longer cause initialization
    /// of #NMSecretAgentOld to fail.
    ///
    /// If the property is [`false`], the agent will not automatically register with
    /// NetworkManager, and nm_secret_agent_old_enable() or
    /// nm_secret_agent_old_register_async() must be called to register it.
    ///
    /// Calling nm_secret_agent_old_enable() has the same effect as setting this
    /// property.
    ///
    /// Readable | Writeable | Construct
    ///
    ///
    /// #### `capabilities`
    ///  A bitfield of `NMSecretAgentCapabilities`.
    ///
    /// Changing this property is possible at any time. In case the secret
    /// agent is currently registered, this will cause a re-registration.
    ///
    /// Readable | Writeable | Construct
    ///
    ///
    /// #### `dbus-connection`
    ///  The #GDBusConnection used by the instance. You may either set this
    /// as construct-only property, or otherwise #NMSecretAgentOld will choose
    /// a connection via g_bus_get() during initialization.
    ///
    /// Readable | Writeable | Construct Only
    ///
    ///
    /// #### `identifier`
    ///  Identifies this agent; only one agent in each user session may use the
    /// same identifier.  Identifier formatting follows the same rules as
    /// D-Bus bus names with the exception that the ':' character is not
    /// allowed.  The valid set of characters is "[A-Z][a-z][0-9]_-." and the
    /// identifier is limited in length to 255 characters with a minimum
    /// of 3 characters.  An example valid identifier is 'org.gnome.nm-applet'
    /// (without quotes).
    ///
    /// Readable | Writeable | Construct Only
    ///
    ///
    /// #### `registered`
    ///  [`true`] if the agent is registered with NetworkManager, [`false`] if not.
    ///
    /// Readable
    ///
    /// # Implements
    ///
    /// [`SecretAgentOldExt`][trait@crate::prelude::SecretAgentOldExt], [`trait@gio::prelude::AsyncInitableExt`], [`trait@gio::prelude::InitableExt`]
    #[doc(alias = "NMSecretAgentOld")]
    pub struct SecretAgentOld(Object<ffi::NMSecretAgentOld, ffi::NMSecretAgentOldClass>) @implements gio::AsyncInitable, gio::Initable;

    match fn {
        type_ => || ffi::nm_secret_agent_old_get_type(),
    }
}

#[cfg(not(any(feature = "gio_v2_22")))]
#[cfg(feature = "gio_v2_22")]
glib::wrapper! {
    #[doc(alias = "NMSecretAgentOld")]
    pub struct SecretAgentOld(Object<ffi::NMSecretAgentOld, ffi::NMSecretAgentOldClass>) @implements gio::Initable;

    match fn {
        type_ => || ffi::nm_secret_agent_old_get_type(),
    }
}

#[cfg(not(any(feature = "gio_v2_22")))]
glib::wrapper! {
    #[doc(alias = "NMSecretAgentOld")]
    pub struct SecretAgentOld(Object<ffi::NMSecretAgentOld, ffi::NMSecretAgentOldClass>);

    match fn {
        type_ => || ffi::nm_secret_agent_old_get_type(),
    }
}

impl SecretAgentOld {
        pub const NONE: Option<&'static SecretAgentOld> = None;
    
}

/// Trait containing all [`struct@SecretAgentOld`] methods.
///
/// # Implementors
///
/// [`SecretAgentOld`][struct@crate::SecretAgentOld]
pub trait SecretAgentOldExt: IsA<SecretAgentOld> + 'static {
    /// Asynchronously asks the agent to delete all saved secrets belonging to
    /// @connection.
    /// ## `connection`
    /// a #NMConnection
    /// ## `callback`
    /// a callback, to be invoked when the operation is done
    #[doc(alias = "nm_secret_agent_old_delete_secrets")]
    fn delete_secrets<P: FnOnce(&SecretAgentOld, &Connection, Option<&glib::Error>) + 'static>(&self, connection: &impl IsA<Connection>, callback: P) {
        let callback_data: Box_<P> = Box_::new(callback);
        unsafe extern "C" fn callback_func<P: FnOnce(&SecretAgentOld, &Connection, Option<&glib::Error>) + 'static>(agent: *mut ffi::NMSecretAgentOld, connection: *mut ffi::NMConnection, error: *mut glib::ffi::GError, user_data: glib::ffi::gpointer) {
            let agent = from_glib_borrow(agent);
            let connection = from_glib_borrow(connection);
            let error: Borrowed<Option<glib::Error>> = from_glib_borrow(error);
            let callback = Box_::from_raw(user_data as *mut P);
            (*callback)(&agent, &connection, error.as_ref().as_ref())
        }
        let callback = Some(callback_func::<P> as _);
        let super_callback0: Box_<P> = callback_data;
        unsafe {
            ffi::nm_secret_agent_old_delete_secrets(self.as_ref().to_glib_none().0, connection.as_ref().to_glib_none().0, callback, Box_::into_raw(super_callback0) as *mut _);
        }
    }

    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    #[doc(alias = "nm_secret_agent_old_destroy")]
    fn destroy(&self) {
        unsafe {
            ffi::nm_secret_agent_old_destroy(self.as_ref().to_glib_none().0);
        }
    }

    /// This has the same effect as setting [`SECRET_AGENT_OLD_AUTO_REGISTER`][crate::SECRET_AGENT_OLD_AUTO_REGISTER]
    /// property.
    ///
    /// Unlike most other functions, you may already call this function before
    /// initialization completes.
    /// ## `enable`
    /// whether to enable or disable the listener.
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    #[doc(alias = "nm_secret_agent_old_enable")]
    fn enable(&self, enable: bool) {
        unsafe {
            ffi::nm_secret_agent_old_enable(self.as_ref().to_glib_none().0, enable.into_glib());
        }
    }

    //#[cfg(feature = "v1_24")]
    //#[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    //#[doc(alias = "nm_secret_agent_old_get_context_busy_watcher")]
    //#[doc(alias = "get_context_busy_watcher")]
    //fn context_busy_watcher(&self) -> /*Ignored*/glib::Object {
    //    unsafe { TODO: call ffi:nm_secret_agent_old_get_context_busy_watcher() }
    //}

    //#[cfg(feature = "v1_24")]
    //#[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    //#[doc(alias = "nm_secret_agent_old_get_dbus_connection")]
    //#[doc(alias = "get_dbus_connection")]
    //#[doc(alias = "dbus-connection")]
    //fn dbus_connection(&self) -> /*Ignored*/gio::DBusConnection {
    //    unsafe { TODO: call ffi:nm_secret_agent_old_get_dbus_connection() }
    //}

    ///
    /// # Returns
    ///
    /// the current D-Bus name owner. While this property
    ///   is set while registering, it really only makes sense when
    ///   the nm_secret_agent_old_get_registered() indicates that
    ///   registration is successful.
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    #[doc(alias = "nm_secret_agent_old_get_dbus_name_owner")]
    #[doc(alias = "get_dbus_name_owner")]
    fn dbus_name_owner(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_secret_agent_old_get_dbus_name_owner(self.as_ref().to_glib_none().0))
        }
    }

    //#[cfg(feature = "v1_24")]
    //#[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    //#[doc(alias = "nm_secret_agent_old_get_main_context")]
    //#[doc(alias = "get_main_context")]
    //fn main_context(&self) -> /*Ignored*/glib::MainContext {
    //    unsafe { TODO: call ffi:nm_secret_agent_old_get_main_context() }
    //}

    /// Note that the secret agent transparently registers and re-registers
    /// as the D-Bus name owner appears. Hence, this property is not really
    /// useful. Also, to be graceful against races during registration, the
    /// instance will already accept requests while being in the process of
    /// registering.
    /// If you need to avoid races and want to wait until @self is registered,
    /// call nm_secret_agent_old_register_async(). If that function completes
    /// with success, you know the instance is registered.
    ///
    /// # Returns
    ///
    /// a [`true`] if the agent is registered, [`false`] if it is not.
    #[doc(alias = "nm_secret_agent_old_get_registered")]
    #[doc(alias = "get_registered")]
    #[doc(alias = "registered")]
    fn is_registered(&self) -> bool {
        unsafe {
            from_glib(ffi::nm_secret_agent_old_get_registered(self.as_ref().to_glib_none().0))
        }
    }

    //#[doc(alias = "nm_secret_agent_old_get_secrets")]
    //#[doc(alias = "get_secrets")]
    //fn secrets(&self, connection: &impl IsA<Connection>, setting_name: &str, hints: &[&str], flags: SecretAgentGetSecretsFlags, callback: /*Unimplemented*/FnOnce(&SecretAgentOld, &Connection, /*Ignored*/Option<glib::Variant>, Option<&glib::Error>), user_data: /*Unimplemented*/Option<Basic: Pointer>) {
    //    unsafe { TODO: call ffi:nm_secret_agent_old_get_secrets() }
    //}

    /// Registers the #NMSecretAgentOld with the NetworkManager secret manager,
    /// indicating to NetworkManager that the agent is able to provide and save
    /// secrets for connections on behalf of its user.
    ///
    /// # Deprecated since 1.24
    ///
    /// Use nm_secret_agent_old_enable() or nm_secret_agent_old_register_async().
    /// ## `cancellable`
    /// a #GCancellable, or [`None`]
    ///
    /// # Returns
    ///
    /// [`true`] if registration was successful, [`false`] on error.
    ///
    /// Since 1.24, this can no longer fail unless the @cancellable gets
    /// cancelled. Contrary to nm_secret_agent_old_register_async(), this also
    /// does not wait for the registration to succeed. You cannot synchronously
    /// (without iterating the caller's GMainContext) wait for registration.
    ///
    /// Since 1.24, registration is idempotent. It has the same effect as setting
    /// [`SECRET_AGENT_OLD_AUTO_REGISTER`][crate::SECRET_AGENT_OLD_AUTO_REGISTER] to [`true`] or nm_secret_agent_old_enable().
    #[cfg_attr(feature = "v1_24", deprecated = "Since 1.24")]
    #[allow(deprecated)]
    #[doc(alias = "nm_secret_agent_old_register")]
    fn register(&self, cancellable: Option<&impl IsA<gio::Cancellable>>) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::nm_secret_agent_old_register(self.as_ref().to_glib_none().0, cancellable.map(|p| p.as_ref()).to_glib_none().0, &mut error);
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
        }
    }

    /// Asynchronously registers the #NMSecretAgentOld with the NetworkManager secret
    /// manager, indicating to NetworkManager that the agent is able to provide and
    /// save secrets for connections on behalf of its user.
    ///
    /// Since 1.24, registration cannot fail and is idempotent. It has
    /// the same effect as setting [`SECRET_AGENT_OLD_AUTO_REGISTER`][crate::SECRET_AGENT_OLD_AUTO_REGISTER] to [`true`]
    /// or nm_secret_agent_old_enable().
    ///
    /// Since 1.24, the asynchronous result indicates whether the instance is successfully
    /// registered. In any case, this call enables the agent and it will automatically
    /// try to register and handle secret requests. A failure of this function only indicates
    /// that currently the instance might not be ready (but since it will automatically
    /// try to recover, it might be ready in a moment afterwards). Use this function if
    /// you want to check and ensure that the agent is registered.
    /// ## `cancellable`
    /// a #GCancellable, or [`None`]
    /// ## `callback`
    /// callback to call when the agent is registered
    #[doc(alias = "nm_secret_agent_old_register_async")]
    fn register_async<P: FnOnce(Result<(), glib::Error>) + 'static>(&self, cancellable: Option<&impl IsA<gio::Cancellable>>, callback: P) {
        
                let main_context = glib::MainContext::ref_thread_default();
                let is_main_context_owner = main_context.is_owner();
                let has_acquired_main_context = (!is_main_context_owner)
                    .then(|| main_context.acquire().ok())
                    .flatten();
                assert!(
                    is_main_context_owner || has_acquired_main_context.is_some(),
                    "Async operations only allowed if the thread is owning the MainContext"
                );
        
        let user_data: Box_<glib::thread_guard::ThreadGuard<P>> = Box_::new(glib::thread_guard::ThreadGuard::new(callback));
        unsafe extern "C" fn register_async_trampoline<P: FnOnce(Result<(), glib::Error>) + 'static>(_source_object: *mut glib::gobject_ffi::GObject, res: *mut gio::ffi::GAsyncResult, user_data: glib::ffi::gpointer) {
            let mut error = std::ptr::null_mut();
            ffi::nm_secret_agent_old_register_finish(_source_object as *mut _, res, &mut error);
            let result = if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) };
            let callback: Box_<glib::thread_guard::ThreadGuard<P>> = Box_::from_raw(user_data as *mut _);
            let callback: P = callback.into_inner();
            callback(result);
        }
        let callback = register_async_trampoline::<P>;
        unsafe {
            ffi::nm_secret_agent_old_register_async(self.as_ref().to_glib_none().0, cancellable.map(|p| p.as_ref()).to_glib_none().0, Some(callback), Box_::into_raw(user_data) as *mut _);
        }
    }

    
    fn register_future(&self) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>> {

        Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
            obj.register_async(
                Some(cancellable),
                move |res| {
                    send.resolve(res);
                },
            );
        }))
    }

    /// Asynchronously ensures that all secrets inside @connection are stored to
    /// disk.
    /// ## `connection`
    /// a #NMConnection
    /// ## `callback`
    /// a callback, to be invoked when the operation is done
    #[doc(alias = "nm_secret_agent_old_save_secrets")]
    fn save_secrets<P: FnOnce(&SecretAgentOld, &Connection, Option<&glib::Error>) + 'static>(&self, connection: &impl IsA<Connection>, callback: P) {
        let callback_data: Box_<P> = Box_::new(callback);
        unsafe extern "C" fn callback_func<P: FnOnce(&SecretAgentOld, &Connection, Option<&glib::Error>) + 'static>(agent: *mut ffi::NMSecretAgentOld, connection: *mut ffi::NMConnection, error: *mut glib::ffi::GError, user_data: glib::ffi::gpointer) {
            let agent = from_glib_borrow(agent);
            let connection = from_glib_borrow(connection);
            let error: Borrowed<Option<glib::Error>> = from_glib_borrow(error);
            let callback = Box_::from_raw(user_data as *mut P);
            (*callback)(&agent, &connection, error.as_ref().as_ref())
        }
        let callback = Some(callback_func::<P> as _);
        let super_callback0: Box_<P> = callback_data;
        unsafe {
            ffi::nm_secret_agent_old_save_secrets(self.as_ref().to_glib_none().0, connection.as_ref().to_glib_none().0, callback, Box_::into_raw(super_callback0) as *mut _);
        }
    }

    /// Unregisters the #NMSecretAgentOld with the NetworkManager secret manager,
    /// indicating to NetworkManager that the agent will no longer provide or
    /// store secrets on behalf of this user.
    ///
    /// # Deprecated since 1.24
    ///
    /// Use nm_secret_agent_old_enable().
    /// ## `cancellable`
    /// a #GCancellable, or [`None`]
    ///
    /// # Returns
    ///
    /// [`true`] if unregistration was successful, [`false`] on error
    ///
    /// Since 1.24, registration cannot fail and is idempotent. It has
    /// the same effect as setting [`SECRET_AGENT_OLD_AUTO_REGISTER`][crate::SECRET_AGENT_OLD_AUTO_REGISTER] to [`false`]
    /// or nm_secret_agent_old_enable().
    #[cfg_attr(feature = "v1_24", deprecated = "Since 1.24")]
    #[allow(deprecated)]
    #[doc(alias = "nm_secret_agent_old_unregister")]
    fn unregister(&self, cancellable: Option<&impl IsA<gio::Cancellable>>) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::nm_secret_agent_old_unregister(self.as_ref().to_glib_none().0, cancellable.map(|p| p.as_ref()).to_glib_none().0, &mut error);
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
        }
    }

    /// Asynchronously unregisters the #NMSecretAgentOld with the NetworkManager secret
    /// manager, indicating to NetworkManager that the agent will no longer provide
    /// or store secrets on behalf of this user.
    ///
    /// Since 1.24, registration cannot fail and is idempotent. It has
    /// the same effect as setting [`SECRET_AGENT_OLD_AUTO_REGISTER`][crate::SECRET_AGENT_OLD_AUTO_REGISTER] to [`false`]
    /// or nm_secret_agent_old_enable().
    ///
    /// # Deprecated since 1.24
    ///
    /// Use nm_secret_agent_old_enable().
    /// ## `cancellable`
    /// a #GCancellable, or [`None`]
    /// ## `callback`
    /// callback to call when the agent is unregistered
    #[cfg_attr(feature = "v1_24", deprecated = "Since 1.24")]
    #[allow(deprecated)]
    #[doc(alias = "nm_secret_agent_old_unregister_async")]
    fn unregister_async<P: FnOnce(Result<(), glib::Error>) + 'static>(&self, cancellable: Option<&impl IsA<gio::Cancellable>>, callback: P) {
        
                let main_context = glib::MainContext::ref_thread_default();
                let is_main_context_owner = main_context.is_owner();
                let has_acquired_main_context = (!is_main_context_owner)
                    .then(|| main_context.acquire().ok())
                    .flatten();
                assert!(
                    is_main_context_owner || has_acquired_main_context.is_some(),
                    "Async operations only allowed if the thread is owning the MainContext"
                );
        
        let user_data: Box_<glib::thread_guard::ThreadGuard<P>> = Box_::new(glib::thread_guard::ThreadGuard::new(callback));
        unsafe extern "C" fn unregister_async_trampoline<P: FnOnce(Result<(), glib::Error>) + 'static>(_source_object: *mut glib::gobject_ffi::GObject, res: *mut gio::ffi::GAsyncResult, user_data: glib::ffi::gpointer) {
            let mut error = std::ptr::null_mut();
            ffi::nm_secret_agent_old_unregister_finish(_source_object as *mut _, res, &mut error);
            let result = if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) };
            let callback: Box_<glib::thread_guard::ThreadGuard<P>> = Box_::from_raw(user_data as *mut _);
            let callback: P = callback.into_inner();
            callback(result);
        }
        let callback = unregister_async_trampoline::<P>;
        unsafe {
            ffi::nm_secret_agent_old_unregister_async(self.as_ref().to_glib_none().0, cancellable.map(|p| p.as_ref()).to_glib_none().0, Some(callback), Box_::into_raw(user_data) as *mut _);
        }
    }

    #[cfg_attr(feature = "v1_24", deprecated = "Since 1.24")]
    
    fn unregister_future(&self) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>> {

        Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
            obj.unregister_async(
                Some(cancellable),
                move |res| {
                    send.resolve(res);
                },
            );
        }))
    }

    /// If [`true`] (the default), the agent will always be registered when
    /// NetworkManager is running; if NetworkManager exits and restarts, the
    /// agent will re-register itself automatically.
    ///
    /// In particular, if this property is [`true`] at construct time, then the
    /// agent will register itself with NetworkManager during
    /// construction/initialization and initialization will only complete
    /// after registration is completed (either successfully or unsuccessfully).
    /// Since 1.24, a failure to register will no longer cause initialization
    /// of #NMSecretAgentOld to fail.
    ///
    /// If the property is [`false`], the agent will not automatically register with
    /// NetworkManager, and nm_secret_agent_old_enable() or
    /// nm_secret_agent_old_register_async() must be called to register it.
    ///
    /// Calling nm_secret_agent_old_enable() has the same effect as setting this
    /// property.
    #[doc(alias = "auto-register")]
    fn is_auto_register(&self) -> bool {
        ObjectExt::property(self.as_ref(), "auto-register")
    }

    /// If [`true`] (the default), the agent will always be registered when
    /// NetworkManager is running; if NetworkManager exits and restarts, the
    /// agent will re-register itself automatically.
    ///
    /// In particular, if this property is [`true`] at construct time, then the
    /// agent will register itself with NetworkManager during
    /// construction/initialization and initialization will only complete
    /// after registration is completed (either successfully or unsuccessfully).
    /// Since 1.24, a failure to register will no longer cause initialization
    /// of #NMSecretAgentOld to fail.
    ///
    /// If the property is [`false`], the agent will not automatically register with
    /// NetworkManager, and nm_secret_agent_old_enable() or
    /// nm_secret_agent_old_register_async() must be called to register it.
    ///
    /// Calling nm_secret_agent_old_enable() has the same effect as setting this
    /// property.
    #[doc(alias = "auto-register")]
    fn set_auto_register(&self, auto_register: bool) {
        ObjectExt::set_property(self.as_ref(),"auto-register", auto_register)
    }

    /// A bitfield of `NMSecretAgentCapabilities`.
    ///
    /// Changing this property is possible at any time. In case the secret
    /// agent is currently registered, this will cause a re-registration.
    fn capabilities(&self) -> SecretAgentCapabilities {
        ObjectExt::property(self.as_ref(), "capabilities")
    }

    /// A bitfield of `NMSecretAgentCapabilities`.
    ///
    /// Changing this property is possible at any time. In case the secret
    /// agent is currently registered, this will cause a re-registration.
    fn set_capabilities(&self, capabilities: SecretAgentCapabilities) {
        ObjectExt::set_property(self.as_ref(),"capabilities", capabilities)
    }

    /// Identifies this agent; only one agent in each user session may use the
    /// same identifier.  Identifier formatting follows the same rules as
    /// D-Bus bus names with the exception that the ':' character is not
    /// allowed.  The valid set of characters is "[A-Z][a-z][0-9]_-." and the
    /// identifier is limited in length to 255 characters with a minimum
    /// of 3 characters.  An example valid identifier is 'org.gnome.nm-applet'
    /// (without quotes).
    fn identifier(&self) -> Option<glib::GString> {
        ObjectExt::property(self.as_ref(), "identifier")
    }

    #[doc(alias = "auto-register")]
    fn connect_auto_register_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_auto_register_trampoline<P: IsA<SecretAgentOld>, F: Fn(&P) + 'static>(this: *mut ffi::NMSecretAgentOld, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(SecretAgentOld::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::auto-register".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_auto_register_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "capabilities")]
    fn connect_capabilities_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_capabilities_trampoline<P: IsA<SecretAgentOld>, F: Fn(&P) + 'static>(this: *mut ffi::NMSecretAgentOld, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(SecretAgentOld::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::capabilities".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_capabilities_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "registered")]
    fn connect_registered_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_registered_trampoline<P: IsA<SecretAgentOld>, F: Fn(&P) + 'static>(this: *mut ffi::NMSecretAgentOld, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(SecretAgentOld::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::registered".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_registered_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }
}

impl<O: IsA<SecretAgentOld>> SecretAgentOldExt for O {}
