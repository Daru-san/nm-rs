// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir
// from gtk-girs (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use crate::{ffi,Setting};
#[cfg(feature = "v1_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
use crate::{SettingMacsecMode,SettingMacsecValidation,SettingSecretFlags};
#[cfg(feature = "v1_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
use crate::{SettingMacsecOffload};
use glib::{prelude::*};
#[cfg(feature = "v1_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
use glib::{signal::{connect_raw, SignalHandlerId},translate::*};
#[cfg(feature = "v1_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
use std::{boxed::Box as Box_};

glib::wrapper! {
    /// MACSec Settings
    ///
    /// ## Properties
    ///
    ///
    /// #### `encrypt`
    ///  Whether the transmitted traffic must be encrypted.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `mka-cak`
    ///  The pre-shared CAK (Connectivity Association Key) for MACsec
    /// Key Agreement. Must be a string of 32 hexadecimal characters.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `mka-cak-flags`
    ///  Flags indicating how to handle the #NMSettingMacsec:mka-cak
    /// property.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `mka-ckn`
    ///  The pre-shared CKN (Connectivity-association Key Name) for
    /// MACsec Key Agreement. Must be a string of hexadecimal characters
    /// with a even length between 2 and 64.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `mode`
    ///  Specifies how the CAK (Connectivity Association Key) for MKA (MACsec Key
    /// Agreement) is obtained.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `offload`
    ///  Specifies the MACsec offload mode.
    ///
    /// [`SettingMacsecOffload::Off`][crate::SettingMacsecOffload::Off] disables MACsec offload.
    ///
    /// [`SettingMacsecOffload::Phy`][crate::SettingMacsecOffload::Phy] and [`SettingMacsecOffload::Mac`][crate::SettingMacsecOffload::Mac] request offload
    /// respectively to the PHY or to the MAC; if the selected mode is not available, the
    /// connection will fail.
    ///
    /// [`SettingMacsecOffload::Default`][crate::SettingMacsecOffload::Default] uses the global default value specified in
    /// NetworkManager configuration; if no global default is defined, the built-in
    /// default is [`SettingMacsecOffload::Off`][crate::SettingMacsecOffload::Off].
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `parent`
    ///  If given, specifies the parent interface name or parent connection UUID
    /// from which this MACSEC interface should be created.  If this property is
    /// not specified, the connection must contain an #NMSettingWired setting
    /// with a #NMSettingWired:mac-address property.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `port`
    ///  The port component of the SCI (Secure Channel Identifier), between 1 and 65534.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `send-sci`
    ///  Specifies whether the SCI (Secure Channel Identifier) is included
    /// in every packet.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `validation`
    ///  Specifies the validation mode for incoming frames.
    ///
    /// Readable | Writeable
    /// <details><summary><h4>Setting</h4></summary>
    ///
    ///
    /// #### `name`
    ///  The setting's name, which uniquely identifies the setting within the
    /// connection.  Each setting type has a name unique to that type, for
    /// example "ppp" or "802-11-wireless" or "802-3-ethernet".
    ///
    /// Readable
    /// </details>
    ///
    /// # Implements
    ///
    /// [`SettingExt`][trait@crate::prelude::SettingExt]
    #[doc(alias = "NMSettingMacsec")]
    pub struct SettingMacsec(Object<ffi::NMSettingMacsec, ffi::NMSettingMacsecClass>) @extends Setting;

    match fn {
        type_ => || ffi::nm_setting_macsec_get_type(),
    }
}

impl SettingMacsec {
    /// Creates a new #NMSettingMacsec object with default values.
    ///
    /// # Returns
    ///
    /// the new empty #NMSettingMacsec object
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    #[doc(alias = "nm_setting_macsec_new")]
    pub fn new() -> SettingMacsec {
        assert_initialized_main_thread!();
        unsafe {
            Setting::from_glib_full(ffi::nm_setting_macsec_new()).unsafe_cast()
        }
    }

            // rustdoc-stripper-ignore-next
            /// Creates a new builder-pattern struct instance to construct [`SettingMacsec`] objects.
            ///
            /// This method returns an instance of [`SettingMacsecBuilder`](crate::builders::SettingMacsecBuilder) which can be used to create [`SettingMacsec`] objects.
            pub fn builder() -> SettingMacsecBuilder {
                SettingMacsecBuilder::new()
            }
        

    ///
    /// # Returns
    ///
    /// the #NMSettingMacsec:encrypt property of the setting
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    #[doc(alias = "nm_setting_macsec_get_encrypt")]
    #[doc(alias = "get_encrypt")]
    #[doc(alias = "encrypt")]
    pub fn is_encrypt(&self) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_macsec_get_encrypt(self.to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// the #NMSettingMacsec:mka-cak property of the setting
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    #[doc(alias = "nm_setting_macsec_get_mka_cak")]
    #[doc(alias = "get_mka_cak")]
    #[doc(alias = "mka-cak")]
    pub fn mka_cak(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_setting_macsec_get_mka_cak(self.to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// the #NMSettingSecretFlags pertaining to the #NMSettingMacsec:mka-cak
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    #[doc(alias = "nm_setting_macsec_get_mka_cak_flags")]
    #[doc(alias = "get_mka_cak_flags")]
    #[doc(alias = "mka-cak-flags")]
    pub fn mka_cak_flags(&self) -> SettingSecretFlags {
        unsafe {
            from_glib(ffi::nm_setting_macsec_get_mka_cak_flags(self.to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// the #NMSettingMacsec:mka-ckn property of the setting
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    #[doc(alias = "nm_setting_macsec_get_mka_ckn")]
    #[doc(alias = "get_mka_ckn")]
    #[doc(alias = "mka-ckn")]
    pub fn mka_ckn(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_setting_macsec_get_mka_ckn(self.to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// the #NMSettingMacsec:mode property of the setting
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    #[doc(alias = "nm_setting_macsec_get_mode")]
    #[doc(alias = "get_mode")]
    pub fn mode(&self) -> SettingMacsecMode {
        unsafe {
            from_glib(ffi::nm_setting_macsec_get_mode(self.to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// the #NMSettingMacsec:offload property of the setting
    #[cfg(feature = "v1_46")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
    #[doc(alias = "nm_setting_macsec_get_offload")]
    #[doc(alias = "get_offload")]
    pub fn offload(&self) -> SettingMacsecOffload {
        unsafe {
            from_glib(ffi::nm_setting_macsec_get_offload(self.to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// the #NMSettingMacsec:parent property of the setting
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    #[doc(alias = "nm_setting_macsec_get_parent")]
    #[doc(alias = "get_parent")]
    pub fn parent(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_setting_macsec_get_parent(self.to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// the #NMSettingMacsec:port property of the setting
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    #[doc(alias = "nm_setting_macsec_get_port")]
    #[doc(alias = "get_port")]
    pub fn port(&self) -> i32 {
        unsafe {
            ffi::nm_setting_macsec_get_port(self.to_glib_none().0)
        }
    }

    ///
    /// # Returns
    ///
    /// the #NMSettingMacsec:send-sci property of the setting
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    #[doc(alias = "nm_setting_macsec_get_send_sci")]
    #[doc(alias = "get_send_sci")]
    #[doc(alias = "send-sci")]
    pub fn is_send_sci(&self) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_macsec_get_send_sci(self.to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// the #NMSettingMacsec:validation property of the setting
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    #[doc(alias = "nm_setting_macsec_get_validation")]
    #[doc(alias = "get_validation")]
    pub fn validation(&self) -> SettingMacsecValidation {
        unsafe {
            from_glib(ffi::nm_setting_macsec_get_validation(self.to_glib_none().0))
        }
    }

    /// Whether the transmitted traffic must be encrypted.
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn set_encrypt(&self, encrypt: bool) {
        ObjectExt::set_property(self,"encrypt", encrypt)
    }

    /// The pre-shared CAK (Connectivity Association Key) for MACsec
    /// Key Agreement. Must be a string of 32 hexadecimal characters.
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    #[doc(alias = "mka-cak")]
    pub fn set_mka_cak(&self, mka_cak: Option<&str>) {
        ObjectExt::set_property(self,"mka-cak", mka_cak)
    }

    /// Flags indicating how to handle the #NMSettingMacsec:mka-cak
    /// property.
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    #[doc(alias = "mka-cak-flags")]
    pub fn set_mka_cak_flags(&self, mka_cak_flags: SettingSecretFlags) {
        ObjectExt::set_property(self,"mka-cak-flags", mka_cak_flags)
    }

    /// The pre-shared CKN (Connectivity-association Key Name) for
    /// MACsec Key Agreement. Must be a string of hexadecimal characters
    /// with a even length between 2 and 64.
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    #[doc(alias = "mka-ckn")]
    pub fn set_mka_ckn(&self, mka_ckn: Option<&str>) {
        ObjectExt::set_property(self,"mka-ckn", mka_ckn)
    }

    /// Specifies how the CAK (Connectivity Association Key) for MKA (MACsec Key
    /// Agreement) is obtained.
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn set_mode(&self, mode: i32) {
        ObjectExt::set_property(self,"mode", mode)
    }

    /// Specifies the MACsec offload mode.
    ///
    /// [`SettingMacsecOffload::Off`][crate::SettingMacsecOffload::Off] disables MACsec offload.
    ///
    /// [`SettingMacsecOffload::Phy`][crate::SettingMacsecOffload::Phy] and [`SettingMacsecOffload::Mac`][crate::SettingMacsecOffload::Mac] request offload
    /// respectively to the PHY or to the MAC; if the selected mode is not available, the
    /// connection will fail.
    ///
    /// [`SettingMacsecOffload::Default`][crate::SettingMacsecOffload::Default] uses the global default value specified in
    /// NetworkManager configuration; if no global default is defined, the built-in
    /// default is [`SettingMacsecOffload::Off`][crate::SettingMacsecOffload::Off].
    #[cfg(feature = "v1_46")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
    pub fn set_offload(&self, offload: i32) {
        ObjectExt::set_property(self,"offload", offload)
    }

    /// If given, specifies the parent interface name or parent connection UUID
    /// from which this MACSEC interface should be created.  If this property is
    /// not specified, the connection must contain an #NMSettingWired setting
    /// with a #NMSettingWired:mac-address property.
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn set_parent(&self, parent: Option<&str>) {
        ObjectExt::set_property(self,"parent", parent)
    }

    /// The port component of the SCI (Secure Channel Identifier), between 1 and 65534.
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn set_port(&self, port: i32) {
        ObjectExt::set_property(self,"port", port)
    }

    /// Specifies whether the SCI (Secure Channel Identifier) is included
    /// in every packet.
    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    #[doc(alias = "send-sci")]
    pub fn set_send_sci(&self, send_sci: bool) {
        ObjectExt::set_property(self,"send-sci", send_sci)
    }

    /// Specifies the validation mode for incoming frames.
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn set_validation(&self, validation: i32) {
        ObjectExt::set_property(self,"validation", validation)
    }

    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    #[doc(alias = "encrypt")]
    pub fn connect_encrypt_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_encrypt_trampoline<F: Fn(&SettingMacsec) + 'static>(this: *mut ffi::NMSettingMacsec, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::encrypt".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_encrypt_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    #[doc(alias = "mka-cak")]
    pub fn connect_mka_cak_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_mka_cak_trampoline<F: Fn(&SettingMacsec) + 'static>(this: *mut ffi::NMSettingMacsec, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::mka-cak".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_mka_cak_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    #[doc(alias = "mka-cak-flags")]
    pub fn connect_mka_cak_flags_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_mka_cak_flags_trampoline<F: Fn(&SettingMacsec) + 'static>(this: *mut ffi::NMSettingMacsec, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::mka-cak-flags".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_mka_cak_flags_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    #[doc(alias = "mka-ckn")]
    pub fn connect_mka_ckn_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_mka_ckn_trampoline<F: Fn(&SettingMacsec) + 'static>(this: *mut ffi::NMSettingMacsec, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::mka-ckn".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_mka_ckn_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    #[doc(alias = "mode")]
    pub fn connect_mode_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_mode_trampoline<F: Fn(&SettingMacsec) + 'static>(this: *mut ffi::NMSettingMacsec, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::mode".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_mode_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v1_46")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
    #[doc(alias = "offload")]
    pub fn connect_offload_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_offload_trampoline<F: Fn(&SettingMacsec) + 'static>(this: *mut ffi::NMSettingMacsec, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::offload".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_offload_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    #[doc(alias = "parent")]
    pub fn connect_parent_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_parent_trampoline<F: Fn(&SettingMacsec) + 'static>(this: *mut ffi::NMSettingMacsec, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::parent".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_parent_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    #[doc(alias = "port")]
    pub fn connect_port_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_port_trampoline<F: Fn(&SettingMacsec) + 'static>(this: *mut ffi::NMSettingMacsec, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::port".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_port_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    #[doc(alias = "send-sci")]
    pub fn connect_send_sci_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_send_sci_trampoline<F: Fn(&SettingMacsec) + 'static>(this: *mut ffi::NMSettingMacsec, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::send-sci".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_send_sci_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    #[doc(alias = "validation")]
    pub fn connect_validation_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_validation_trampoline<F: Fn(&SettingMacsec) + 'static>(this: *mut ffi::NMSettingMacsec, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::validation".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_validation_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }
}

#[cfg(feature = "v1_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
impl Default for SettingMacsec {
                     fn default() -> Self {
                         Self::new()
                     }
                 }

// rustdoc-stripper-ignore-next
        /// A [builder-pattern] type to construct [`SettingMacsec`] objects.
        ///
        /// [builder-pattern]: https://doc.rust-lang.org/1.0.0/style/ownership/builders.html
#[must_use = "The builder must be built to be used"]
pub struct SettingMacsecBuilder {
            builder: glib::object::ObjectBuilder<'static, SettingMacsec>,
        }

        impl SettingMacsecBuilder {
        fn new() -> Self {
            Self { builder: glib::object::Object::builder() }
        }

                            /// Whether the transmitted traffic must be encrypted.
                            #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn encrypt(self, encrypt: bool) -> Self {
                            Self { builder: self.builder.property("encrypt", encrypt), }
                        }

                            /// The pre-shared CAK (Connectivity Association Key) for MACsec
                            /// Key Agreement. Must be a string of 32 hexadecimal characters.
                            #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn mka_cak(self, mka_cak: impl Into<glib::GString>) -> Self {
                            Self { builder: self.builder.property("mka-cak", mka_cak.into()), }
                        }

                            /// Flags indicating how to handle the #NMSettingMacsec:mka-cak
                            /// property.
                            #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn mka_cak_flags(self, mka_cak_flags: SettingSecretFlags) -> Self {
                            Self { builder: self.builder.property("mka-cak-flags", mka_cak_flags), }
                        }

                            /// The pre-shared CKN (Connectivity-association Key Name) for
                            /// MACsec Key Agreement. Must be a string of hexadecimal characters
                            /// with a even length between 2 and 64.
                            #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn mka_ckn(self, mka_ckn: impl Into<glib::GString>) -> Self {
                            Self { builder: self.builder.property("mka-ckn", mka_ckn.into()), }
                        }

                            /// Specifies how the CAK (Connectivity Association Key) for MKA (MACsec Key
                            /// Agreement) is obtained.
                            #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn mode(self, mode: i32) -> Self {
                            Self { builder: self.builder.property("mode", mode), }
                        }

                            /// Specifies the MACsec offload mode.
                            ///
                            /// [`SettingMacsecOffload::Off`][crate::SettingMacsecOffload::Off] disables MACsec offload.
                            ///
                            /// [`SettingMacsecOffload::Phy`][crate::SettingMacsecOffload::Phy] and [`SettingMacsecOffload::Mac`][crate::SettingMacsecOffload::Mac] request offload
                            /// respectively to the PHY or to the MAC; if the selected mode is not available, the
                            /// connection will fail.
                            ///
                            /// [`SettingMacsecOffload::Default`][crate::SettingMacsecOffload::Default] uses the global default value specified in
                            /// NetworkManager configuration; if no global default is defined, the built-in
                            /// default is [`SettingMacsecOffload::Off`][crate::SettingMacsecOffload::Off].
                            #[cfg(feature = "v1_46")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_46")))]
    pub fn offload(self, offload: i32) -> Self {
                            Self { builder: self.builder.property("offload", offload), }
                        }

                            /// If given, specifies the parent interface name or parent connection UUID
                            /// from which this MACSEC interface should be created.  If this property is
                            /// not specified, the connection must contain an #NMSettingWired setting
                            /// with a #NMSettingWired:mac-address property.
                            #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn parent(self, parent: impl Into<glib::GString>) -> Self {
                            Self { builder: self.builder.property("parent", parent.into()), }
                        }

                            /// The port component of the SCI (Secure Channel Identifier), between 1 and 65534.
                            #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn port(self, port: i32) -> Self {
                            Self { builder: self.builder.property("port", port), }
                        }

                            /// Specifies whether the SCI (Secure Channel Identifier) is included
                            /// in every packet.
                            #[cfg(feature = "v1_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_12")))]
    pub fn send_sci(self, send_sci: bool) -> Self {
                            Self { builder: self.builder.property("send-sci", send_sci), }
                        }

                            /// Specifies the validation mode for incoming frames.
                            #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn validation(self, validation: i32) -> Self {
                            Self { builder: self.builder.property("validation", validation), }
                        }

    // rustdoc-stripper-ignore-next
    /// Build the [`SettingMacsec`].
    #[must_use = "Building the object from the builder is usually expensive and is not expected to have side effects"]
    pub fn build(self) -> SettingMacsec {
assert_initialized_main_thread!();
    self.builder.build() }
}
