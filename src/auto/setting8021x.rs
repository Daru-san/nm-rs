// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir
// from gtk-girs (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

#[cfg(feature = "v1_8")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
use crate::Setting8021xAuthFlags;
use crate::{Setting, Setting8021xCKFormat, Setting8021xCKScheme, SettingSecretFlags, ffi};
use glib::{
    prelude::*,
    signal::{SignalHandlerId, connect_raw},
    translate::*,
};
use std::boxed::Box as Box_;

glib::wrapper! {
    /// IEEE 802.1x Authentication Settings
    ///
    /// ## Properties
    ///
    ///
    /// #### `altsubject-matches`
    ///  List of strings to be matched against the altSubjectName of the
    /// certificate presented by the authentication server. If the list is empty,
    /// no verification of the server certificate's altSubjectName is performed.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `anonymous-identity`
    ///  Anonymous identity string for EAP authentication methods.  Used as the
    /// unencrypted identity with EAP types that support different tunneled
    /// identity like EAP-TTLS.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `auth-timeout`
    ///  A timeout for the authentication. Zero means the global default; if the
    /// global default is not set, the authentication timeout is 25 seconds.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `ca-cert`
    ///  Contains the CA certificate if used by the EAP method specified in the
    /// #NMSetting8021x:eap property.
    ///
    /// Certificate data is specified using a "scheme"; three are currently
    /// supported: blob, path and pkcs#11 URL. When using the blob scheme this property
    /// should be set to the certificate's DER encoded data. When using the path
    /// scheme, this property should be set to the full UTF-8 encoded path of the
    /// certificate, prefixed with the string "file://" and ending with a terminating
    /// NUL byte.
    /// This property can be unset even if the EAP method supports CA certificates,
    /// but this allows man-in-the-middle attacks and is NOT recommended.
    ///
    /// Note that enabling NMSetting8021x:system-ca-certs will override this
    /// setting to use the built-in path, if the built-in path is not a directory.
    ///
    /// Setting this property directly is discouraged; use the
    /// nm_setting_802_1x_set_ca_cert() function instead.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `ca-cert-password`
    ///  The password used to access the CA certificate stored in
    /// #NMSetting8021x:ca-cert property. Only makes sense if the certificate
    /// is stored on a PKCS#<!-- -->11 token that requires a login.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `ca-cert-password-flags`
    ///  Flags indicating how to handle the #NMSetting8021x:ca-cert-password property.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `ca-path`
    ///  UTF-8 encoded path to a directory containing PEM or DER formatted
    /// certificates to be added to the verification chain in addition to the
    /// certificate specified in the #NMSetting8021x:ca-cert property.
    ///
    /// If NMSetting8021x:system-ca-certs is enabled and the built-in CA
    /// path is an existing directory, then this setting is ignored.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `client-cert`
    ///  Contains the client certificate if used by the EAP method specified in
    /// the #NMSetting8021x:eap property.
    ///
    /// Certificate data is specified using a "scheme"; two are currently
    /// supported: blob and path. When using the blob scheme (which is backwards
    /// compatible with NM 0.7.x) this property should be set to the
    /// certificate's DER encoded data. When using the path scheme, this property
    /// should be set to the full UTF-8 encoded path of the certificate, prefixed
    /// with the string "file://" and ending with a terminating NUL byte.
    ///
    /// Setting this property directly is discouraged; use the
    /// nm_setting_802_1x_set_client_cert() function instead.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `client-cert-password`
    ///  The password used to access the client certificate stored in
    /// #NMSetting8021x:client-cert property. Only makes sense if the certificate
    /// is stored on a PKCS#<!-- -->11 token that requires a login.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `client-cert-password-flags`
    ///  Flags indicating how to handle the #NMSetting8021x:client-cert-password property.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `domain-match`
    ///  Constraint for server domain name. If set, this list of FQDNs is used as
    /// a match requirement for dNSName element(s) of the certificate presented
    /// by the authentication server.  If a matching dNSName is found, this
    /// constraint is met.  If no dNSName values are present, this constraint is
    /// matched against SubjectName CN using the same comparison.
    /// Multiple valid FQDNs can be passed as a ";" delimited list.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `domain-suffix-match`
    ///  Constraint for server domain name. If set, this FQDN is used as a suffix
    /// match requirement for dNSName element(s) of the certificate presented by
    /// the authentication server.  If a matching dNSName is found, this
    /// constraint is met.  If no dNSName values are present, this constraint is
    /// matched against SubjectName CN using same suffix match comparison.
    /// Since version 1.24, multiple valid FQDNs can be passed as a ";" delimited
    /// list.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `eap`
    ///  The allowed EAP method to be used when authenticating to the network with
    /// 802.1x.  Valid methods are: "leap", "md5", "tls", "peap", "ttls", "pwd",
    /// and "fast".  Each method requires different configuration using the
    /// properties of this setting; refer to wpa_supplicant documentation for the
    /// allowed combinations.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `identity`
    ///  Identity string for EAP authentication methods.  Often the user's user or
    /// login name.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `openssl-ciphers`
    ///  Define openssl_ciphers for wpa_supplicant. Openssl sometimes moves ciphers
    /// among SECLEVELs, thus compiled-in default value in wpa_supplicant
    /// (as modified by some linux distributions) sometimes prevents
    /// to connect to old servers that do not support new protocols.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `optional`
    ///  Whether the 802.1X authentication is optional. If [`true`], the activation
    /// will continue even after a timeout or an authentication failure. Setting
    /// the property to [`true`] is currently allowed only for Ethernet connections.
    /// If set to [`false`], the activation can continue only after a successful
    /// authentication.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `pac-file`
    ///  UTF-8 encoded file path containing PAC for EAP-FAST.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `password`
    ///  UTF-8 encoded password used for EAP authentication methods. If both the
    /// #NMSetting8021x:password property and the #NMSetting8021x:password-raw
    /// property are specified, #NMSetting8021x:password is preferred.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `password-flags`
    ///  Flags indicating how to handle the #NMSetting8021x:password property.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `password-raw`
    ///  Password used for EAP authentication methods, given as a byte array to
    /// allow passwords in other encodings than UTF-8 to be used. If both the
    /// #NMSetting8021x:password property and the #NMSetting8021x:password-raw
    /// property are specified, #NMSetting8021x:password is preferred.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `password-raw-flags`
    ///  Flags indicating how to handle the #NMSetting8021x:password-raw property.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `phase1-auth-flags`
    ///  Specifies authentication flags to use in "phase 1" outer
    /// authentication using #NMSetting8021xAuthFlags options.
    /// The individual TLS versions can be explicitly disabled. TLS time checks
    /// can be also disabled. If a certain TLS disable flag is not
    /// set, it is up to the supplicant to allow or forbid it. The TLS options
    /// map to tls_disable_tlsv1_x and tls_disable_time_checks settings.
    /// See the wpa_supplicant documentation for more details.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `phase1-fast-provisioning`
    ///  Enables or disables in-line provisioning of EAP-FAST credentials when
    /// FAST is specified as the EAP method in the #NMSetting8021x:eap property.
    /// Recognized values are "0" (disabled), "1" (allow unauthenticated
    /// provisioning), "2" (allow authenticated provisioning), and "3" (allow
    /// both authenticated and unauthenticated provisioning).  See the
    /// wpa_supplicant documentation for more details.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `phase1-peaplabel`
    ///  Forces use of the new PEAP label during key derivation.  Some RADIUS
    /// servers may require forcing the new PEAP label to interoperate with
    /// PEAPv1.  Set to "1" to force use of the new PEAP label.  See the
    /// wpa_supplicant documentation for more details.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `phase1-peapver`
    ///  Forces which PEAP version is used when PEAP is set as the EAP method in
    /// the #NMSetting8021x:eap property.  When unset, the version reported by
    /// the server will be used.  Sometimes when using older RADIUS servers, it
    /// is necessary to force the client to use a particular PEAP version.  To do
    /// so, this property may be set to "0" or "1" to force that specific PEAP
    /// version.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `phase2-altsubject-matches`
    ///  List of strings to be matched against the altSubjectName of the
    /// certificate presented by the authentication server during the inner
    /// "phase 2" authentication. If the list is empty, no verification of the
    /// server certificate's altSubjectName is performed.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `phase2-auth`
    ///  Specifies the allowed "phase 2" inner authentication method when an EAP
    /// method that uses an inner TLS tunnel is specified in the #NMSetting8021x:eap
    /// property.  For TTLS this property selects one of the supported non-EAP
    /// inner methods: "pap", "chap", "mschap", "mschapv2" while
    /// #NMSetting8021x:phase2-autheap selects an EAP inner method.  For PEAP
    /// this selects an inner EAP method, one of: "gtc", "otp", "md5" and "tls".
    /// Each "phase 2" inner method requires specific parameters for successful
    /// authentication; see the wpa_supplicant documentation for more details.
    /// Both #NMSetting8021x:phase2-auth and #NMSetting8021x:phase2-autheap cannot
    /// be specified.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `phase2-autheap`
    ///  Specifies the allowed "phase 2" inner EAP-based authentication method
    /// when TTLS is specified in the #NMSetting8021x:eap property.  Recognized
    /// EAP-based "phase 2" methods are "md5", "mschapv2", "otp", "gtc", and
    /// "tls". Each "phase 2" inner method requires specific parameters for
    /// successful authentication; see the wpa_supplicant documentation for
    /// more details.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `phase2-ca-cert`
    ///  Contains the "phase 2" CA certificate if used by the EAP method specified
    /// in the #NMSetting8021x:phase2-auth or #NMSetting8021x:phase2-autheap
    /// properties.
    ///
    /// Certificate data is specified using a "scheme"; three are currently
    /// supported: blob, path and pkcs#11 URL. When using the blob scheme this property
    /// should be set to the certificate's DER encoded data. When using the path
    /// scheme, this property should be set to the full UTF-8 encoded path of the
    /// certificate, prefixed with the string "file://" and ending with a terminating
    /// NUL byte.
    /// This property can be unset even if the EAP method supports CA certificates,
    /// but this allows man-in-the-middle attacks and is NOT recommended.
    ///
    /// Note that enabling NMSetting8021x:system-ca-certs will override this
    /// setting to use the built-in path, if the built-in path is not a directory.
    ///
    /// Setting this property directly is discouraged; use the
    /// nm_setting_802_1x_set_phase2_ca_cert() function instead.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `phase2-ca-cert-password`
    ///  The password used to access the "phase2" CA certificate stored in
    /// #NMSetting8021x:phase2-ca-cert property. Only makes sense if the certificate
    /// is stored on a PKCS#<!-- -->11 token that requires a login.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `phase2-ca-cert-password-flags`
    ///  Flags indicating how to handle the #NMSetting8021x:phase2-ca-cert-password property.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `phase2-ca-path`
    ///  UTF-8 encoded path to a directory containing PEM or DER formatted
    /// certificates to be added to the verification chain in addition to the
    /// certificate specified in the #NMSetting8021x:phase2-ca-cert property.
    ///
    /// If NMSetting8021x:system-ca-certs is enabled and the built-in CA
    /// path is an existing directory, then this setting is ignored.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `phase2-client-cert`
    ///  Contains the "phase 2" client certificate if used by the EAP method
    /// specified in the #NMSetting8021x:phase2-auth or
    /// #NMSetting8021x:phase2-autheap properties.
    ///
    /// Certificate data is specified using a "scheme"; two are currently
    /// supported: blob and path. When using the blob scheme (which is backwards
    /// compatible with NM 0.7.x) this property should be set to the
    /// certificate's DER encoded data. When using the path scheme, this property
    /// should be set to the full UTF-8 encoded path of the certificate, prefixed
    /// with the string "file://" and ending with a terminating NUL byte. This
    /// property can be unset even if the EAP method supports CA certificates,
    /// but this allows man-in-the-middle attacks and is NOT recommended.
    ///
    /// Setting this property directly is discouraged; use the
    /// nm_setting_802_1x_set_phase2_client_cert() function instead.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `phase2-client-cert-password`
    ///  The password used to access the "phase2" client certificate stored in
    /// #NMSetting8021x:phase2-client-cert property. Only makes sense if the certificate
    /// is stored on a PKCS#<!-- -->11 token that requires a login.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `phase2-client-cert-password-flags`
    ///  Flags indicating how to handle the #NMSetting8021x:phase2-client-cert-password property.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `phase2-domain-match`
    ///  Constraint for server domain name. If set, this list of FQDNs is used as
    /// a match requirement for dNSName element(s) of the certificate presented
    /// by the authentication server during the inner "phase 2" authentication.
    /// If a matching dNSName is found, this constraint is met.  If no dNSName
    /// values are present, this constraint is matched against SubjectName CN
    /// using the same comparison.
    /// Multiple valid FQDNs can be passed as a ";" delimited list.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `phase2-domain-suffix-match`
    ///  Constraint for server domain name. If set, this FQDN is used as a suffix
    /// match requirement for dNSName element(s) of the certificate presented by
    /// the authentication server during the inner "phase 2" authentication.  If
    /// a matching dNSName is found, this constraint is met.  If no dNSName
    /// values are present, this constraint is matched against SubjectName CN
    /// using same suffix match comparison.
    /// Since version 1.24, multiple valid FQDNs can be passed as a ";" delimited
    /// list.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `phase2-private-key`
    ///  Contains the "phase 2" inner private key when the
    /// #NMSetting8021x:phase2-auth or #NMSetting8021x:phase2-autheap property is
    /// set to "tls".
    ///
    /// Key data is specified using a "scheme"; two are currently supported: blob
    /// and path. When using the blob scheme and private keys, this property
    /// should be set to the key's encrypted PEM encoded data. When using private
    /// keys with the path scheme, this property should be set to the full UTF-8
    /// encoded path of the key, prefixed with the string "file://" and ending
    /// with a terminating NUL byte. When using PKCS#<!-- -->12 format private
    /// keys and the blob scheme, this property should be set to the
    /// PKCS#<!-- -->12 data and the #NMSetting8021x:phase2-private-key-password
    /// property must be set to password used to decrypt the PKCS#<!-- -->12
    /// certificate and key. When using PKCS#<!-- -->12 files and the path
    /// scheme, this property should be set to the full UTF-8 encoded path of the
    /// key, prefixed with the string "file://" and ending with a terminating
    /// NUL byte, and as with the blob scheme the
    /// #NMSetting8021x:phase2-private-key-password property must be set to the
    /// password used to decode the PKCS#<!-- -->12 private key and certificate.
    ///
    /// Setting this property directly is discouraged; use the
    /// nm_setting_802_1x_set_phase2_private_key() function instead.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `phase2-private-key-password`
    ///  The password used to decrypt the "phase 2" private key specified in the
    /// #NMSetting8021x:phase2-private-key property when the private key either
    /// uses the path scheme, or is a PKCS#<!-- -->12 format key.  Setting this
    /// property directly is not generally necessary except when returning
    /// secrets to NetworkManager; it is generally set automatically when setting
    /// the private key by the nm_setting_802_1x_set_phase2_private_key()
    /// function.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `phase2-private-key-password-flags`
    ///  Flags indicating how to handle the
    /// #NMSetting8021x:phase2-private-key-password property.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `phase2-subject-match`
    ///  Substring to be matched against the subject of the certificate presented
    /// by the authentication server during the inner "phase 2"
    /// authentication. When unset, no verification of the authentication server
    /// certificate's subject is performed. This property provides little security,
    /// if any, and should not be used.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `pin`
    ///  PIN used for EAP authentication methods.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `pin-flags`
    ///  Flags indicating how to handle the #NMSetting8021x:pin property.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `private-key`
    ///  Contains the private key when the #NMSetting8021x:eap property is set to
    /// "tls".
    ///
    /// Key data is specified using a "scheme"; two are currently supported: blob
    /// and path. When using the blob scheme and private keys, this property
    /// should be set to the key's encrypted PEM encoded data. When using private
    /// keys with the path scheme, this property should be set to the full UTF-8
    /// encoded path of the key, prefixed with the string "file://" and ending
    /// with a terminating NUL byte. When using PKCS#<!-- -->12 format private
    /// keys and the blob scheme, this property should be set to the
    /// PKCS#<!-- -->12 data and the #NMSetting8021x:private-key-password
    /// property must be set to password used to decrypt the PKCS#<!-- -->12
    /// certificate and key. When using PKCS#<!-- -->12 files and the path
    /// scheme, this property should be set to the full UTF-8 encoded path of the
    /// key, prefixed with the string "file://" and ending with a terminating
    /// NUL byte, and as with the blob scheme the "private-key-password" property
    /// must be set to the password used to decode the PKCS#<!-- -->12 private
    /// key and certificate.
    ///
    /// Setting this property directly is discouraged; use the
    /// nm_setting_802_1x_set_private_key() function instead.
    ///
    /// WARNING: #NMSetting8021x:private-key is not a "secret" property, and thus
    /// unencrypted private key data using the BLOB scheme may be readable by
    /// unprivileged users.  Private keys should always be encrypted with a
    /// private key password to prevent unauthorized access to unencrypted
    /// private key data.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `private-key-password`
    ///  The password used to decrypt the private key specified in the
    /// #NMSetting8021x:private-key property when the private key either uses the
    /// path scheme, or if the private key is a PKCS#<!-- -->12 format key.  Setting this
    /// property directly is not generally necessary except when returning
    /// secrets to NetworkManager; it is generally set automatically when setting
    /// the private key by the nm_setting_802_1x_set_private_key() function.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `private-key-password-flags`
    ///  Flags indicating how to handle the #NMSetting8021x:private-key-password
    /// property.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `subject-match`
    ///  Substring to be matched against the subject of the certificate presented
    /// by the authentication server. When unset, no verification of the
    /// authentication server certificate's subject is performed. This property
    /// provides little security, if any, and should not be used.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `system-ca-certs`
    ///  When [`true`], overrides the #NMSetting8021x:ca-path and
    /// #NMSetting8021x:phase2-ca-path properties using the system CA directory
    /// specified at configure time with the --system-ca-path switch.  The
    /// certificates in this directory are added to the verification chain in
    /// addition to any certificates specified by the #NMSetting8021x:ca-cert and
    /// #NMSetting8021x:phase2-ca-cert properties. If the path provided with
    /// --system-ca-path is rather a file name (bundle of trusted CA certificates),
    /// it overrides #NMSetting8021x:ca-cert and #NMSetting8021x:phase2-ca-cert
    /// properties instead (sets ca_cert/ca_cert2 options for wpa_supplicant).
    ///
    /// Readable | Writeable
    /// <details><summary><h4>Setting</h4></summary>
    ///
    ///
    /// #### `name`
    ///  The setting's name, which uniquely identifies the setting within the
    /// connection.  Each setting type has a name unique to that type, for
    /// example "ppp" or "802-11-wireless" or "802-3-ethernet".
    ///
    /// Readable
    /// </details>
    ///
    /// # Implements
    ///
    /// [`SettingExt`][trait@crate::prelude::SettingExt]
    #[doc(alias = "NMSetting8021x")]
    pub struct Setting8021x(Object<ffi::NMSetting8021x, ffi::NMSetting8021xClass>) @extends Setting;

    match fn {
        type_ => || ffi::nm_setting_802_1x_get_type(),
    }
}

impl Setting8021x {
    /// Creates a new #NMSetting8021x object with default values.
    ///
    /// # Returns
    ///
    /// the new empty #NMSetting8021x object
    #[doc(alias = "nm_setting_802_1x_new")]
    pub fn new() -> Setting8021x {
        assert_initialized_main_thread!();
        unsafe { Setting::from_glib_full(ffi::nm_setting_802_1x_new()).unsafe_cast() }
    }

    // rustdoc-stripper-ignore-next
    /// Creates a new builder-pattern struct instance to construct [`Setting8021x`] objects.
    ///
    /// This method returns an instance of [`Setting8021xBuilder`](crate::builders::Setting8021xBuilder) which can be used to create [`Setting8021x`] objects.
    pub fn builder() -> Setting8021xBuilder {
        Setting8021xBuilder::new()
    }

    /// Adds an allowed alternate subject name match.  Until at least one
    /// match is added, the altSubjectName of the remote authentication
    /// server is not verified.
    /// ## `altsubject_match`
    /// the altSubjectName to allow for this connection
    ///
    /// # Returns
    ///
    /// [`true`] if the alternative subject name match was
    ///  successfully added, [`false`] if it was already allowed.
    #[doc(alias = "nm_setting_802_1x_add_altsubject_match")]
    pub fn add_altsubject_match(&self, altsubject_match: &str) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_802_1x_add_altsubject_match(
                self.to_glib_none().0,
                altsubject_match.to_glib_none().0,
            ))
        }
    }

    /// Adds an allowed EAP method.  The setting is not valid until at least one
    /// EAP method has been added.  See #NMSetting8021x:eap property for a list of
    /// allowed EAP methods.
    /// ## `eap`
    /// the name of the EAP method to allow for this connection
    ///
    /// # Returns
    ///
    /// [`true`] if the EAP method was successfully added, [`false`] if it was
    ///  not a valid method or if it was already allowed.
    #[doc(alias = "nm_setting_802_1x_add_eap_method")]
    pub fn add_eap_method(&self, eap: &str) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_802_1x_add_eap_method(
                self.to_glib_none().0,
                eap.to_glib_none().0,
            ))
        }
    }

    /// Adds an allowed alternate subject name match for "phase 2".  Until
    /// at least one match is added, the altSubjectName of the "phase 2"
    /// remote authentication server is not verified.
    /// ## `phase2_altsubject_match`
    /// the "phase 2" altSubjectName to allow for this
    /// connection
    ///
    /// # Returns
    ///
    /// [`true`] if the "phase 2" alternative subject name match was
    ///  successfully added, [`false`] if it was already allowed.
    #[doc(alias = "nm_setting_802_1x_add_phase2_altsubject_match")]
    pub fn add_phase2_altsubject_match(&self, phase2_altsubject_match: &str) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_802_1x_add_phase2_altsubject_match(
                self.to_glib_none().0,
                phase2_altsubject_match.to_glib_none().0,
            ))
        }
    }

    /// Clears all altSubjectName matches.
    #[doc(alias = "nm_setting_802_1x_clear_altsubject_matches")]
    pub fn clear_altsubject_matches(&self) {
        unsafe {
            ffi::nm_setting_802_1x_clear_altsubject_matches(self.to_glib_none().0);
        }
    }

    /// Clears all allowed EAP methods.
    #[doc(alias = "nm_setting_802_1x_clear_eap_methods")]
    pub fn clear_eap_methods(&self) {
        unsafe {
            ffi::nm_setting_802_1x_clear_eap_methods(self.to_glib_none().0);
        }
    }

    /// Clears all "phase 2" altSubjectName matches.
    #[doc(alias = "nm_setting_802_1x_clear_phase2_altsubject_matches")]
    pub fn clear_phase2_altsubject_matches(&self) {
        unsafe {
            ffi::nm_setting_802_1x_clear_phase2_altsubject_matches(self.to_glib_none().0);
        }
    }

    /// Returns the altSubjectName match at index @i.
    /// ## `i`
    /// the zero-based index of the array of altSubjectName matches
    ///
    /// # Returns
    ///
    /// the altSubjectName match at index @i
    #[doc(alias = "nm_setting_802_1x_get_altsubject_match")]
    #[doc(alias = "get_altsubject_match")]
    pub fn altsubject_match(&self, i: u32) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_setting_802_1x_get_altsubject_match(
                self.to_glib_none().0,
                i,
            ))
        }
    }

    /// Returns the anonymous identifier used by some EAP methods (like TTLS) to
    /// authenticate the user in the outer unencrypted "phase 1" authentication.  The
    /// inner "phase 2" authentication will use the #NMSetting8021x:identity in
    /// a secure form, if applicable for that EAP method.
    ///
    /// # Returns
    ///
    /// the anonymous identifier
    #[doc(alias = "nm_setting_802_1x_get_anonymous_identity")]
    #[doc(alias = "get_anonymous_identity")]
    #[doc(alias = "anonymous-identity")]
    pub fn anonymous_identity(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_setting_802_1x_get_anonymous_identity(
                self.to_glib_none().0,
            ))
        }
    }

    /// Returns the value contained in the #NMSetting8021x:auth-timeout property.
    ///
    /// # Returns
    ///
    /// the configured authentication timeout in seconds. Zero means the
    /// global default value.
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    #[doc(alias = "nm_setting_802_1x_get_auth_timeout")]
    #[doc(alias = "get_auth_timeout")]
    #[doc(alias = "auth-timeout")]
    pub fn auth_timeout(&self) -> i32 {
        unsafe { ffi::nm_setting_802_1x_get_auth_timeout(self.to_glib_none().0) }
    }

    //#[doc(alias = "nm_setting_802_1x_get_ca_cert_blob")]
    //#[doc(alias = "get_ca_cert_blob")]
    //pub fn ca_cert_blob(&self) -> /*Ignored*/glib::Bytes {
    //    unsafe { TODO: call ffi:nm_setting_802_1x_get_ca_cert_blob() }
    //}

    ///
    /// # Returns
    ///
    /// the password used to access the CA certificate stored in
    /// #NMSetting8021x:ca-cert property. Only makes sense if the certificate
    /// is stored on a PKCS#<!-- -->11 token that requires a login.
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    #[doc(alias = "nm_setting_802_1x_get_ca_cert_password")]
    #[doc(alias = "get_ca_cert_password")]
    #[doc(alias = "ca-cert-password")]
    pub fn ca_cert_password(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_setting_802_1x_get_ca_cert_password(
                self.to_glib_none().0,
            ))
        }
    }

    ///
    /// # Returns
    ///
    /// the #NMSettingSecretFlags pertaining to the
    /// #NMSetting8021x:ca-cert-password
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    #[doc(alias = "nm_setting_802_1x_get_ca_cert_password_flags")]
    #[doc(alias = "get_ca_cert_password_flags")]
    #[doc(alias = "ca-cert-password-flags")]
    pub fn ca_cert_password_flags(&self) -> SettingSecretFlags {
        unsafe {
            from_glib(ffi::nm_setting_802_1x_get_ca_cert_password_flags(
                self.to_glib_none().0,
            ))
        }
    }

    /// Returns the CA certificate path if the CA certificate is stored using the
    /// [`Setting8021xCKScheme::Path`][crate::Setting8021xCKScheme::Path] scheme.  Not all EAP methods use a
    /// CA certificate (LEAP for example), and those that can take advantage of the
    /// CA certificate allow it to be unset.  Note that lack of a CA certificate
    /// reduces security by allowing man-in-the-middle attacks, because the identity
    /// of the network cannot be confirmed by the client.
    ///
    /// # Returns
    ///
    /// path to the CA certificate file
    #[doc(alias = "nm_setting_802_1x_get_ca_cert_path")]
    #[doc(alias = "get_ca_cert_path")]
    pub fn ca_cert_path(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_setting_802_1x_get_ca_cert_path(
                self.to_glib_none().0,
            ))
        }
    }

    /// Returns the scheme used to store the CA certificate.  If the returned scheme
    /// is [`Setting8021xCKScheme::Blob`][crate::Setting8021xCKScheme::Blob], use nm_setting_802_1x_get_ca_cert_blob();
    /// if [`Setting8021xCKScheme::Path`][crate::Setting8021xCKScheme::Path], use nm_setting_802_1x_get_ca_cert_path();
    /// if [`Setting8021xCKScheme::Pkcs11`][crate::Setting8021xCKScheme::Pkcs11], use nm_setting_802_1x_get_ca_cert_uri().
    ///
    /// # Returns
    ///
    /// scheme used to store the CA certificate (blob or path)
    #[doc(alias = "nm_setting_802_1x_get_ca_cert_scheme")]
    #[doc(alias = "get_ca_cert_scheme")]
    pub fn ca_cert_scheme(&self) -> Setting8021xCKScheme {
        unsafe {
            from_glib(ffi::nm_setting_802_1x_get_ca_cert_scheme(
                self.to_glib_none().0,
            ))
        }
    }

    /// Returns the CA certificate URI analogously to
    /// nm_setting_802_1x_get_ca_cert_blob() and
    /// nm_setting_802_1x_get_ca_cert_path().
    ///
    /// Currently, it's limited to PKCS#11 URIs ('pkcs11' scheme as defined by RFC
    /// 7512), but may be extended to other schemes in future (such as 'file' URIs
    /// for local files and 'data' URIs for inline certificate data).
    ///
    /// # Returns
    ///
    /// the URI string
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    #[doc(alias = "nm_setting_802_1x_get_ca_cert_uri")]
    #[doc(alias = "get_ca_cert_uri")]
    pub fn ca_cert_uri(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_setting_802_1x_get_ca_cert_uri(
                self.to_glib_none().0,
            ))
        }
    }

    /// Returns the path of the CA certificate directory if previously set.  Systems
    /// will often have a directory that contains multiple individual CA certificates
    /// which the supplicant can then add to the verification chain.  This may be
    /// used in addition to the #NMSetting8021x:ca-cert property to add more CA
    /// certificates for verifying the network to client.
    ///
    /// # Returns
    ///
    /// the CA certificate directory path
    #[doc(alias = "nm_setting_802_1x_get_ca_path")]
    #[doc(alias = "get_ca_path")]
    #[doc(alias = "ca-path")]
    pub fn ca_path(&self) -> glib::GString {
        unsafe { from_glib_none(ffi::nm_setting_802_1x_get_ca_path(self.to_glib_none().0)) }
    }

    //#[doc(alias = "nm_setting_802_1x_get_client_cert_blob")]
    //#[doc(alias = "get_client_cert_blob")]
    //pub fn client_cert_blob(&self) -> /*Ignored*/glib::Bytes {
    //    unsafe { TODO: call ffi:nm_setting_802_1x_get_client_cert_blob() }
    //}

    ///
    /// # Returns
    ///
    /// the password used to access the client certificate stored in
    /// #NMSetting8021x:client-cert property. Only makes sense if the certificate
    /// is stored on a PKCS#<!-- -->11 token that requires a login.
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    #[doc(alias = "nm_setting_802_1x_get_client_cert_password")]
    #[doc(alias = "get_client_cert_password")]
    #[doc(alias = "client-cert-password")]
    pub fn client_cert_password(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_setting_802_1x_get_client_cert_password(
                self.to_glib_none().0,
            ))
        }
    }

    ///
    /// # Returns
    ///
    /// the #NMSettingSecretFlags pertaining to the
    /// #NMSetting8021x:client-cert-password
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    #[doc(alias = "nm_setting_802_1x_get_client_cert_password_flags")]
    #[doc(alias = "get_client_cert_password_flags")]
    #[doc(alias = "client-cert-password-flags")]
    pub fn client_cert_password_flags(&self) -> SettingSecretFlags {
        unsafe {
            from_glib(ffi::nm_setting_802_1x_get_client_cert_password_flags(
                self.to_glib_none().0,
            ))
        }
    }

    /// Client certificates are used to identify the connecting client to the network
    /// when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
    /// authentication method.
    ///
    /// # Returns
    ///
    /// path to the client certificate file
    #[doc(alias = "nm_setting_802_1x_get_client_cert_path")]
    #[doc(alias = "get_client_cert_path")]
    pub fn client_cert_path(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_setting_802_1x_get_client_cert_path(
                self.to_glib_none().0,
            ))
        }
    }

    /// Returns the scheme used to store the client certificate.  If the returned scheme
    /// is [`Setting8021xCKScheme::Blob`][crate::Setting8021xCKScheme::Blob], use nm_setting_802_1x_get_client_cert_blob();
    /// if [`Setting8021xCKScheme::Path`][crate::Setting8021xCKScheme::Path], use nm_setting_802_1x_get_client_cert_path();
    /// if [`Setting8021xCKScheme::Pkcs11`][crate::Setting8021xCKScheme::Pkcs11], use nm_setting_802_1x_get_client_cert_uri().
    ///
    /// # Returns
    ///
    /// scheme used to store the client certificate (blob or path)
    #[doc(alias = "nm_setting_802_1x_get_client_cert_scheme")]
    #[doc(alias = "get_client_cert_scheme")]
    pub fn client_cert_scheme(&self) -> Setting8021xCKScheme {
        unsafe {
            from_glib(ffi::nm_setting_802_1x_get_client_cert_scheme(
                self.to_glib_none().0,
            ))
        }
    }

    /// Returns the client certificate URI analogously to
    /// nm_setting_802_1x_get_client_cert_blob() and
    /// nm_setting_802_1x_get_client_cert_path().
    ///
    /// Currently, it's limited to PKCS#11 URIs ('pkcs11' scheme as defined by RFC
    /// 7512), but may be extended to other schemes in future (such as 'file' URIs
    /// for local files and 'data' URIs for inline certificate data).
    ///
    /// # Returns
    ///
    /// the URI string
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    #[doc(alias = "nm_setting_802_1x_get_client_cert_uri")]
    #[doc(alias = "get_client_cert_uri")]
    pub fn client_cert_uri(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_setting_802_1x_get_client_cert_uri(
                self.to_glib_none().0,
            ))
        }
    }

    ///
    /// # Returns
    ///
    /// the #NMSetting8021x:domain-match property.
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    #[doc(alias = "nm_setting_802_1x_get_domain_match")]
    #[doc(alias = "get_domain_match")]
    #[doc(alias = "domain-match")]
    pub fn domain_match(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_setting_802_1x_get_domain_match(
                self.to_glib_none().0,
            ))
        }
    }

    ///
    /// # Returns
    ///
    /// the #NMSetting8021x:domain-suffix-match property.
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    #[doc(alias = "nm_setting_802_1x_get_domain_suffix_match")]
    #[doc(alias = "get_domain_suffix_match")]
    #[doc(alias = "domain-suffix-match")]
    pub fn domain_suffix_match(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_setting_802_1x_get_domain_suffix_match(
                self.to_glib_none().0,
            ))
        }
    }

    /// Returns the name of the allowed EAP method at index @i.
    /// ## `i`
    /// the index of the EAP method name to return
    ///
    /// # Returns
    ///
    /// the name of the allowed EAP method at index @i
    #[doc(alias = "nm_setting_802_1x_get_eap_method")]
    #[doc(alias = "get_eap_method")]
    pub fn eap_method(&self, i: u32) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_setting_802_1x_get_eap_method(
                self.to_glib_none().0,
                i,
            ))
        }
    }

    /// Returns the identifier used by some EAP methods (like TLS) to
    /// authenticate the user.  Often this is a username or login name.
    ///
    /// # Returns
    ///
    /// the user identifier
    #[doc(alias = "nm_setting_802_1x_get_identity")]
    #[doc(alias = "get_identity")]
    pub fn identity(&self) -> glib::GString {
        unsafe { from_glib_none(ffi::nm_setting_802_1x_get_identity(self.to_glib_none().0)) }
    }

    /// Returns the number of entries in the
    /// #NMSetting8021x:altsubject-matches property of this setting.
    ///
    /// # Returns
    ///
    /// the number of altsubject-matches entries.
    #[doc(alias = "nm_setting_802_1x_get_num_altsubject_matches")]
    #[doc(alias = "get_num_altsubject_matches")]
    pub fn num_altsubject_matches(&self) -> u32 {
        unsafe { ffi::nm_setting_802_1x_get_num_altsubject_matches(self.to_glib_none().0) }
    }

    /// Returns the number of eap methods allowed for use when connecting to the
    /// network.  Generally only one EAP method is used.  Use the functions
    /// nm_setting_802_1x_get_eap_method(), nm_setting_802_1x_add_eap_method(),
    /// and nm_setting_802_1x_remove_eap_method() for adding, removing, and retrieving
    /// allowed EAP methods.
    ///
    /// # Returns
    ///
    /// the number of allowed EAP methods
    #[doc(alias = "nm_setting_802_1x_get_num_eap_methods")]
    #[doc(alias = "get_num_eap_methods")]
    pub fn num_eap_methods(&self) -> u32 {
        unsafe { ffi::nm_setting_802_1x_get_num_eap_methods(self.to_glib_none().0) }
    }

    /// Returns the number of entries in the
    /// #NMSetting8021x:phase2-altsubject-matches property of this setting.
    ///
    /// # Returns
    ///
    /// the number of phase2-altsubject-matches entries.
    #[doc(alias = "nm_setting_802_1x_get_num_phase2_altsubject_matches")]
    #[doc(alias = "get_num_phase2_altsubject_matches")]
    pub fn num_phase2_altsubject_matches(&self) -> u32 {
        unsafe { ffi::nm_setting_802_1x_get_num_phase2_altsubject_matches(self.to_glib_none().0) }
    }

    /// Returns the openssl_ciphers configuration for wpa_supplicant.
    ///
    /// # Returns
    ///
    /// cipher string for tls setup in wpa_supplicant.
    #[cfg(feature = "v1_48")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_48")))]
    #[doc(alias = "nm_setting_802_1x_get_openssl_ciphers")]
    #[doc(alias = "get_openssl_ciphers")]
    #[doc(alias = "openssl-ciphers")]
    pub fn openssl_ciphers(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_setting_802_1x_get_openssl_ciphers(
                self.to_glib_none().0,
            ))
        }
    }

    /// Returns the value contained in the #NMSetting8021x:optional property.
    ///
    /// # Returns
    ///
    /// [`true`] if the activation should proceed even when the 802.1X
    ///     authentication fails; [`false`] otherwise
    #[cfg(feature = "v1_22")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
    #[doc(alias = "nm_setting_802_1x_get_optional")]
    #[doc(alias = "get_optional")]
    #[doc(alias = "optional")]
    pub fn is_optional(&self) -> bool {
        unsafe { from_glib(ffi::nm_setting_802_1x_get_optional(self.to_glib_none().0)) }
    }

    /// Returns the file containing PAC credentials used by EAP-FAST method.
    ///
    /// # Returns
    ///
    /// the PAC file
    #[doc(alias = "nm_setting_802_1x_get_pac_file")]
    #[doc(alias = "get_pac_file")]
    #[doc(alias = "pac-file")]
    pub fn pac_file(&self) -> glib::GString {
        unsafe { from_glib_none(ffi::nm_setting_802_1x_get_pac_file(self.to_glib_none().0)) }
    }

    ///
    /// # Returns
    ///
    /// the password used by the authentication method, if any, as specified
    ///   by the #NMSetting8021x:password property
    #[doc(alias = "nm_setting_802_1x_get_password")]
    #[doc(alias = "get_password")]
    pub fn password(&self) -> glib::GString {
        unsafe { from_glib_none(ffi::nm_setting_802_1x_get_password(self.to_glib_none().0)) }
    }

    ///
    /// # Returns
    ///
    /// the #NMSettingSecretFlags pertaining to the #NMSetting8021x:password
    #[doc(alias = "nm_setting_802_1x_get_password_flags")]
    #[doc(alias = "get_password_flags")]
    #[doc(alias = "password-flags")]
    pub fn password_flags(&self) -> SettingSecretFlags {
        unsafe {
            from_glib(ffi::nm_setting_802_1x_get_password_flags(
                self.to_glib_none().0,
            ))
        }
    }

    //#[doc(alias = "nm_setting_802_1x_get_password_raw")]
    //#[doc(alias = "get_password_raw")]
    //#[doc(alias = "password-raw")]
    //pub fn password_raw(&self) -> /*Ignored*/glib::Bytes {
    //    unsafe { TODO: call ffi:nm_setting_802_1x_get_password_raw() }
    //}

    ///
    /// # Returns
    ///
    /// the #NMSettingSecretFlags pertaining to the
    ///   #NMSetting8021x:password-raw
    #[doc(alias = "nm_setting_802_1x_get_password_raw_flags")]
    #[doc(alias = "get_password_raw_flags")]
    #[doc(alias = "password-raw-flags")]
    pub fn password_raw_flags(&self) -> SettingSecretFlags {
        unsafe {
            from_glib(ffi::nm_setting_802_1x_get_password_raw_flags(
                self.to_glib_none().0,
            ))
        }
    }

    ///
    /// # Returns
    ///
    /// the authentication flags for "phase 1".
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    #[doc(alias = "nm_setting_802_1x_get_phase1_auth_flags")]
    #[doc(alias = "get_phase1_auth_flags")]
    #[doc(alias = "phase1-auth-flags")]
    pub fn phase1_auth_flags(&self) -> Setting8021xAuthFlags {
        unsafe {
            from_glib(ffi::nm_setting_802_1x_get_phase1_auth_flags(
                self.to_glib_none().0,
            ))
        }
    }

    ///
    /// # Returns
    ///
    /// whether "phase 1" PEAP fast provisioning should be used, as specified
    ///  by the #NMSetting8021x:phase1-fast-provisioning property.  See the
    ///  wpa_supplicant documentation for more details.
    #[doc(alias = "nm_setting_802_1x_get_phase1_fast_provisioning")]
    #[doc(alias = "get_phase1_fast_provisioning")]
    #[doc(alias = "phase1-fast-provisioning")]
    pub fn phase1_fast_provisioning(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_setting_802_1x_get_phase1_fast_provisioning(
                self.to_glib_none().0,
            ))
        }
    }

    ///
    /// # Returns
    ///
    /// whether the "phase 1" PEAP label is new-style or old-style, to be
    ///  used when authenticating with EAP-PEAP, as contained in the
    ///  #NMSetting8021x:phase1-peaplabel property.  Valid values are [`None`] (unset),
    ///  "0" (use old-style label), and "1" (use new-style label).  See the
    ///  wpa_supplicant documentation for more details.
    #[doc(alias = "nm_setting_802_1x_get_phase1_peaplabel")]
    #[doc(alias = "get_phase1_peaplabel")]
    #[doc(alias = "phase1-peaplabel")]
    pub fn phase1_peaplabel(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_setting_802_1x_get_phase1_peaplabel(
                self.to_glib_none().0,
            ))
        }
    }

    ///
    /// # Returns
    ///
    /// the "phase 1" PEAP version to be used when authenticating with
    ///  EAP-PEAP as contained in the #NMSetting8021x:phase1-peapver property.  Valid
    ///  values are [`None`] (unset), "0" (PEAP version 0), and "1" (PEAP version 1).
    #[doc(alias = "nm_setting_802_1x_get_phase1_peapver")]
    #[doc(alias = "get_phase1_peapver")]
    #[doc(alias = "phase1-peapver")]
    pub fn phase1_peapver(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_setting_802_1x_get_phase1_peapver(
                self.to_glib_none().0,
            ))
        }
    }

    /// Returns the "phase 2" altSubjectName match at index @i.
    /// ## `i`
    /// the zero-based index of the array of "phase 2" altSubjectName matches
    ///
    /// # Returns
    ///
    /// the "phase 2" altSubjectName match at index @i
    #[doc(alias = "nm_setting_802_1x_get_phase2_altsubject_match")]
    #[doc(alias = "get_phase2_altsubject_match")]
    pub fn phase2_altsubject_match(&self, i: u32) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_setting_802_1x_get_phase2_altsubject_match(
                self.to_glib_none().0,
                i,
            ))
        }
    }

    ///
    /// # Returns
    ///
    /// the "phase 2" non-EAP (ex MD5) allowed authentication method as
    ///   specified by the #NMSetting8021x:phase2-auth property.
    #[doc(alias = "nm_setting_802_1x_get_phase2_auth")]
    #[doc(alias = "get_phase2_auth")]
    #[doc(alias = "phase2-auth")]
    pub fn phase2_auth(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_setting_802_1x_get_phase2_auth(
                self.to_glib_none().0,
            ))
        }
    }

    ///
    /// # Returns
    ///
    /// the "phase 2" EAP-based (ex TLS) allowed authentication method as
    ///   specified by the #NMSetting8021x:phase2-autheap property.
    #[doc(alias = "nm_setting_802_1x_get_phase2_autheap")]
    #[doc(alias = "get_phase2_autheap")]
    #[doc(alias = "phase2-autheap")]
    pub fn phase2_autheap(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_setting_802_1x_get_phase2_autheap(
                self.to_glib_none().0,
            ))
        }
    }

    //#[doc(alias = "nm_setting_802_1x_get_phase2_ca_cert_blob")]
    //#[doc(alias = "get_phase2_ca_cert_blob")]
    //pub fn phase2_ca_cert_blob(&self) -> /*Ignored*/glib::Bytes {
    //    unsafe { TODO: call ffi:nm_setting_802_1x_get_phase2_ca_cert_blob() }
    //}

    ///
    /// # Returns
    ///
    /// the password used to access the "phase2" CA certificate stored in
    /// #NMSetting8021x:phase2-ca-cert property. Only makes sense if the certificate
    /// is stored on a PKCS#<!-- -->11 token that requires a login.
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    #[doc(alias = "nm_setting_802_1x_get_phase2_ca_cert_password")]
    #[doc(alias = "get_phase2_ca_cert_password")]
    #[doc(alias = "phase2-ca-cert-password")]
    pub fn phase2_ca_cert_password(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_setting_802_1x_get_phase2_ca_cert_password(
                self.to_glib_none().0,
            ))
        }
    }

    ///
    /// # Returns
    ///
    /// the #NMSettingSecretFlags pertaining to the
    /// #NMSetting8021x:phase2-private-key-password
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    #[doc(alias = "nm_setting_802_1x_get_phase2_ca_cert_password_flags")]
    #[doc(alias = "get_phase2_ca_cert_password_flags")]
    #[doc(alias = "phase2-ca-cert-password-flags")]
    pub fn phase2_ca_cert_password_flags(&self) -> SettingSecretFlags {
        unsafe {
            from_glib(ffi::nm_setting_802_1x_get_phase2_ca_cert_password_flags(
                self.to_glib_none().0,
            ))
        }
    }

    /// Returns the "phase 2" CA certificate path if the CA certificate is stored
    /// using the [`Setting8021xCKScheme::Path`][crate::Setting8021xCKScheme::Path] scheme.  Not all EAP methods use
    /// a CA certificate (LEAP for example), and those that can take advantage of the
    /// CA certificate allow it to be unset.  Note that lack of a CA certificate
    /// reduces security by allowing man-in-the-middle attacks, because the identity
    /// of the network cannot be confirmed by the client.
    ///
    /// # Returns
    ///
    /// path to the "phase 2" CA certificate file
    #[doc(alias = "nm_setting_802_1x_get_phase2_ca_cert_path")]
    #[doc(alias = "get_phase2_ca_cert_path")]
    pub fn phase2_ca_cert_path(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_setting_802_1x_get_phase2_ca_cert_path(
                self.to_glib_none().0,
            ))
        }
    }

    /// Returns the scheme used to store the "phase 2" CA certificate.  If the
    /// returned scheme is [`Setting8021xCKScheme::Blob`][crate::Setting8021xCKScheme::Blob], use
    /// nm_setting_802_1x_get_ca_cert_blob(); if [`Setting8021xCKScheme::Path`][crate::Setting8021xCKScheme::Path],
    /// use nm_setting_802_1x_get_ca_cert_path(); if [`Setting8021xCKScheme::Pkcs11`][crate::Setting8021xCKScheme::Pkcs11],
    /// use nm_setting_802_1x_get_ca_cert_uri().
    ///
    /// # Returns
    ///
    /// scheme used to store the "phase 2" CA certificate (blob or path)
    #[doc(alias = "nm_setting_802_1x_get_phase2_ca_cert_scheme")]
    #[doc(alias = "get_phase2_ca_cert_scheme")]
    pub fn phase2_ca_cert_scheme(&self) -> Setting8021xCKScheme {
        unsafe {
            from_glib(ffi::nm_setting_802_1x_get_phase2_ca_cert_scheme(
                self.to_glib_none().0,
            ))
        }
    }

    /// Returns the "phase 2" CA certificate URI analogously to
    /// nm_setting_802_1x_get_phase2_ca_cert_blob() and
    /// nm_setting_802_1x_get_phase2_ca_cert_path().
    ///
    /// Currently, it's limited to PKCS#<!-- -->11 URIs ('pkcs11' scheme as defined by RFC
    /// 7512), but may be extended to other schemes in future (such as 'file' URIs
    /// for local files and 'data' URIs for inline certificate data).
    ///
    /// # Returns
    ///
    /// the URI string
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    #[doc(alias = "nm_setting_802_1x_get_phase2_ca_cert_uri")]
    #[doc(alias = "get_phase2_ca_cert_uri")]
    pub fn phase2_ca_cert_uri(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_setting_802_1x_get_phase2_ca_cert_uri(
                self.to_glib_none().0,
            ))
        }
    }

    /// Returns the path of the "phase 2" CA certificate directory if previously set.
    /// Systems will often have a directory that contains multiple individual CA
    /// certificates which the supplicant can then add to the verification chain.
    /// This may be used in addition to the #NMSetting8021x:phase2-ca-cert property
    /// to add more CA certificates for verifying the network to client.
    ///
    /// # Returns
    ///
    /// the "phase 2" CA certificate directory path
    #[doc(alias = "nm_setting_802_1x_get_phase2_ca_path")]
    #[doc(alias = "get_phase2_ca_path")]
    #[doc(alias = "phase2-ca-path")]
    pub fn phase2_ca_path(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_setting_802_1x_get_phase2_ca_path(
                self.to_glib_none().0,
            ))
        }
    }

    //#[doc(alias = "nm_setting_802_1x_get_phase2_client_cert_blob")]
    //#[doc(alias = "get_phase2_client_cert_blob")]
    //pub fn phase2_client_cert_blob(&self) -> /*Ignored*/glib::Bytes {
    //    unsafe { TODO: call ffi:nm_setting_802_1x_get_phase2_client_cert_blob() }
    //}

    ///
    /// # Returns
    ///
    /// the password used to access the "phase2" client certificate stored in
    /// #NMSetting8021x:phase2-client-cert property. Only makes sense if the certificate
    /// is stored on a PKCS#<!-- -->11 token that requires a login.
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    #[doc(alias = "nm_setting_802_1x_get_phase2_client_cert_password")]
    #[doc(alias = "get_phase2_client_cert_password")]
    #[doc(alias = "phase2-client-cert-password")]
    pub fn phase2_client_cert_password(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_setting_802_1x_get_phase2_client_cert_password(
                self.to_glib_none().0,
            ))
        }
    }

    ///
    /// # Returns
    ///
    /// the #NMSettingSecretFlags pertaining to the
    /// #NMSetting8021x:phase2-client-cert-password
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    #[doc(alias = "nm_setting_802_1x_get_phase2_client_cert_password_flags")]
    #[doc(alias = "get_phase2_client_cert_password_flags")]
    #[doc(alias = "phase2-client-cert-password-flags")]
    pub fn phase2_client_cert_password_flags(&self) -> SettingSecretFlags {
        unsafe {
            from_glib(
                ffi::nm_setting_802_1x_get_phase2_client_cert_password_flags(self.to_glib_none().0),
            )
        }
    }

    /// Client certificates are used to identify the connecting client to the network
    /// when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
    /// authentication method.
    ///
    /// # Returns
    ///
    /// path to the "phase 2" client certificate file
    #[doc(alias = "nm_setting_802_1x_get_phase2_client_cert_path")]
    #[doc(alias = "get_phase2_client_cert_path")]
    pub fn phase2_client_cert_path(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_setting_802_1x_get_phase2_client_cert_path(
                self.to_glib_none().0,
            ))
        }
    }

    /// Returns the scheme used to store the "phase 2" client certificate.  If the
    /// returned scheme is [`Setting8021xCKScheme::Blob`][crate::Setting8021xCKScheme::Blob], use
    /// nm_setting_802_1x_get_client_cert_blob(); if
    /// [`Setting8021xCKScheme::Path`][crate::Setting8021xCKScheme::Path], use
    /// nm_setting_802_1x_get_client_cert_path(); if
    /// [`Setting8021xCKScheme::Pkcs11`][crate::Setting8021xCKScheme::Pkcs11], use
    /// nm_setting_802_1x_get_client_cert_uri().
    ///
    /// # Returns
    ///
    /// scheme used to store the "phase 2" client certificate (blob or path)
    #[doc(alias = "nm_setting_802_1x_get_phase2_client_cert_scheme")]
    #[doc(alias = "get_phase2_client_cert_scheme")]
    pub fn phase2_client_cert_scheme(&self) -> Setting8021xCKScheme {
        unsafe {
            from_glib(ffi::nm_setting_802_1x_get_phase2_client_cert_scheme(
                self.to_glib_none().0,
            ))
        }
    }

    /// Returns the "phase 2" client certificate URI analogously to
    /// nm_setting_802_1x_get_phase2_ca_cert_blob() and
    /// nm_setting_802_1x_get_phase2_ca_cert_path().
    ///
    /// Currently, it's limited to PKCS#<!-- -->11 URIs ('pkcs11' scheme as defined by RFC
    /// 7512), but may be extended to other schemes in future (such as 'file' URIs
    /// for local files and 'data' URIs for inline certificate data).
    ///
    /// # Returns
    ///
    /// the URI string
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    #[doc(alias = "nm_setting_802_1x_get_phase2_client_cert_uri")]
    #[doc(alias = "get_phase2_client_cert_uri")]
    pub fn phase2_client_cert_uri(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_setting_802_1x_get_phase2_client_cert_uri(
                self.to_glib_none().0,
            ))
        }
    }

    ///
    /// # Returns
    ///
    /// the #NMSetting8021x:phase2-domain-match property.
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    #[doc(alias = "nm_setting_802_1x_get_phase2_domain_match")]
    #[doc(alias = "get_phase2_domain_match")]
    #[doc(alias = "phase2-domain-match")]
    pub fn phase2_domain_match(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_setting_802_1x_get_phase2_domain_match(
                self.to_glib_none().0,
            ))
        }
    }

    ///
    /// # Returns
    ///
    /// the #NMSetting8021x:phase2-domain-suffix-match property.
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    #[doc(alias = "nm_setting_802_1x_get_phase2_domain_suffix_match")]
    #[doc(alias = "get_phase2_domain_suffix_match")]
    #[doc(alias = "phase2-domain-suffix-match")]
    pub fn phase2_domain_suffix_match(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_setting_802_1x_get_phase2_domain_suffix_match(
                self.to_glib_none().0,
            ))
        }
    }

    //#[doc(alias = "nm_setting_802_1x_get_phase2_private_key_blob")]
    //#[doc(alias = "get_phase2_private_key_blob")]
    //pub fn phase2_private_key_blob(&self) -> /*Ignored*/glib::Bytes {
    //    unsafe { TODO: call ffi:nm_setting_802_1x_get_phase2_private_key_blob() }
    //}

    ///
    /// # Returns
    ///
    /// the data format of the "phase 2" private key data stored in the
    ///   #NMSetting8021x:phase2-private-key property
    #[doc(alias = "nm_setting_802_1x_get_phase2_private_key_format")]
    #[doc(alias = "get_phase2_private_key_format")]
    pub fn phase2_private_key_format(&self) -> Setting8021xCKFormat {
        unsafe {
            from_glib(ffi::nm_setting_802_1x_get_phase2_private_key_format(
                self.to_glib_none().0,
            ))
        }
    }

    ///
    /// # Returns
    ///
    /// the private key password used to decrypt the private key if
    ///  previously set with nm_setting_802_1x_set_phase2_private_key() or the
    ///  #NMSetting8021x:phase2-private-key-password property.
    #[doc(alias = "nm_setting_802_1x_get_phase2_private_key_password")]
    #[doc(alias = "get_phase2_private_key_password")]
    #[doc(alias = "phase2-private-key-password")]
    pub fn phase2_private_key_password(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_setting_802_1x_get_phase2_private_key_password(
                self.to_glib_none().0,
            ))
        }
    }

    ///
    /// # Returns
    ///
    /// the #NMSettingSecretFlags pertaining to the
    /// #NMSetting8021x:phase2-private-key-password
    #[doc(alias = "nm_setting_802_1x_get_phase2_private_key_password_flags")]
    #[doc(alias = "get_phase2_private_key_password_flags")]
    #[doc(alias = "phase2-private-key-password-flags")]
    pub fn phase2_private_key_password_flags(&self) -> SettingSecretFlags {
        unsafe {
            from_glib(
                ffi::nm_setting_802_1x_get_phase2_private_key_password_flags(self.to_glib_none().0),
            )
        }
    }

    /// Private keys are used to authenticate the connecting client to the network
    /// when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
    /// authentication method.
    ///
    /// # Returns
    ///
    /// path to the "phase 2" private key file
    #[doc(alias = "nm_setting_802_1x_get_phase2_private_key_path")]
    #[doc(alias = "get_phase2_private_key_path")]
    pub fn phase2_private_key_path(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_setting_802_1x_get_phase2_private_key_path(
                self.to_glib_none().0,
            ))
        }
    }

    /// Returns the scheme used to store the "phase 2" private key.  If the returned
    /// scheme is [`Setting8021xCKScheme::Blob`][crate::Setting8021xCKScheme::Blob], use
    /// nm_setting_802_1x_get_client_cert_blob(); if
    /// [`Setting8021xCKScheme::Path`][crate::Setting8021xCKScheme::Path], use
    /// nm_setting_802_1x_get_client_cert_path(); if
    /// [`Setting8021xCKScheme::Pkcs11`][crate::Setting8021xCKScheme::Pkcs11], use
    /// nm_setting_802_1x_get_client_cert_uri().
    ///
    /// # Returns
    ///
    /// scheme used to store the "phase 2" private key (blob or path)
    #[doc(alias = "nm_setting_802_1x_get_phase2_private_key_scheme")]
    #[doc(alias = "get_phase2_private_key_scheme")]
    pub fn phase2_private_key_scheme(&self) -> Setting8021xCKScheme {
        unsafe {
            from_glib(ffi::nm_setting_802_1x_get_phase2_private_key_scheme(
                self.to_glib_none().0,
            ))
        }
    }

    /// Returns the "phase 2" private key URI analogously to
    /// nm_setting_802_1x_get_phase2_private_key_blob() and
    /// nm_setting_802_1x_get_phase2_private_key_path().
    ///
    /// Currently, it's limited to PKCS#<!-- -->11 URIs ('pkcs11' scheme as defined by RFC
    /// 7512), but may be extended to other schemes in future (such as 'file' URIs
    /// for local files and 'data' URIs for inline certificate data).
    ///
    /// # Returns
    ///
    /// the URI string
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    #[doc(alias = "nm_setting_802_1x_get_phase2_private_key_uri")]
    #[doc(alias = "get_phase2_private_key_uri")]
    pub fn phase2_private_key_uri(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_setting_802_1x_get_phase2_private_key_uri(
                self.to_glib_none().0,
            ))
        }
    }

    ///
    /// # Returns
    ///
    /// the #NMSetting8021x:phase2-subject-match property. This is
    /// the substring to be matched against the subject of the "phase 2"
    /// authentication server certificate, or [`None`] no subject verification
    /// is to be performed.
    #[doc(alias = "nm_setting_802_1x_get_phase2_subject_match")]
    #[doc(alias = "get_phase2_subject_match")]
    #[doc(alias = "phase2-subject-match")]
    pub fn phase2_subject_match(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_setting_802_1x_get_phase2_subject_match(
                self.to_glib_none().0,
            ))
        }
    }

    ///
    /// # Returns
    ///
    /// the PIN used by the authentication method, if any, as specified
    ///   by the #NMSetting8021x:pin property
    #[doc(alias = "nm_setting_802_1x_get_pin")]
    #[doc(alias = "get_pin")]
    pub fn pin(&self) -> glib::GString {
        unsafe { from_glib_none(ffi::nm_setting_802_1x_get_pin(self.to_glib_none().0)) }
    }

    ///
    /// # Returns
    ///
    /// the #NMSettingSecretFlags pertaining to the
    /// #NMSetting8021x:pin
    #[doc(alias = "nm_setting_802_1x_get_pin_flags")]
    #[doc(alias = "get_pin_flags")]
    #[doc(alias = "pin-flags")]
    pub fn pin_flags(&self) -> SettingSecretFlags {
        unsafe { from_glib(ffi::nm_setting_802_1x_get_pin_flags(self.to_glib_none().0)) }
    }

    //#[doc(alias = "nm_setting_802_1x_get_private_key_blob")]
    //#[doc(alias = "get_private_key_blob")]
    //pub fn private_key_blob(&self) -> /*Ignored*/glib::Bytes {
    //    unsafe { TODO: call ffi:nm_setting_802_1x_get_private_key_blob() }
    //}

    ///
    /// # Returns
    ///
    /// the data format of the private key data stored in the
    ///   #NMSetting8021x:private-key property
    #[doc(alias = "nm_setting_802_1x_get_private_key_format")]
    #[doc(alias = "get_private_key_format")]
    pub fn private_key_format(&self) -> Setting8021xCKFormat {
        unsafe {
            from_glib(ffi::nm_setting_802_1x_get_private_key_format(
                self.to_glib_none().0,
            ))
        }
    }

    ///
    /// # Returns
    ///
    /// the private key password used to decrypt the private key if
    ///  previously set with nm_setting_802_1x_set_private_key(), or the
    ///  #NMSetting8021x:private-key-password property.
    #[doc(alias = "nm_setting_802_1x_get_private_key_password")]
    #[doc(alias = "get_private_key_password")]
    #[doc(alias = "private-key-password")]
    pub fn private_key_password(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_setting_802_1x_get_private_key_password(
                self.to_glib_none().0,
            ))
        }
    }

    ///
    /// # Returns
    ///
    /// the #NMSettingSecretFlags pertaining to the
    /// #NMSetting8021x:private-key-password
    #[doc(alias = "nm_setting_802_1x_get_private_key_password_flags")]
    #[doc(alias = "get_private_key_password_flags")]
    #[doc(alias = "private-key-password-flags")]
    pub fn private_key_password_flags(&self) -> SettingSecretFlags {
        unsafe {
            from_glib(ffi::nm_setting_802_1x_get_private_key_password_flags(
                self.to_glib_none().0,
            ))
        }
    }

    /// Private keys are used to authenticate the connecting client to the network
    /// when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
    /// authentication method.
    ///
    /// # Returns
    ///
    /// path to the private key file
    #[doc(alias = "nm_setting_802_1x_get_private_key_path")]
    #[doc(alias = "get_private_key_path")]
    pub fn private_key_path(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_setting_802_1x_get_private_key_path(
                self.to_glib_none().0,
            ))
        }
    }

    /// Returns the scheme used to store the private key.  If the returned scheme is
    /// [`Setting8021xCKScheme::Blob`][crate::Setting8021xCKScheme::Blob], use
    /// nm_setting_802_1x_get_client_cert_blob(); if
    /// [`Setting8021xCKScheme::Path`][crate::Setting8021xCKScheme::Path], use
    /// nm_setting_802_1x_get_client_cert_path(); if
    /// [`Setting8021xCKScheme::Pkcs11`][crate::Setting8021xCKScheme::Pkcs11], use
    /// nm_setting_802_1x_get_client_cert_uri().
    ///
    /// # Returns
    ///
    /// scheme used to store the private key (blob or path)
    #[doc(alias = "nm_setting_802_1x_get_private_key_scheme")]
    #[doc(alias = "get_private_key_scheme")]
    pub fn private_key_scheme(&self) -> Setting8021xCKScheme {
        unsafe {
            from_glib(ffi::nm_setting_802_1x_get_private_key_scheme(
                self.to_glib_none().0,
            ))
        }
    }

    /// Returns the private key URI analogously to
    /// nm_setting_802_1x_get_private_key_blob() and
    /// nm_setting_802_1x_get_private_key_path().
    ///
    /// Currently, it's limited to PKCS#<!-- -->11 URIs ('pkcs11' scheme as defined by RFC
    /// 7512), but may be extended to other schemes in future (such as 'file' URIs
    /// for local files and 'data' URIs for inline certificate data).
    ///
    /// # Returns
    ///
    /// the URI string
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    #[doc(alias = "nm_setting_802_1x_get_private_key_uri")]
    #[doc(alias = "get_private_key_uri")]
    pub fn private_key_uri(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_setting_802_1x_get_private_key_uri(
                self.to_glib_none().0,
            ))
        }
    }

    ///
    /// # Returns
    ///
    /// the #NMSetting8021x:subject-match property. This is the
    /// substring to be matched against the subject of the authentication
    /// server certificate, or [`None`] no subject verification is to be
    /// performed.
    #[doc(alias = "nm_setting_802_1x_get_subject_match")]
    #[doc(alias = "get_subject_match")]
    #[doc(alias = "subject-match")]
    pub fn subject_match(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::nm_setting_802_1x_get_subject_match(
                self.to_glib_none().0,
            ))
        }
    }

    /// Sets the #NMSetting8021x:system-ca-certs property. The
    /// #NMSetting8021x:ca-path and #NMSetting8021x:phase2-ca-path
    /// properties are ignored if the #NMSetting8021x:system-ca-certs property is
    /// [`true`], in which case a system-wide CA certificate directory specified at
    /// compile time (using the --system-ca-path configure option) is used in place
    /// of these properties.
    ///
    /// # Returns
    ///
    /// [`true`] if a system CA certificate path should be used, [`false`] if not
    #[doc(alias = "nm_setting_802_1x_get_system_ca_certs")]
    #[doc(alias = "get_system_ca_certs")]
    #[doc(alias = "system-ca-certs")]
    pub fn is_system_ca_certs(&self) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_802_1x_get_system_ca_certs(
                self.to_glib_none().0,
            ))
        }
    }

    /// Removes the allowed altSubjectName at the specified index.
    /// ## `i`
    /// the index of the altSubjectName match to remove
    #[doc(alias = "nm_setting_802_1x_remove_altsubject_match")]
    pub fn remove_altsubject_match(&self, i: u32) {
        unsafe {
            ffi::nm_setting_802_1x_remove_altsubject_match(self.to_glib_none().0, i);
        }
    }

    /// Removes the allowed altSubjectName @altsubject_match.
    /// ## `altsubject_match`
    /// the altSubjectName to remove
    ///
    /// # Returns
    ///
    /// [`true`] if the alternative subject name match was found and removed,
    ///          [`false`] if it was not.
    #[doc(alias = "nm_setting_802_1x_remove_altsubject_match_by_value")]
    pub fn remove_altsubject_match_by_value(&self, altsubject_match: &str) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_802_1x_remove_altsubject_match_by_value(
                self.to_glib_none().0,
                altsubject_match.to_glib_none().0,
            ))
        }
    }

    /// Removes the allowed EAP method at the specified index.
    /// ## `i`
    /// the index of the EAP method to remove
    #[doc(alias = "nm_setting_802_1x_remove_eap_method")]
    pub fn remove_eap_method(&self, i: u32) {
        unsafe {
            ffi::nm_setting_802_1x_remove_eap_method(self.to_glib_none().0, i);
        }
    }

    /// Removes the allowed EAP method @method.
    /// ## `eap`
    /// the name of the EAP method to remove
    ///
    /// # Returns
    ///
    /// [`true`] if the EAP method was founs and removed, [`false`] if it was not.
    #[doc(alias = "nm_setting_802_1x_remove_eap_method_by_value")]
    pub fn remove_eap_method_by_value(&self, eap: &str) -> bool {
        unsafe {
            from_glib(ffi::nm_setting_802_1x_remove_eap_method_by_value(
                self.to_glib_none().0,
                eap.to_glib_none().0,
            ))
        }
    }

    /// Removes the allowed "phase 2" altSubjectName at the specified index.
    /// ## `i`
    /// the index of the "phase 2" altSubjectName match to remove
    #[doc(alias = "nm_setting_802_1x_remove_phase2_altsubject_match")]
    pub fn remove_phase2_altsubject_match(&self, i: u32) {
        unsafe {
            ffi::nm_setting_802_1x_remove_phase2_altsubject_match(self.to_glib_none().0, i);
        }
    }

    /// Removes the allowed "phase 2" altSubjectName @phase2_altsubject_match.
    /// ## `phase2_altsubject_match`
    /// the "phase 2" altSubjectName to remove
    ///
    /// # Returns
    ///
    /// [`true`] if the alternative subject name match for "phase 2" was found and removed,
    ///          [`false`] if it was not.
    #[doc(alias = "nm_setting_802_1x_remove_phase2_altsubject_match_by_value")]
    pub fn remove_phase2_altsubject_match_by_value(&self, phase2_altsubject_match: &str) -> bool {
        unsafe {
            from_glib(
                ffi::nm_setting_802_1x_remove_phase2_altsubject_match_by_value(
                    self.to_glib_none().0,
                    phase2_altsubject_match.to_glib_none().0,
                ),
            )
        }
    }

    /// Reads a certificate from disk and sets the #NMSetting8021x:ca-cert property
    /// with the raw certificate data if using the [`Setting8021xCKScheme::Blob`][crate::Setting8021xCKScheme::Blob]
    /// scheme, or with the path to the certificate file if using the
    /// [`Setting8021xCKScheme::Path`][crate::Setting8021xCKScheme::Path] scheme.
    /// ## `value`
    /// when @scheme is set to either [`Setting8021xCKScheme::Path`][crate::Setting8021xCKScheme::Path]
    ///   or [`Setting8021xCKScheme::Blob`][crate::Setting8021xCKScheme::Blob], pass the path of the CA certificate
    ///   file (PEM or DER format).  The path must be UTF-8 encoded; use
    ///   g_filename_to_utf8() to convert if needed.  Passing [`None`] with any @scheme
    ///   clears the CA certificate.
    /// ## `scheme`
    /// desired storage scheme for the certificate
    /// ## `out_format`
    /// on successful return, the type of the certificate added
    ///
    /// # Returns
    ///
    /// [`true`] if the operation succeeded, [`false`] if it was unsuccessful
    #[doc(alias = "nm_setting_802_1x_set_ca_cert")]
    #[doc(alias = "ca-cert")]
    pub fn set_ca_cert(
        &self,
        value: &str,
        scheme: Setting8021xCKScheme,
        out_format: Setting8021xCKFormat,
    ) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::nm_setting_802_1x_set_ca_cert(
                self.to_glib_none().0,
                value.to_glib_none().0,
                scheme.into_glib(),
                &mut out_format.into_glib(),
                &mut error,
            );
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    /// Reads a certificate from disk and sets the #NMSetting8021x:client-cert
    /// property with the raw certificate data if using the
    /// [`Setting8021xCKScheme::Blob`][crate::Setting8021xCKScheme::Blob] scheme, or with the path to the certificate
    /// file if using the [`Setting8021xCKScheme::Path`][crate::Setting8021xCKScheme::Path] scheme.
    ///
    /// Client certificates are used to identify the connecting client to the network
    /// when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
    /// authentication method.
    /// ## `value`
    /// when @scheme is set to either [`Setting8021xCKScheme::Path`][crate::Setting8021xCKScheme::Path]
    ///   or [`Setting8021xCKScheme::Blob`][crate::Setting8021xCKScheme::Blob], pass the path of the client
    ///   certificate file (PEM, DER, or PKCS#<!-- -->12 format).  The path must be UTF-8
    ///   encoded; use g_filename_to_utf8() to convert if needed.  Passing [`None`] with
    ///   any @scheme clears the client certificate.
    /// ## `scheme`
    /// desired storage scheme for the certificate
    /// ## `out_format`
    /// on successful return, the type of the certificate added
    ///
    /// # Returns
    ///
    /// [`true`] if the operation succeeded, [`false`] if it was unsuccessful
    #[doc(alias = "nm_setting_802_1x_set_client_cert")]
    #[doc(alias = "client-cert")]
    pub fn set_client_cert(
        &self,
        value: &str,
        scheme: Setting8021xCKScheme,
        out_format: Setting8021xCKFormat,
    ) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::nm_setting_802_1x_set_client_cert(
                self.to_glib_none().0,
                value.to_glib_none().0,
                scheme.into_glib(),
                &mut out_format.into_glib(),
                &mut error,
            );
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    /// Reads a certificate from disk and sets the #NMSetting8021x:phase2-ca-cert
    /// property with the raw certificate data if using the
    /// [`Setting8021xCKScheme::Blob`][crate::Setting8021xCKScheme::Blob] scheme, or with the path to the certificate
    /// file if using the [`Setting8021xCKScheme::Path`][crate::Setting8021xCKScheme::Path] scheme.
    /// ## `value`
    /// when @scheme is set to either [`Setting8021xCKScheme::Path`][crate::Setting8021xCKScheme::Path]
    ///   or [`Setting8021xCKScheme::Blob`][crate::Setting8021xCKScheme::Blob], pass the path of the "phase2" CA
    ///   certificate file (PEM or DER format).  The path must be UTF-8 encoded; use
    ///   g_filename_to_utf8() to convert if needed.  Passing [`None`] with any @scheme
    ///   clears the "phase2" CA certificate.
    /// ## `scheme`
    /// desired storage scheme for the certificate
    /// ## `out_format`
    /// on successful return, the type of the certificate added
    ///
    /// # Returns
    ///
    /// [`true`] if the operation succeeded, [`false`] if it was unsuccessful
    #[doc(alias = "nm_setting_802_1x_set_phase2_ca_cert")]
    #[doc(alias = "phase2-ca-cert")]
    pub fn set_phase2_ca_cert(
        &self,
        value: &str,
        scheme: Setting8021xCKScheme,
        out_format: Setting8021xCKFormat,
    ) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::nm_setting_802_1x_set_phase2_ca_cert(
                self.to_glib_none().0,
                value.to_glib_none().0,
                scheme.into_glib(),
                &mut out_format.into_glib(),
                &mut error,
            );
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    /// Reads a certificate from disk and sets the #NMSetting8021x:phase2-client-cert
    /// property with the raw certificate data if using the
    /// [`Setting8021xCKScheme::Blob`][crate::Setting8021xCKScheme::Blob] scheme, or with the path to the certificate
    /// file if using the [`Setting8021xCKScheme::Path`][crate::Setting8021xCKScheme::Path] scheme.
    ///
    /// Client certificates are used to identify the connecting client to the network
    /// when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
    /// authentication method.
    /// ## `value`
    /// when @scheme is set to either [`Setting8021xCKScheme::Path`][crate::Setting8021xCKScheme::Path]
    ///   or [`Setting8021xCKScheme::Blob`][crate::Setting8021xCKScheme::Blob], pass the path of the "phase2" client
    ///   certificate file (PEM, DER, or PKCS#<!-- -->12 format).  The path must be UTF-8
    ///   encoded; use g_filename_to_utf8() to convert if needed.  Passing [`None`] with
    ///   any @scheme clears the "phase2" client certificate.
    /// ## `scheme`
    /// desired storage scheme for the certificate
    /// ## `out_format`
    /// on successful return, the type of the certificate added
    ///
    /// # Returns
    ///
    /// [`true`] if the operation succeeded, [`false`] if it was unsuccessful
    #[doc(alias = "nm_setting_802_1x_set_phase2_client_cert")]
    #[doc(alias = "phase2-client-cert")]
    pub fn set_phase2_client_cert(
        &self,
        value: &str,
        scheme: Setting8021xCKScheme,
        out_format: Setting8021xCKFormat,
    ) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::nm_setting_802_1x_set_phase2_client_cert(
                self.to_glib_none().0,
                value.to_glib_none().0,
                scheme.into_glib(),
                &mut out_format.into_glib(),
                &mut error,
            );
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    /// Private keys are used to authenticate the connecting client to the network
    /// when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
    /// authentication method.
    ///
    /// This function reads a private key from disk and sets the
    /// #NMSetting8021x:phase2-private-key property with the private key file data if
    /// using the [`Setting8021xCKScheme::Blob`][crate::Setting8021xCKScheme::Blob] scheme, or with the path to the
    /// private key file if using the [`Setting8021xCKScheme::Path`][crate::Setting8021xCKScheme::Path] scheme.
    ///
    /// If @password is given, this function attempts to decrypt the private key to
    /// verify that @password is correct, and if it is, updates the
    /// #NMSetting8021x:phase2-private-key-password property with the given
    /// @password.  If the decryption is unsuccessful, [`false`] is returned, @error is
    /// set, and no internal data is changed.  If no @password is given, the private
    /// key is assumed to be valid, no decryption is performed, and the password may
    /// be set at a later time.
    ///
    /// WARNING: the "phase2" private key property is not a "secret" property, and
    /// thus unencrypted private key data using the BLOB scheme may be readable by
    /// unprivileged users.  Private keys should always be encrypted with a private
    /// key password to prevent unauthorized access to unencrypted private key data.
    /// ## `value`
    /// when @scheme is set to either [`Setting8021xCKScheme::Path`][crate::Setting8021xCKScheme::Path] or
    ///   [`Setting8021xCKScheme::Blob`][crate::Setting8021xCKScheme::Blob], pass the path of the "phase2" private
    ///   key file (PEM, DER, or PKCS#<!-- -->12 format).  The path must be UTF-8 encoded;
    ///   use g_filename_to_utf8() to convert if needed.  Passing [`None`] with any
    ///   @scheme clears the private key.
    /// ## `password`
    /// password used to decrypt the private key, or [`None`] if the password
    ///   is unknown.  If the password is given but fails to decrypt the private key,
    ///   an error is returned.
    /// ## `scheme`
    /// desired storage scheme for the private key
    /// ## `out_format`
    /// on successful return, the type of the private key added
    ///
    /// # Returns
    ///
    /// [`true`] if the operation succeeded, [`false`] if it was unsuccessful
    #[doc(alias = "nm_setting_802_1x_set_phase2_private_key")]
    #[doc(alias = "phase2-private-key")]
    pub fn set_phase2_private_key(
        &self,
        value: &str,
        password: &str,
        scheme: Setting8021xCKScheme,
        out_format: Setting8021xCKFormat,
    ) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::nm_setting_802_1x_set_phase2_private_key(
                self.to_glib_none().0,
                value.to_glib_none().0,
                password.to_glib_none().0,
                scheme.into_glib(),
                &mut out_format.into_glib(),
                &mut error,
            );
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    /// Private keys are used to authenticate the connecting client to the network
    /// when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
    /// authentication method.
    ///
    /// This function reads a private key from disk and sets the
    /// #NMSetting8021x:private-key property with the private key file data if using
    /// the [`Setting8021xCKScheme::Blob`][crate::Setting8021xCKScheme::Blob] scheme, or with the path to the private
    /// key file if using the [`Setting8021xCKScheme::Path`][crate::Setting8021xCKScheme::Path] scheme.
    ///
    /// If @password is given, this function attempts to decrypt the private key to
    /// verify that @password is correct, and if it is, updates the
    /// #NMSetting8021x:private-key-password property with the given @password.  If
    /// the decryption is unsuccessful, [`false`] is returned, @error is set, and no
    /// internal data is changed.  If no @password is given, the private key is
    /// assumed to be valid, no decryption is performed, and the password may be set
    /// at a later time.
    ///
    /// WARNING: the private key property is not a "secret" property, and thus
    /// unencrypted private key data using the BLOB scheme may be readable by
    /// unprivileged users.  Private keys should always be encrypted with a private
    /// key password to prevent unauthorized access to unencrypted private key data.
    /// ## `value`
    /// when @scheme is set to either [`Setting8021xCKScheme::Path`][crate::Setting8021xCKScheme::Path] or
    ///   [`Setting8021xCKScheme::Blob`][crate::Setting8021xCKScheme::Blob], pass the path of the private key file
    ///   (PEM, DER, or PKCS#<!-- -->12 format).  The path must be UTF-8 encoded; use
    ///   g_filename_to_utf8() to convert if needed.  Passing [`None`] with any @scheme
    ///   clears the private key.
    /// ## `password`
    /// password used to decrypt the private key, or [`None`] if the password
    ///   is unknown.  If the password is given but fails to decrypt the private key,
    ///   an error is returned.
    /// ## `scheme`
    /// desired storage scheme for the private key
    /// ## `out_format`
    /// on successful return, the type of the private key added
    ///
    /// # Returns
    ///
    /// [`true`] if the operation succeeded, [`false`] if it was unsuccessful
    #[doc(alias = "nm_setting_802_1x_set_private_key")]
    #[doc(alias = "private-key")]
    pub fn set_private_key(
        &self,
        value: &str,
        password: &str,
        scheme: Setting8021xCKScheme,
        out_format: Setting8021xCKFormat,
    ) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::nm_setting_802_1x_set_private_key(
                self.to_glib_none().0,
                value.to_glib_none().0,
                password.to_glib_none().0,
                scheme.into_glib(),
                &mut out_format.into_glib(),
                &mut error,
            );
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    /// List of strings to be matched against the altSubjectName of the
    /// certificate presented by the authentication server. If the list is empty,
    /// no verification of the server certificate's altSubjectName is performed.
    #[doc(alias = "altsubject-matches")]
    pub fn altsubject_matches(&self) -> Vec<glib::GString> {
        ObjectExt::property(self, "altsubject-matches")
    }

    /// List of strings to be matched against the altSubjectName of the
    /// certificate presented by the authentication server. If the list is empty,
    /// no verification of the server certificate's altSubjectName is performed.
    #[doc(alias = "altsubject-matches")]
    pub fn set_altsubject_matches(&self, altsubject_matches: &[&str]) {
        ObjectExt::set_property(self, "altsubject-matches", altsubject_matches)
    }

    /// Anonymous identity string for EAP authentication methods.  Used as the
    /// unencrypted identity with EAP types that support different tunneled
    /// identity like EAP-TTLS.
    #[doc(alias = "anonymous-identity")]
    pub fn set_anonymous_identity(&self, anonymous_identity: Option<&str>) {
        ObjectExt::set_property(self, "anonymous-identity", anonymous_identity)
    }

    /// A timeout for the authentication. Zero means the global default; if the
    /// global default is not set, the authentication timeout is 25 seconds.
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    #[doc(alias = "auth-timeout")]
    pub fn set_auth_timeout(&self, auth_timeout: i32) {
        ObjectExt::set_property(self, "auth-timeout", auth_timeout)
    }

    //#[doc(alias = "ca-cert")]
    //pub fn ca_cert(&self) -> /*Ignored*/Option<glib::Bytes> {
    //    ObjectExt::property(self, "ca-cert")
    //}

    /// The password used to access the CA certificate stored in
    /// #NMSetting8021x:ca-cert property. Only makes sense if the certificate
    /// is stored on a PKCS#<!-- -->11 token that requires a login.
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    #[doc(alias = "ca-cert-password")]
    pub fn set_ca_cert_password(&self, ca_cert_password: Option<&str>) {
        ObjectExt::set_property(self, "ca-cert-password", ca_cert_password)
    }

    /// Flags indicating how to handle the #NMSetting8021x:ca-cert-password property.
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    #[doc(alias = "ca-cert-password-flags")]
    pub fn set_ca_cert_password_flags(&self, ca_cert_password_flags: SettingSecretFlags) {
        ObjectExt::set_property(self, "ca-cert-password-flags", ca_cert_password_flags)
    }

    /// UTF-8 encoded path to a directory containing PEM or DER formatted
    /// certificates to be added to the verification chain in addition to the
    /// certificate specified in the #NMSetting8021x:ca-cert property.
    ///
    /// If NMSetting8021x:system-ca-certs is enabled and the built-in CA
    /// path is an existing directory, then this setting is ignored.
    #[doc(alias = "ca-path")]
    pub fn set_ca_path(&self, ca_path: Option<&str>) {
        ObjectExt::set_property(self, "ca-path", ca_path)
    }

    //#[doc(alias = "client-cert")]
    //pub fn client_cert(&self) -> /*Ignored*/Option<glib::Bytes> {
    //    ObjectExt::property(self, "client-cert")
    //}

    /// The password used to access the client certificate stored in
    /// #NMSetting8021x:client-cert property. Only makes sense if the certificate
    /// is stored on a PKCS#<!-- -->11 token that requires a login.
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    #[doc(alias = "client-cert-password")]
    pub fn set_client_cert_password(&self, client_cert_password: Option<&str>) {
        ObjectExt::set_property(self, "client-cert-password", client_cert_password)
    }

    /// Flags indicating how to handle the #NMSetting8021x:client-cert-password property.
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    #[doc(alias = "client-cert-password-flags")]
    pub fn set_client_cert_password_flags(&self, client_cert_password_flags: SettingSecretFlags) {
        ObjectExt::set_property(
            self,
            "client-cert-password-flags",
            client_cert_password_flags,
        )
    }

    /// Constraint for server domain name. If set, this list of FQDNs is used as
    /// a match requirement for dNSName element(s) of the certificate presented
    /// by the authentication server.  If a matching dNSName is found, this
    /// constraint is met.  If no dNSName values are present, this constraint is
    /// matched against SubjectName CN using the same comparison.
    /// Multiple valid FQDNs can be passed as a ";" delimited list.
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    #[doc(alias = "domain-match")]
    pub fn set_domain_match(&self, domain_match: Option<&str>) {
        ObjectExt::set_property(self, "domain-match", domain_match)
    }

    /// Constraint for server domain name. If set, this FQDN is used as a suffix
    /// match requirement for dNSName element(s) of the certificate presented by
    /// the authentication server.  If a matching dNSName is found, this
    /// constraint is met.  If no dNSName values are present, this constraint is
    /// matched against SubjectName CN using same suffix match comparison.
    /// Since version 1.24, multiple valid FQDNs can be passed as a ";" delimited
    /// list.
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    #[doc(alias = "domain-suffix-match")]
    pub fn set_domain_suffix_match(&self, domain_suffix_match: Option<&str>) {
        ObjectExt::set_property(self, "domain-suffix-match", domain_suffix_match)
    }

    /// The allowed EAP method to be used when authenticating to the network with
    /// 802.1x.  Valid methods are: "leap", "md5", "tls", "peap", "ttls", "pwd",
    /// and "fast".  Each method requires different configuration using the
    /// properties of this setting; refer to wpa_supplicant documentation for the
    /// allowed combinations.
    pub fn eap(&self) -> Vec<glib::GString> {
        ObjectExt::property(self, "eap")
    }

    /// The allowed EAP method to be used when authenticating to the network with
    /// 802.1x.  Valid methods are: "leap", "md5", "tls", "peap", "ttls", "pwd",
    /// and "fast".  Each method requires different configuration using the
    /// properties of this setting; refer to wpa_supplicant documentation for the
    /// allowed combinations.
    pub fn set_eap(&self, eap: &[&str]) {
        ObjectExt::set_property(self, "eap", eap)
    }

    /// Identity string for EAP authentication methods.  Often the user's user or
    /// login name.
    pub fn set_identity(&self, identity: Option<&str>) {
        ObjectExt::set_property(self, "identity", identity)
    }

    /// Define openssl_ciphers for wpa_supplicant. Openssl sometimes moves ciphers
    /// among SECLEVELs, thus compiled-in default value in wpa_supplicant
    /// (as modified by some linux distributions) sometimes prevents
    /// to connect to old servers that do not support new protocols.
    #[cfg(feature = "v1_48")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_48")))]
    #[doc(alias = "openssl-ciphers")]
    pub fn set_openssl_ciphers(&self, openssl_ciphers: Option<&str>) {
        ObjectExt::set_property(self, "openssl-ciphers", openssl_ciphers)
    }

    /// Whether the 802.1X authentication is optional. If [`true`], the activation
    /// will continue even after a timeout or an authentication failure. Setting
    /// the property to [`true`] is currently allowed only for Ethernet connections.
    /// If set to [`false`], the activation can continue only after a successful
    /// authentication.
    #[cfg(feature = "v1_22")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
    pub fn set_optional(&self, optional: bool) {
        ObjectExt::set_property(self, "optional", optional)
    }

    /// UTF-8 encoded file path containing PAC for EAP-FAST.
    #[doc(alias = "pac-file")]
    pub fn set_pac_file(&self, pac_file: Option<&str>) {
        ObjectExt::set_property(self, "pac-file", pac_file)
    }

    /// UTF-8 encoded password used for EAP authentication methods. If both the
    /// #NMSetting8021x:password property and the #NMSetting8021x:password-raw
    /// property are specified, #NMSetting8021x:password is preferred.
    pub fn set_password(&self, password: Option<&str>) {
        ObjectExt::set_property(self, "password", password)
    }

    /// Flags indicating how to handle the #NMSetting8021x:password property.
    #[doc(alias = "password-flags")]
    pub fn set_password_flags(&self, password_flags: SettingSecretFlags) {
        ObjectExt::set_property(self, "password-flags", password_flags)
    }

    //#[doc(alias = "password-raw")]
    //pub fn set_password_raw(&self, password_raw: /*Ignored*/Option<&glib::Bytes>) {
    //    ObjectExt::set_property(self,"password-raw", password_raw)
    //}

    /// Flags indicating how to handle the #NMSetting8021x:password-raw property.
    #[doc(alias = "password-raw-flags")]
    pub fn set_password_raw_flags(&self, password_raw_flags: SettingSecretFlags) {
        ObjectExt::set_property(self, "password-raw-flags", password_raw_flags)
    }

    /// Specifies authentication flags to use in "phase 1" outer
    /// authentication using #NMSetting8021xAuthFlags options.
    /// The individual TLS versions can be explicitly disabled. TLS time checks
    /// can be also disabled. If a certain TLS disable flag is not
    /// set, it is up to the supplicant to allow or forbid it. The TLS options
    /// map to tls_disable_tlsv1_x and tls_disable_time_checks settings.
    /// See the wpa_supplicant documentation for more details.
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    #[doc(alias = "phase1-auth-flags")]
    pub fn set_phase1_auth_flags(&self, phase1_auth_flags: u32) {
        ObjectExt::set_property(self, "phase1-auth-flags", phase1_auth_flags)
    }

    /// Enables or disables in-line provisioning of EAP-FAST credentials when
    /// FAST is specified as the EAP method in the #NMSetting8021x:eap property.
    /// Recognized values are "0" (disabled), "1" (allow unauthenticated
    /// provisioning), "2" (allow authenticated provisioning), and "3" (allow
    /// both authenticated and unauthenticated provisioning).  See the
    /// wpa_supplicant documentation for more details.
    #[doc(alias = "phase1-fast-provisioning")]
    pub fn set_phase1_fast_provisioning(&self, phase1_fast_provisioning: Option<&str>) {
        ObjectExt::set_property(self, "phase1-fast-provisioning", phase1_fast_provisioning)
    }

    /// Forces use of the new PEAP label during key derivation.  Some RADIUS
    /// servers may require forcing the new PEAP label to interoperate with
    /// PEAPv1.  Set to "1" to force use of the new PEAP label.  See the
    /// wpa_supplicant documentation for more details.
    #[doc(alias = "phase1-peaplabel")]
    pub fn set_phase1_peaplabel(&self, phase1_peaplabel: Option<&str>) {
        ObjectExt::set_property(self, "phase1-peaplabel", phase1_peaplabel)
    }

    /// Forces which PEAP version is used when PEAP is set as the EAP method in
    /// the #NMSetting8021x:eap property.  When unset, the version reported by
    /// the server will be used.  Sometimes when using older RADIUS servers, it
    /// is necessary to force the client to use a particular PEAP version.  To do
    /// so, this property may be set to "0" or "1" to force that specific PEAP
    /// version.
    #[doc(alias = "phase1-peapver")]
    pub fn set_phase1_peapver(&self, phase1_peapver: Option<&str>) {
        ObjectExt::set_property(self, "phase1-peapver", phase1_peapver)
    }

    /// List of strings to be matched against the altSubjectName of the
    /// certificate presented by the authentication server during the inner
    /// "phase 2" authentication. If the list is empty, no verification of the
    /// server certificate's altSubjectName is performed.
    #[doc(alias = "phase2-altsubject-matches")]
    pub fn phase2_altsubject_matches(&self) -> Vec<glib::GString> {
        ObjectExt::property(self, "phase2-altsubject-matches")
    }

    /// List of strings to be matched against the altSubjectName of the
    /// certificate presented by the authentication server during the inner
    /// "phase 2" authentication. If the list is empty, no verification of the
    /// server certificate's altSubjectName is performed.
    #[doc(alias = "phase2-altsubject-matches")]
    pub fn set_phase2_altsubject_matches(&self, phase2_altsubject_matches: &[&str]) {
        ObjectExt::set_property(self, "phase2-altsubject-matches", phase2_altsubject_matches)
    }

    /// Specifies the allowed "phase 2" inner authentication method when an EAP
    /// method that uses an inner TLS tunnel is specified in the #NMSetting8021x:eap
    /// property.  For TTLS this property selects one of the supported non-EAP
    /// inner methods: "pap", "chap", "mschap", "mschapv2" while
    /// #NMSetting8021x:phase2-autheap selects an EAP inner method.  For PEAP
    /// this selects an inner EAP method, one of: "gtc", "otp", "md5" and "tls".
    /// Each "phase 2" inner method requires specific parameters for successful
    /// authentication; see the wpa_supplicant documentation for more details.
    /// Both #NMSetting8021x:phase2-auth and #NMSetting8021x:phase2-autheap cannot
    /// be specified.
    #[doc(alias = "phase2-auth")]
    pub fn set_phase2_auth(&self, phase2_auth: Option<&str>) {
        ObjectExt::set_property(self, "phase2-auth", phase2_auth)
    }

    /// Specifies the allowed "phase 2" inner EAP-based authentication method
    /// when TTLS is specified in the #NMSetting8021x:eap property.  Recognized
    /// EAP-based "phase 2" methods are "md5", "mschapv2", "otp", "gtc", and
    /// "tls". Each "phase 2" inner method requires specific parameters for
    /// successful authentication; see the wpa_supplicant documentation for
    /// more details.
    #[doc(alias = "phase2-autheap")]
    pub fn set_phase2_autheap(&self, phase2_autheap: Option<&str>) {
        ObjectExt::set_property(self, "phase2-autheap", phase2_autheap)
    }

    //#[doc(alias = "phase2-ca-cert")]
    //pub fn phase2_ca_cert(&self) -> /*Ignored*/Option<glib::Bytes> {
    //    ObjectExt::property(self, "phase2-ca-cert")
    //}

    /// The password used to access the "phase2" CA certificate stored in
    /// #NMSetting8021x:phase2-ca-cert property. Only makes sense if the certificate
    /// is stored on a PKCS#<!-- -->11 token that requires a login.
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    #[doc(alias = "phase2-ca-cert-password")]
    pub fn set_phase2_ca_cert_password(&self, phase2_ca_cert_password: Option<&str>) {
        ObjectExt::set_property(self, "phase2-ca-cert-password", phase2_ca_cert_password)
    }

    /// Flags indicating how to handle the #NMSetting8021x:phase2-ca-cert-password property.
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    #[doc(alias = "phase2-ca-cert-password-flags")]
    pub fn set_phase2_ca_cert_password_flags(
        &self,
        phase2_ca_cert_password_flags: SettingSecretFlags,
    ) {
        ObjectExt::set_property(
            self,
            "phase2-ca-cert-password-flags",
            phase2_ca_cert_password_flags,
        )
    }

    /// UTF-8 encoded path to a directory containing PEM or DER formatted
    /// certificates to be added to the verification chain in addition to the
    /// certificate specified in the #NMSetting8021x:phase2-ca-cert property.
    ///
    /// If NMSetting8021x:system-ca-certs is enabled and the built-in CA
    /// path is an existing directory, then this setting is ignored.
    #[doc(alias = "phase2-ca-path")]
    pub fn set_phase2_ca_path(&self, phase2_ca_path: Option<&str>) {
        ObjectExt::set_property(self, "phase2-ca-path", phase2_ca_path)
    }

    //#[doc(alias = "phase2-client-cert")]
    //pub fn phase2_client_cert(&self) -> /*Ignored*/Option<glib::Bytes> {
    //    ObjectExt::property(self, "phase2-client-cert")
    //}

    /// The password used to access the "phase2" client certificate stored in
    /// #NMSetting8021x:phase2-client-cert property. Only makes sense if the certificate
    /// is stored on a PKCS#<!-- -->11 token that requires a login.
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    #[doc(alias = "phase2-client-cert-password")]
    pub fn set_phase2_client_cert_password(&self, phase2_client_cert_password: Option<&str>) {
        ObjectExt::set_property(
            self,
            "phase2-client-cert-password",
            phase2_client_cert_password,
        )
    }

    /// Flags indicating how to handle the #NMSetting8021x:phase2-client-cert-password property.
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    #[doc(alias = "phase2-client-cert-password-flags")]
    pub fn set_phase2_client_cert_password_flags(
        &self,
        phase2_client_cert_password_flags: SettingSecretFlags,
    ) {
        ObjectExt::set_property(
            self,
            "phase2-client-cert-password-flags",
            phase2_client_cert_password_flags,
        )
    }

    /// Constraint for server domain name. If set, this list of FQDNs is used as
    /// a match requirement for dNSName element(s) of the certificate presented
    /// by the authentication server during the inner "phase 2" authentication.
    /// If a matching dNSName is found, this constraint is met.  If no dNSName
    /// values are present, this constraint is matched against SubjectName CN
    /// using the same comparison.
    /// Multiple valid FQDNs can be passed as a ";" delimited list.
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    #[doc(alias = "phase2-domain-match")]
    pub fn set_phase2_domain_match(&self, phase2_domain_match: Option<&str>) {
        ObjectExt::set_property(self, "phase2-domain-match", phase2_domain_match)
    }

    /// Constraint for server domain name. If set, this FQDN is used as a suffix
    /// match requirement for dNSName element(s) of the certificate presented by
    /// the authentication server during the inner "phase 2" authentication.  If
    /// a matching dNSName is found, this constraint is met.  If no dNSName
    /// values are present, this constraint is matched against SubjectName CN
    /// using same suffix match comparison.
    /// Since version 1.24, multiple valid FQDNs can be passed as a ";" delimited
    /// list.
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    #[doc(alias = "phase2-domain-suffix-match")]
    pub fn set_phase2_domain_suffix_match(&self, phase2_domain_suffix_match: Option<&str>) {
        ObjectExt::set_property(
            self,
            "phase2-domain-suffix-match",
            phase2_domain_suffix_match,
        )
    }

    //#[doc(alias = "phase2-private-key")]
    //pub fn phase2_private_key(&self) -> /*Ignored*/Option<glib::Bytes> {
    //    ObjectExt::property(self, "phase2-private-key")
    //}

    /// The password used to decrypt the "phase 2" private key specified in the
    /// #NMSetting8021x:phase2-private-key property when the private key either
    /// uses the path scheme, or is a PKCS#<!-- -->12 format key.  Setting this
    /// property directly is not generally necessary except when returning
    /// secrets to NetworkManager; it is generally set automatically when setting
    /// the private key by the nm_setting_802_1x_set_phase2_private_key()
    /// function.
    #[doc(alias = "phase2-private-key-password")]
    pub fn set_phase2_private_key_password(&self, phase2_private_key_password: Option<&str>) {
        ObjectExt::set_property(
            self,
            "phase2-private-key-password",
            phase2_private_key_password,
        )
    }

    /// Flags indicating how to handle the
    /// #NMSetting8021x:phase2-private-key-password property.
    #[doc(alias = "phase2-private-key-password-flags")]
    pub fn set_phase2_private_key_password_flags(
        &self,
        phase2_private_key_password_flags: SettingSecretFlags,
    ) {
        ObjectExt::set_property(
            self,
            "phase2-private-key-password-flags",
            phase2_private_key_password_flags,
        )
    }

    /// Substring to be matched against the subject of the certificate presented
    /// by the authentication server during the inner "phase 2"
    /// authentication. When unset, no verification of the authentication server
    /// certificate's subject is performed. This property provides little security,
    /// if any, and should not be used.
    ///
    /// # Deprecated since 1.2
    ///
    /// Use #NMSetting8021x:phase2-domain-suffix-match instead.
    #[cfg_attr(feature = "v1_2", deprecated = "Since 1.2")]
    #[doc(alias = "phase2-subject-match")]
    pub fn set_phase2_subject_match(&self, phase2_subject_match: Option<&str>) {
        ObjectExt::set_property(self, "phase2-subject-match", phase2_subject_match)
    }

    /// PIN used for EAP authentication methods.
    pub fn set_pin(&self, pin: Option<&str>) {
        ObjectExt::set_property(self, "pin", pin)
    }

    /// Flags indicating how to handle the #NMSetting8021x:pin property.
    #[doc(alias = "pin-flags")]
    pub fn set_pin_flags(&self, pin_flags: SettingSecretFlags) {
        ObjectExt::set_property(self, "pin-flags", pin_flags)
    }

    //#[doc(alias = "private-key")]
    //pub fn private_key(&self) -> /*Ignored*/Option<glib::Bytes> {
    //    ObjectExt::property(self, "private-key")
    //}

    /// The password used to decrypt the private key specified in the
    /// #NMSetting8021x:private-key property when the private key either uses the
    /// path scheme, or if the private key is a PKCS#<!-- -->12 format key.  Setting this
    /// property directly is not generally necessary except when returning
    /// secrets to NetworkManager; it is generally set automatically when setting
    /// the private key by the nm_setting_802_1x_set_private_key() function.
    #[doc(alias = "private-key-password")]
    pub fn set_private_key_password(&self, private_key_password: Option<&str>) {
        ObjectExt::set_property(self, "private-key-password", private_key_password)
    }

    /// Flags indicating how to handle the #NMSetting8021x:private-key-password
    /// property.
    #[doc(alias = "private-key-password-flags")]
    pub fn set_private_key_password_flags(&self, private_key_password_flags: SettingSecretFlags) {
        ObjectExt::set_property(
            self,
            "private-key-password-flags",
            private_key_password_flags,
        )
    }

    /// Substring to be matched against the subject of the certificate presented
    /// by the authentication server. When unset, no verification of the
    /// authentication server certificate's subject is performed. This property
    /// provides little security, if any, and should not be used.
    ///
    /// # Deprecated since 1.2
    ///
    /// Use #NMSetting8021x:phase2-domain-suffix-match instead.
    #[cfg_attr(feature = "v1_2", deprecated = "Since 1.2")]
    #[doc(alias = "subject-match")]
    pub fn set_subject_match(&self, subject_match: Option<&str>) {
        ObjectExt::set_property(self, "subject-match", subject_match)
    }

    /// When [`true`], overrides the #NMSetting8021x:ca-path and
    /// #NMSetting8021x:phase2-ca-path properties using the system CA directory
    /// specified at configure time with the --system-ca-path switch.  The
    /// certificates in this directory are added to the verification chain in
    /// addition to any certificates specified by the #NMSetting8021x:ca-cert and
    /// #NMSetting8021x:phase2-ca-cert properties. If the path provided with
    /// --system-ca-path is rather a file name (bundle of trusted CA certificates),
    /// it overrides #NMSetting8021x:ca-cert and #NMSetting8021x:phase2-ca-cert
    /// properties instead (sets ca_cert/ca_cert2 options for wpa_supplicant).
    #[doc(alias = "system-ca-certs")]
    pub fn set_system_ca_certs(&self, system_ca_certs: bool) {
        ObjectExt::set_property(self, "system-ca-certs", system_ca_certs)
    }

    //#[cfg(feature = "v1_2")]
    //#[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    //#[doc(alias = "nm_setting_802_1x_check_cert_scheme")]
    //pub fn check_cert_scheme(pdata: /*Unimplemented*/Option<Basic: Pointer>, length: usize) -> Result<Setting8021xCKScheme, glib::Error> {
    //    unsafe { TODO: call ffi:nm_setting_802_1x_check_cert_scheme() }
    //}

    #[doc(alias = "altsubject-matches")]
    pub fn connect_altsubject_matches_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_altsubject_matches_trampoline<
            F: Fn(&Setting8021x) + 'static,
        >(
            this: *mut ffi::NMSetting8021x,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::altsubject-matches".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_altsubject_matches_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "anonymous-identity")]
    pub fn connect_anonymous_identity_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_anonymous_identity_trampoline<
            F: Fn(&Setting8021x) + 'static,
        >(
            this: *mut ffi::NMSetting8021x,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::anonymous-identity".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_anonymous_identity_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    #[doc(alias = "auth-timeout")]
    pub fn connect_auth_timeout_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_auth_timeout_trampoline<F: Fn(&Setting8021x) + 'static>(
            this: *mut ffi::NMSetting8021x,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::auth-timeout".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_auth_timeout_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "ca-cert")]
    pub fn connect_ca_cert_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_ca_cert_trampoline<F: Fn(&Setting8021x) + 'static>(
            this: *mut ffi::NMSetting8021x,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::ca-cert".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_ca_cert_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    #[doc(alias = "ca-cert-password")]
    pub fn connect_ca_cert_password_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_ca_cert_password_trampoline<F: Fn(&Setting8021x) + 'static>(
            this: *mut ffi::NMSetting8021x,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::ca-cert-password".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_ca_cert_password_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    #[doc(alias = "ca-cert-password-flags")]
    pub fn connect_ca_cert_password_flags_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_ca_cert_password_flags_trampoline<
            F: Fn(&Setting8021x) + 'static,
        >(
            this: *mut ffi::NMSetting8021x,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::ca-cert-password-flags".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_ca_cert_password_flags_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "ca-path")]
    pub fn connect_ca_path_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_ca_path_trampoline<F: Fn(&Setting8021x) + 'static>(
            this: *mut ffi::NMSetting8021x,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::ca-path".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_ca_path_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "client-cert")]
    pub fn connect_client_cert_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_client_cert_trampoline<F: Fn(&Setting8021x) + 'static>(
            this: *mut ffi::NMSetting8021x,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::client-cert".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_client_cert_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    #[doc(alias = "client-cert-password")]
    pub fn connect_client_cert_password_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_client_cert_password_trampoline<
            F: Fn(&Setting8021x) + 'static,
        >(
            this: *mut ffi::NMSetting8021x,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::client-cert-password".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_client_cert_password_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    #[doc(alias = "client-cert-password-flags")]
    pub fn connect_client_cert_password_flags_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_client_cert_password_flags_trampoline<
            F: Fn(&Setting8021x) + 'static,
        >(
            this: *mut ffi::NMSetting8021x,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::client-cert-password-flags".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_client_cert_password_flags_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    #[doc(alias = "domain-match")]
    pub fn connect_domain_match_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_domain_match_trampoline<F: Fn(&Setting8021x) + 'static>(
            this: *mut ffi::NMSetting8021x,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::domain-match".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_domain_match_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    #[doc(alias = "domain-suffix-match")]
    pub fn connect_domain_suffix_match_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_domain_suffix_match_trampoline<
            F: Fn(&Setting8021x) + 'static,
        >(
            this: *mut ffi::NMSetting8021x,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::domain-suffix-match".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_domain_suffix_match_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "eap")]
    pub fn connect_eap_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_eap_trampoline<F: Fn(&Setting8021x) + 'static>(
            this: *mut ffi::NMSetting8021x,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::eap".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_eap_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "identity")]
    pub fn connect_identity_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_identity_trampoline<F: Fn(&Setting8021x) + 'static>(
            this: *mut ffi::NMSetting8021x,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::identity".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_identity_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(feature = "v1_48")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_48")))]
    #[doc(alias = "openssl-ciphers")]
    pub fn connect_openssl_ciphers_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_openssl_ciphers_trampoline<F: Fn(&Setting8021x) + 'static>(
            this: *mut ffi::NMSetting8021x,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::openssl-ciphers".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_openssl_ciphers_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(feature = "v1_22")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
    #[doc(alias = "optional")]
    pub fn connect_optional_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_optional_trampoline<F: Fn(&Setting8021x) + 'static>(
            this: *mut ffi::NMSetting8021x,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::optional".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_optional_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "pac-file")]
    pub fn connect_pac_file_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_pac_file_trampoline<F: Fn(&Setting8021x) + 'static>(
            this: *mut ffi::NMSetting8021x,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::pac-file".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_pac_file_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "password")]
    pub fn connect_password_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_password_trampoline<F: Fn(&Setting8021x) + 'static>(
            this: *mut ffi::NMSetting8021x,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::password".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_password_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "password-flags")]
    pub fn connect_password_flags_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_password_flags_trampoline<F: Fn(&Setting8021x) + 'static>(
            this: *mut ffi::NMSetting8021x,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::password-flags".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_password_flags_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "password-raw")]
    pub fn connect_password_raw_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_password_raw_trampoline<F: Fn(&Setting8021x) + 'static>(
            this: *mut ffi::NMSetting8021x,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::password-raw".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_password_raw_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "password-raw-flags")]
    pub fn connect_password_raw_flags_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_password_raw_flags_trampoline<
            F: Fn(&Setting8021x) + 'static,
        >(
            this: *mut ffi::NMSetting8021x,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::password-raw-flags".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_password_raw_flags_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    #[doc(alias = "phase1-auth-flags")]
    pub fn connect_phase1_auth_flags_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_phase1_auth_flags_trampoline<F: Fn(&Setting8021x) + 'static>(
            this: *mut ffi::NMSetting8021x,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::phase1-auth-flags".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_phase1_auth_flags_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "phase1-fast-provisioning")]
    pub fn connect_phase1_fast_provisioning_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_phase1_fast_provisioning_trampoline<
            F: Fn(&Setting8021x) + 'static,
        >(
            this: *mut ffi::NMSetting8021x,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::phase1-fast-provisioning".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_phase1_fast_provisioning_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "phase1-peaplabel")]
    pub fn connect_phase1_peaplabel_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_phase1_peaplabel_trampoline<F: Fn(&Setting8021x) + 'static>(
            this: *mut ffi::NMSetting8021x,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::phase1-peaplabel".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_phase1_peaplabel_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "phase1-peapver")]
    pub fn connect_phase1_peapver_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_phase1_peapver_trampoline<F: Fn(&Setting8021x) + 'static>(
            this: *mut ffi::NMSetting8021x,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::phase1-peapver".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_phase1_peapver_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "phase2-altsubject-matches")]
    pub fn connect_phase2_altsubject_matches_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_phase2_altsubject_matches_trampoline<
            F: Fn(&Setting8021x) + 'static,
        >(
            this: *mut ffi::NMSetting8021x,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::phase2-altsubject-matches".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_phase2_altsubject_matches_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "phase2-auth")]
    pub fn connect_phase2_auth_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_phase2_auth_trampoline<F: Fn(&Setting8021x) + 'static>(
            this: *mut ffi::NMSetting8021x,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::phase2-auth".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_phase2_auth_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "phase2-autheap")]
    pub fn connect_phase2_autheap_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_phase2_autheap_trampoline<F: Fn(&Setting8021x) + 'static>(
            this: *mut ffi::NMSetting8021x,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::phase2-autheap".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_phase2_autheap_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "phase2-ca-cert")]
    pub fn connect_phase2_ca_cert_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_phase2_ca_cert_trampoline<F: Fn(&Setting8021x) + 'static>(
            this: *mut ffi::NMSetting8021x,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::phase2-ca-cert".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_phase2_ca_cert_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    #[doc(alias = "phase2-ca-cert-password")]
    pub fn connect_phase2_ca_cert_password_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_phase2_ca_cert_password_trampoline<
            F: Fn(&Setting8021x) + 'static,
        >(
            this: *mut ffi::NMSetting8021x,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::phase2-ca-cert-password".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_phase2_ca_cert_password_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    #[doc(alias = "phase2-ca-cert-password-flags")]
    pub fn connect_phase2_ca_cert_password_flags_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_phase2_ca_cert_password_flags_trampoline<
            F: Fn(&Setting8021x) + 'static,
        >(
            this: *mut ffi::NMSetting8021x,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::phase2-ca-cert-password-flags".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_phase2_ca_cert_password_flags_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "phase2-ca-path")]
    pub fn connect_phase2_ca_path_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_phase2_ca_path_trampoline<F: Fn(&Setting8021x) + 'static>(
            this: *mut ffi::NMSetting8021x,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::phase2-ca-path".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_phase2_ca_path_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "phase2-client-cert")]
    pub fn connect_phase2_client_cert_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_phase2_client_cert_trampoline<
            F: Fn(&Setting8021x) + 'static,
        >(
            this: *mut ffi::NMSetting8021x,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::phase2-client-cert".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_phase2_client_cert_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    #[doc(alias = "phase2-client-cert-password")]
    pub fn connect_phase2_client_cert_password_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_phase2_client_cert_password_trampoline<
            F: Fn(&Setting8021x) + 'static,
        >(
            this: *mut ffi::NMSetting8021x,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::phase2-client-cert-password".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_phase2_client_cert_password_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    #[doc(alias = "phase2-client-cert-password-flags")]
    pub fn connect_phase2_client_cert_password_flags_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_phase2_client_cert_password_flags_trampoline<
            F: Fn(&Setting8021x) + 'static,
        >(
            this: *mut ffi::NMSetting8021x,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::phase2-client-cert-password-flags".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_phase2_client_cert_password_flags_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    #[doc(alias = "phase2-domain-match")]
    pub fn connect_phase2_domain_match_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_phase2_domain_match_trampoline<
            F: Fn(&Setting8021x) + 'static,
        >(
            this: *mut ffi::NMSetting8021x,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::phase2-domain-match".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_phase2_domain_match_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    #[doc(alias = "phase2-domain-suffix-match")]
    pub fn connect_phase2_domain_suffix_match_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_phase2_domain_suffix_match_trampoline<
            F: Fn(&Setting8021x) + 'static,
        >(
            this: *mut ffi::NMSetting8021x,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::phase2-domain-suffix-match".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_phase2_domain_suffix_match_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "phase2-private-key")]
    pub fn connect_phase2_private_key_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_phase2_private_key_trampoline<
            F: Fn(&Setting8021x) + 'static,
        >(
            this: *mut ffi::NMSetting8021x,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::phase2-private-key".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_phase2_private_key_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "phase2-private-key-password")]
    pub fn connect_phase2_private_key_password_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_phase2_private_key_password_trampoline<
            F: Fn(&Setting8021x) + 'static,
        >(
            this: *mut ffi::NMSetting8021x,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::phase2-private-key-password".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_phase2_private_key_password_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "phase2-private-key-password-flags")]
    pub fn connect_phase2_private_key_password_flags_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_phase2_private_key_password_flags_trampoline<
            F: Fn(&Setting8021x) + 'static,
        >(
            this: *mut ffi::NMSetting8021x,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::phase2-private-key-password-flags".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_phase2_private_key_password_flags_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg_attr(feature = "v1_2", deprecated = "Since 1.2")]
    #[doc(alias = "phase2-subject-match")]
    pub fn connect_phase2_subject_match_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_phase2_subject_match_trampoline<
            F: Fn(&Setting8021x) + 'static,
        >(
            this: *mut ffi::NMSetting8021x,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::phase2-subject-match".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_phase2_subject_match_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "pin")]
    pub fn connect_pin_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_pin_trampoline<F: Fn(&Setting8021x) + 'static>(
            this: *mut ffi::NMSetting8021x,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::pin".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_pin_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "pin-flags")]
    pub fn connect_pin_flags_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_pin_flags_trampoline<F: Fn(&Setting8021x) + 'static>(
            this: *mut ffi::NMSetting8021x,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::pin-flags".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_pin_flags_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "private-key")]
    pub fn connect_private_key_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_private_key_trampoline<F: Fn(&Setting8021x) + 'static>(
            this: *mut ffi::NMSetting8021x,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::private-key".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_private_key_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "private-key-password")]
    pub fn connect_private_key_password_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_private_key_password_trampoline<
            F: Fn(&Setting8021x) + 'static,
        >(
            this: *mut ffi::NMSetting8021x,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::private-key-password".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_private_key_password_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "private-key-password-flags")]
    pub fn connect_private_key_password_flags_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_private_key_password_flags_trampoline<
            F: Fn(&Setting8021x) + 'static,
        >(
            this: *mut ffi::NMSetting8021x,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::private-key-password-flags".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_private_key_password_flags_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[cfg_attr(feature = "v1_2", deprecated = "Since 1.2")]
    #[doc(alias = "subject-match")]
    pub fn connect_subject_match_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_subject_match_trampoline<F: Fn(&Setting8021x) + 'static>(
            this: *mut ffi::NMSetting8021x,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::subject-match".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_subject_match_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "system-ca-certs")]
    pub fn connect_system_ca_certs_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_system_ca_certs_trampoline<F: Fn(&Setting8021x) + 'static>(
            this: *mut ffi::NMSetting8021x,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::system-ca-certs".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_system_ca_certs_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }
}

impl Default for Setting8021x {
    fn default() -> Self {
        Self::new()
    }
}

// rustdoc-stripper-ignore-next
/// A [builder-pattern] type to construct [`Setting8021x`] objects.
///
/// [builder-pattern]: https://doc.rust-lang.org/1.0.0/style/ownership/builders.html
#[must_use = "The builder must be built to be used"]
pub struct Setting8021xBuilder {
    builder: glib::object::ObjectBuilder<'static, Setting8021x>,
}

impl Setting8021xBuilder {
    fn new() -> Self {
        Self {
            builder: glib::object::Object::builder(),
        }
    }

    /// List of strings to be matched against the altSubjectName of the
    /// certificate presented by the authentication server. If the list is empty,
    /// no verification of the server certificate's altSubjectName is performed.
    pub fn altsubject_matches(self, altsubject_matches: impl Into<glib::StrV>) -> Self {
        Self {
            builder: self
                .builder
                .property("altsubject-matches", altsubject_matches.into()),
        }
    }

    /// Anonymous identity string for EAP authentication methods.  Used as the
    /// unencrypted identity with EAP types that support different tunneled
    /// identity like EAP-TTLS.
    pub fn anonymous_identity(self, anonymous_identity: impl Into<glib::GString>) -> Self {
        Self {
            builder: self
                .builder
                .property("anonymous-identity", anonymous_identity.into()),
        }
    }

    /// A timeout for the authentication. Zero means the global default; if the
    /// global default is not set, the authentication timeout is 25 seconds.
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    pub fn auth_timeout(self, auth_timeout: i32) -> Self {
        Self {
            builder: self.builder.property("auth-timeout", auth_timeout),
        }
    }

    //pub fn ca_cert(self, ca_cert: /*Ignored*/&glib::Bytes) -> Self {
    //    Self { builder: self.builder.property("ca-cert", ca_cert), }
    //}

    /// The password used to access the CA certificate stored in
    /// #NMSetting8021x:ca-cert property. Only makes sense if the certificate
    /// is stored on a PKCS#<!-- -->11 token that requires a login.
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    pub fn ca_cert_password(self, ca_cert_password: impl Into<glib::GString>) -> Self {
        Self {
            builder: self
                .builder
                .property("ca-cert-password", ca_cert_password.into()),
        }
    }

    /// Flags indicating how to handle the #NMSetting8021x:ca-cert-password property.
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    pub fn ca_cert_password_flags(self, ca_cert_password_flags: SettingSecretFlags) -> Self {
        Self {
            builder: self
                .builder
                .property("ca-cert-password-flags", ca_cert_password_flags),
        }
    }

    /// UTF-8 encoded path to a directory containing PEM or DER formatted
    /// certificates to be added to the verification chain in addition to the
    /// certificate specified in the #NMSetting8021x:ca-cert property.
    ///
    /// If NMSetting8021x:system-ca-certs is enabled and the built-in CA
    /// path is an existing directory, then this setting is ignored.
    pub fn ca_path(self, ca_path: impl Into<glib::GString>) -> Self {
        Self {
            builder: self.builder.property("ca-path", ca_path.into()),
        }
    }

    //pub fn client_cert(self, client_cert: /*Ignored*/&glib::Bytes) -> Self {
    //    Self { builder: self.builder.property("client-cert", client_cert), }
    //}

    /// The password used to access the client certificate stored in
    /// #NMSetting8021x:client-cert property. Only makes sense if the certificate
    /// is stored on a PKCS#<!-- -->11 token that requires a login.
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    pub fn client_cert_password(self, client_cert_password: impl Into<glib::GString>) -> Self {
        Self {
            builder: self
                .builder
                .property("client-cert-password", client_cert_password.into()),
        }
    }

    /// Flags indicating how to handle the #NMSetting8021x:client-cert-password property.
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    pub fn client_cert_password_flags(
        self,
        client_cert_password_flags: SettingSecretFlags,
    ) -> Self {
        Self {
            builder: self
                .builder
                .property("client-cert-password-flags", client_cert_password_flags),
        }
    }

    /// Constraint for server domain name. If set, this list of FQDNs is used as
    /// a match requirement for dNSName element(s) of the certificate presented
    /// by the authentication server.  If a matching dNSName is found, this
    /// constraint is met.  If no dNSName values are present, this constraint is
    /// matched against SubjectName CN using the same comparison.
    /// Multiple valid FQDNs can be passed as a ";" delimited list.
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    pub fn domain_match(self, domain_match: impl Into<glib::GString>) -> Self {
        Self {
            builder: self.builder.property("domain-match", domain_match.into()),
        }
    }

    /// Constraint for server domain name. If set, this FQDN is used as a suffix
    /// match requirement for dNSName element(s) of the certificate presented by
    /// the authentication server.  If a matching dNSName is found, this
    /// constraint is met.  If no dNSName values are present, this constraint is
    /// matched against SubjectName CN using same suffix match comparison.
    /// Since version 1.24, multiple valid FQDNs can be passed as a ";" delimited
    /// list.
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn domain_suffix_match(self, domain_suffix_match: impl Into<glib::GString>) -> Self {
        Self {
            builder: self
                .builder
                .property("domain-suffix-match", domain_suffix_match.into()),
        }
    }

    /// The allowed EAP method to be used when authenticating to the network with
    /// 802.1x.  Valid methods are: "leap", "md5", "tls", "peap", "ttls", "pwd",
    /// and "fast".  Each method requires different configuration using the
    /// properties of this setting; refer to wpa_supplicant documentation for the
    /// allowed combinations.
    pub fn eap(self, eap: impl Into<glib::StrV>) -> Self {
        Self {
            builder: self.builder.property("eap", eap.into()),
        }
    }

    /// Identity string for EAP authentication methods.  Often the user's user or
    /// login name.
    pub fn identity(self, identity: impl Into<glib::GString>) -> Self {
        Self {
            builder: self.builder.property("identity", identity.into()),
        }
    }

    /// Define openssl_ciphers for wpa_supplicant. Openssl sometimes moves ciphers
    /// among SECLEVELs, thus compiled-in default value in wpa_supplicant
    /// (as modified by some linux distributions) sometimes prevents
    /// to connect to old servers that do not support new protocols.
    #[cfg(feature = "v1_48")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_48")))]
    pub fn openssl_ciphers(self, openssl_ciphers: impl Into<glib::GString>) -> Self {
        Self {
            builder: self
                .builder
                .property("openssl-ciphers", openssl_ciphers.into()),
        }
    }

    /// Whether the 802.1X authentication is optional. If [`true`], the activation
    /// will continue even after a timeout or an authentication failure. Setting
    /// the property to [`true`] is currently allowed only for Ethernet connections.
    /// If set to [`false`], the activation can continue only after a successful
    /// authentication.
    #[cfg(feature = "v1_22")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
    pub fn optional(self, optional: bool) -> Self {
        Self {
            builder: self.builder.property("optional", optional),
        }
    }

    /// UTF-8 encoded file path containing PAC for EAP-FAST.
    pub fn pac_file(self, pac_file: impl Into<glib::GString>) -> Self {
        Self {
            builder: self.builder.property("pac-file", pac_file.into()),
        }
    }

    /// UTF-8 encoded password used for EAP authentication methods. If both the
    /// #NMSetting8021x:password property and the #NMSetting8021x:password-raw
    /// property are specified, #NMSetting8021x:password is preferred.
    pub fn password(self, password: impl Into<glib::GString>) -> Self {
        Self {
            builder: self.builder.property("password", password.into()),
        }
    }

    /// Flags indicating how to handle the #NMSetting8021x:password property.
    pub fn password_flags(self, password_flags: SettingSecretFlags) -> Self {
        Self {
            builder: self.builder.property("password-flags", password_flags),
        }
    }

    //pub fn password_raw(self, password_raw: /*Ignored*/&glib::Bytes) -> Self {
    //    Self { builder: self.builder.property("password-raw", password_raw), }
    //}

    /// Flags indicating how to handle the #NMSetting8021x:password-raw property.
    pub fn password_raw_flags(self, password_raw_flags: SettingSecretFlags) -> Self {
        Self {
            builder: self
                .builder
                .property("password-raw-flags", password_raw_flags),
        }
    }

    /// Specifies authentication flags to use in "phase 1" outer
    /// authentication using #NMSetting8021xAuthFlags options.
    /// The individual TLS versions can be explicitly disabled. TLS time checks
    /// can be also disabled. If a certain TLS disable flag is not
    /// set, it is up to the supplicant to allow or forbid it. The TLS options
    /// map to tls_disable_tlsv1_x and tls_disable_time_checks settings.
    /// See the wpa_supplicant documentation for more details.
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    pub fn phase1_auth_flags(self, phase1_auth_flags: u32) -> Self {
        Self {
            builder: self
                .builder
                .property("phase1-auth-flags", phase1_auth_flags),
        }
    }

    /// Enables or disables in-line provisioning of EAP-FAST credentials when
    /// FAST is specified as the EAP method in the #NMSetting8021x:eap property.
    /// Recognized values are "0" (disabled), "1" (allow unauthenticated
    /// provisioning), "2" (allow authenticated provisioning), and "3" (allow
    /// both authenticated and unauthenticated provisioning).  See the
    /// wpa_supplicant documentation for more details.
    pub fn phase1_fast_provisioning(
        self,
        phase1_fast_provisioning: impl Into<glib::GString>,
    ) -> Self {
        Self {
            builder: self
                .builder
                .property("phase1-fast-provisioning", phase1_fast_provisioning.into()),
        }
    }

    /// Forces use of the new PEAP label during key derivation.  Some RADIUS
    /// servers may require forcing the new PEAP label to interoperate with
    /// PEAPv1.  Set to "1" to force use of the new PEAP label.  See the
    /// wpa_supplicant documentation for more details.
    pub fn phase1_peaplabel(self, phase1_peaplabel: impl Into<glib::GString>) -> Self {
        Self {
            builder: self
                .builder
                .property("phase1-peaplabel", phase1_peaplabel.into()),
        }
    }

    /// Forces which PEAP version is used when PEAP is set as the EAP method in
    /// the #NMSetting8021x:eap property.  When unset, the version reported by
    /// the server will be used.  Sometimes when using older RADIUS servers, it
    /// is necessary to force the client to use a particular PEAP version.  To do
    /// so, this property may be set to "0" or "1" to force that specific PEAP
    /// version.
    pub fn phase1_peapver(self, phase1_peapver: impl Into<glib::GString>) -> Self {
        Self {
            builder: self
                .builder
                .property("phase1-peapver", phase1_peapver.into()),
        }
    }

    /// List of strings to be matched against the altSubjectName of the
    /// certificate presented by the authentication server during the inner
    /// "phase 2" authentication. If the list is empty, no verification of the
    /// server certificate's altSubjectName is performed.
    pub fn phase2_altsubject_matches(
        self,
        phase2_altsubject_matches: impl Into<glib::StrV>,
    ) -> Self {
        Self {
            builder: self.builder.property(
                "phase2-altsubject-matches",
                phase2_altsubject_matches.into(),
            ),
        }
    }

    /// Specifies the allowed "phase 2" inner authentication method when an EAP
    /// method that uses an inner TLS tunnel is specified in the #NMSetting8021x:eap
    /// property.  For TTLS this property selects one of the supported non-EAP
    /// inner methods: "pap", "chap", "mschap", "mschapv2" while
    /// #NMSetting8021x:phase2-autheap selects an EAP inner method.  For PEAP
    /// this selects an inner EAP method, one of: "gtc", "otp", "md5" and "tls".
    /// Each "phase 2" inner method requires specific parameters for successful
    /// authentication; see the wpa_supplicant documentation for more details.
    /// Both #NMSetting8021x:phase2-auth and #NMSetting8021x:phase2-autheap cannot
    /// be specified.
    pub fn phase2_auth(self, phase2_auth: impl Into<glib::GString>) -> Self {
        Self {
            builder: self.builder.property("phase2-auth", phase2_auth.into()),
        }
    }

    /// Specifies the allowed "phase 2" inner EAP-based authentication method
    /// when TTLS is specified in the #NMSetting8021x:eap property.  Recognized
    /// EAP-based "phase 2" methods are "md5", "mschapv2", "otp", "gtc", and
    /// "tls". Each "phase 2" inner method requires specific parameters for
    /// successful authentication; see the wpa_supplicant documentation for
    /// more details.
    pub fn phase2_autheap(self, phase2_autheap: impl Into<glib::GString>) -> Self {
        Self {
            builder: self
                .builder
                .property("phase2-autheap", phase2_autheap.into()),
        }
    }

    //pub fn phase2_ca_cert(self, phase2_ca_cert: /*Ignored*/&glib::Bytes) -> Self {
    //    Self { builder: self.builder.property("phase2-ca-cert", phase2_ca_cert), }
    //}

    /// The password used to access the "phase2" CA certificate stored in
    /// #NMSetting8021x:phase2-ca-cert property. Only makes sense if the certificate
    /// is stored on a PKCS#<!-- -->11 token that requires a login.
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    pub fn phase2_ca_cert_password(
        self,
        phase2_ca_cert_password: impl Into<glib::GString>,
    ) -> Self {
        Self {
            builder: self
                .builder
                .property("phase2-ca-cert-password", phase2_ca_cert_password.into()),
        }
    }

    /// Flags indicating how to handle the #NMSetting8021x:phase2-ca-cert-password property.
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    pub fn phase2_ca_cert_password_flags(
        self,
        phase2_ca_cert_password_flags: SettingSecretFlags,
    ) -> Self {
        Self {
            builder: self.builder.property(
                "phase2-ca-cert-password-flags",
                phase2_ca_cert_password_flags,
            ),
        }
    }

    /// UTF-8 encoded path to a directory containing PEM or DER formatted
    /// certificates to be added to the verification chain in addition to the
    /// certificate specified in the #NMSetting8021x:phase2-ca-cert property.
    ///
    /// If NMSetting8021x:system-ca-certs is enabled and the built-in CA
    /// path is an existing directory, then this setting is ignored.
    pub fn phase2_ca_path(self, phase2_ca_path: impl Into<glib::GString>) -> Self {
        Self {
            builder: self
                .builder
                .property("phase2-ca-path", phase2_ca_path.into()),
        }
    }

    //pub fn phase2_client_cert(self, phase2_client_cert: /*Ignored*/&glib::Bytes) -> Self {
    //    Self { builder: self.builder.property("phase2-client-cert", phase2_client_cert), }
    //}

    /// The password used to access the "phase2" client certificate stored in
    /// #NMSetting8021x:phase2-client-cert property. Only makes sense if the certificate
    /// is stored on a PKCS#<!-- -->11 token that requires a login.
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    pub fn phase2_client_cert_password(
        self,
        phase2_client_cert_password: impl Into<glib::GString>,
    ) -> Self {
        Self {
            builder: self.builder.property(
                "phase2-client-cert-password",
                phase2_client_cert_password.into(),
            ),
        }
    }

    /// Flags indicating how to handle the #NMSetting8021x:phase2-client-cert-password property.
    #[cfg(feature = "v1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_8")))]
    pub fn phase2_client_cert_password_flags(
        self,
        phase2_client_cert_password_flags: SettingSecretFlags,
    ) -> Self {
        Self {
            builder: self.builder.property(
                "phase2-client-cert-password-flags",
                phase2_client_cert_password_flags,
            ),
        }
    }

    /// Constraint for server domain name. If set, this list of FQDNs is used as
    /// a match requirement for dNSName element(s) of the certificate presented
    /// by the authentication server during the inner "phase 2" authentication.
    /// If a matching dNSName is found, this constraint is met.  If no dNSName
    /// values are present, this constraint is matched against SubjectName CN
    /// using the same comparison.
    /// Multiple valid FQDNs can be passed as a ";" delimited list.
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    pub fn phase2_domain_match(self, phase2_domain_match: impl Into<glib::GString>) -> Self {
        Self {
            builder: self
                .builder
                .property("phase2-domain-match", phase2_domain_match.into()),
        }
    }

    /// Constraint for server domain name. If set, this FQDN is used as a suffix
    /// match requirement for dNSName element(s) of the certificate presented by
    /// the authentication server during the inner "phase 2" authentication.  If
    /// a matching dNSName is found, this constraint is met.  If no dNSName
    /// values are present, this constraint is matched against SubjectName CN
    /// using same suffix match comparison.
    /// Since version 1.24, multiple valid FQDNs can be passed as a ";" delimited
    /// list.
    #[cfg(feature = "v1_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_2")))]
    pub fn phase2_domain_suffix_match(
        self,
        phase2_domain_suffix_match: impl Into<glib::GString>,
    ) -> Self {
        Self {
            builder: self.builder.property(
                "phase2-domain-suffix-match",
                phase2_domain_suffix_match.into(),
            ),
        }
    }

    //pub fn phase2_private_key(self, phase2_private_key: /*Ignored*/&glib::Bytes) -> Self {
    //    Self { builder: self.builder.property("phase2-private-key", phase2_private_key), }
    //}

    /// The password used to decrypt the "phase 2" private key specified in the
    /// #NMSetting8021x:phase2-private-key property when the private key either
    /// uses the path scheme, or is a PKCS#<!-- -->12 format key.  Setting this
    /// property directly is not generally necessary except when returning
    /// secrets to NetworkManager; it is generally set automatically when setting
    /// the private key by the nm_setting_802_1x_set_phase2_private_key()
    /// function.
    pub fn phase2_private_key_password(
        self,
        phase2_private_key_password: impl Into<glib::GString>,
    ) -> Self {
        Self {
            builder: self.builder.property(
                "phase2-private-key-password",
                phase2_private_key_password.into(),
            ),
        }
    }

    /// Flags indicating how to handle the
    /// #NMSetting8021x:phase2-private-key-password property.
    pub fn phase2_private_key_password_flags(
        self,
        phase2_private_key_password_flags: SettingSecretFlags,
    ) -> Self {
        Self {
            builder: self.builder.property(
                "phase2-private-key-password-flags",
                phase2_private_key_password_flags,
            ),
        }
    }

    /// Substring to be matched against the subject of the certificate presented
    /// by the authentication server during the inner "phase 2"
    /// authentication. When unset, no verification of the authentication server
    /// certificate's subject is performed. This property provides little security,
    /// if any, and should not be used.
    /// Use #NMSetting8021x:phase2-domain-suffix-match instead.
    #[cfg_attr(feature = "v1_2", deprecated = "Since 1.2")]
    pub fn phase2_subject_match(self, phase2_subject_match: impl Into<glib::GString>) -> Self {
        Self {
            builder: self
                .builder
                .property("phase2-subject-match", phase2_subject_match.into()),
        }
    }

    /// PIN used for EAP authentication methods.
    pub fn pin(self, pin: impl Into<glib::GString>) -> Self {
        Self {
            builder: self.builder.property("pin", pin.into()),
        }
    }

    /// Flags indicating how to handle the #NMSetting8021x:pin property.
    pub fn pin_flags(self, pin_flags: SettingSecretFlags) -> Self {
        Self {
            builder: self.builder.property("pin-flags", pin_flags),
        }
    }

    //pub fn private_key(self, private_key: /*Ignored*/&glib::Bytes) -> Self {
    //    Self { builder: self.builder.property("private-key", private_key), }
    //}

    /// The password used to decrypt the private key specified in the
    /// #NMSetting8021x:private-key property when the private key either uses the
    /// path scheme, or if the private key is a PKCS#<!-- -->12 format key.  Setting this
    /// property directly is not generally necessary except when returning
    /// secrets to NetworkManager; it is generally set automatically when setting
    /// the private key by the nm_setting_802_1x_set_private_key() function.
    pub fn private_key_password(self, private_key_password: impl Into<glib::GString>) -> Self {
        Self {
            builder: self
                .builder
                .property("private-key-password", private_key_password.into()),
        }
    }

    /// Flags indicating how to handle the #NMSetting8021x:private-key-password
    /// property.
    pub fn private_key_password_flags(
        self,
        private_key_password_flags: SettingSecretFlags,
    ) -> Self {
        Self {
            builder: self
                .builder
                .property("private-key-password-flags", private_key_password_flags),
        }
    }

    /// Substring to be matched against the subject of the certificate presented
    /// by the authentication server. When unset, no verification of the
    /// authentication server certificate's subject is performed. This property
    /// provides little security, if any, and should not be used.
    /// Use #NMSetting8021x:phase2-domain-suffix-match instead.
    #[cfg_attr(feature = "v1_2", deprecated = "Since 1.2")]
    pub fn subject_match(self, subject_match: impl Into<glib::GString>) -> Self {
        Self {
            builder: self.builder.property("subject-match", subject_match.into()),
        }
    }

    /// When [`true`], overrides the #NMSetting8021x:ca-path and
    /// #NMSetting8021x:phase2-ca-path properties using the system CA directory
    /// specified at configure time with the --system-ca-path switch.  The
    /// certificates in this directory are added to the verification chain in
    /// addition to any certificates specified by the #NMSetting8021x:ca-cert and
    /// #NMSetting8021x:phase2-ca-cert properties. If the path provided with
    /// --system-ca-path is rather a file name (bundle of trusted CA certificates),
    /// it overrides #NMSetting8021x:ca-cert and #NMSetting8021x:phase2-ca-cert
    /// properties instead (sets ca_cert/ca_cert2 options for wpa_supplicant).
    pub fn system_ca_certs(self, system_ca_certs: bool) -> Self {
        Self {
            builder: self.builder.property("system-ca-certs", system_ca_certs),
        }
    }

    // rustdoc-stripper-ignore-next
    /// Build the [`Setting8021x`].
    #[must_use = "Building the object from the builder is usually expensive and is not expected to have side effects"]
    pub fn build(self) -> Setting8021x {
        assert_initialized_main_thread!();
        self.builder.build()
    }
}
